<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    归档: 2016
  
</title>

<meta name="description" content="努力、专注、坚信">
<meta property="og:type" content="website">
<meta property="og:title" content="findmoon-白色蜗牛">
<meta property="og:url" content="//findmoon.github.io/index.html/archives/2016/page/3/index.html">
<meta property="og:site_name" content="findmoon-白色蜗牛">
<meta property="og:description" content="努力、专注、坚信">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="findmoon-白色蜗牛">
<meta name="twitter:description" content="努力、专注、坚信">




  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">findmoon-白色蜗牛</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">findmoon-白色蜗牛</a></h1>
    
      <p class="subtitle">
        一个试图专注于自身的成长者
      </p>
    
    <div class="info">
      <div class="content">
        
          <div class="description">努力、专注、坚信</div>
        
        
          <div class="author">findmoon</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="http://i2.piimg.com/81760750547ee122.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">132</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/方法-实例/">方法/实例</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">10</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFC/">BFC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backbone/">Backbone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3动画/">CSS3动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS解析域名/">DNS解析域名</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOCTYPE/">DOCTYPE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MV模式/">MV模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mocha/">Mocha</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP三次握手/">TCP三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNICODE-ASCII/">UNICODE/ASCII</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate/">animate()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate动画队列/">animate动画队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/background-image/">background-image</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border/">border</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border图形/">border图形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/box-shadow/">box-shadow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console-log/">console.log()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css属性/">css属性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css样式/">css样式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deferred/">deferred</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/delete/">delete</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-child/">first-child</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-of-type/">first-of-type</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/float/">float</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font-face/">font-face</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/form表单/">form表单</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/get/">get</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitbash/">gitbash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git错误/">git错误</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haslayout/">haslayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http状态码/">http状态码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inline-block/">inline-block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/input/">input</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/">instanceof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof-typeof/">instanceof/typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js严格模式/">js严格模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js加载/">js加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js模板引擎/">js模板引擎</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list-style/">list-style</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meta/">meta</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offset/">offset()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overflow/">overflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/placeholder/">placeholder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position/">position</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position文档流/">position文档流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/post/">post</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scopechain/">scopechain</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stringify/">stringify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/">typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/undefined/">undefined</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/url加载/">url加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zoom/">zoom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码书写/">代码书写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列表/">列表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画animation/">动画animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量/">变量</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同源跨域/">同源跨域</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字面量/">字面量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/库与架构/">库与架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学函数/">数学函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据包组装/">数据包组装</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法/">方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记语言/">标记语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化编程/">模块化编程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/立即执行函数/">立即执行函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站访问/">网站访问</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/获取路径/">获取路径</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行内元素/">行内元素</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求/">跨域请求</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求处理方法/">跨域请求处理方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择器/">选择器</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">161</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
            
              <li>
                <a href="/work" title="work">work</a>
              </li>
            
          
            
              <li>
                <a href="/about" title="about">about</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="http://findmoon.github.io/" title="findmoon" target="_blank" rel="external">findmoon</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/findmoon/findmoon.github.io" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/archives/2016" class="archive-year">2016</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法/" >
  阮一峰的网络日志*Javascript模块化编程（三）require.js的用法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法/"><span class="article-date">
  2016-05-31
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h1 id="Javascript模块化编程（三）require-js的用法"><a href="#Javascript模块化编程（三）require-js的用法" class="headerlink" title="Javascript模块化编程（三）require.js的用法"></a>Javascript模块化编程（三）require.js的用法</h1><p>原文地址：<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a></p>
<h2 id="一、为什么要用require-js？"><a href="#一、为什么要用require-js？" class="headerlink" title="一、为什么要用require.js？"></a>一、为什么要用require.js？</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码依次加载多个js文件。<br>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。<br>require.js的诞生，就是为了解决这两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![](http://image.beekka.com/blog/201211/bg2012110701.png)</span><br><span class="line">	（1）实现js文件的异步加载，避免网页失去响应；</span><br><span class="line">　　（2）管理模块之间的依赖性，便于代码的编写和维护。</span><br></pre></td></tr></table></figure>
<h2 id="二、require-js的加载"><a href="#二、require-js的加载" class="headerlink" title="二、require.js的加载"></a>二、require.js的加载</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。</p>
<p>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h2 id="三、主模块的写法"><a href="#三、主模块的写法" class="headerlink" title="三、主模块的写法"></a>三、主模块的写法</h2><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。</p>
<p>下面就来看，怎么写main.js。</p>
<p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　alert(&quot;加载成功！&quot;);</span><br></pre></td></tr></table></figure>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>下面，我们看一个实际的例子。</p>
<p>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h2 id="四、模块的加载"><a href="#四、模块的加载" class="headerlink" title="四、模块的加载"></a>四、模块的加载</h2><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。</p>
<p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　baseUrl: &quot;js/lib&quot;,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个<a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="external">优化工具</a>，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h2 id="五、AMD模块的写法"><a href="#五、AMD模块的写法" class="headerlink" title="五、AMD模块的写法"></a>五、AMD模块的写法</h2><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>假定现在有一个math.js文件，它定义了一个math模块。那么,math.js就要这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　// math.js</span><br><span class="line">　　define(function ()&#123;</span><br><span class="line">　　　　var add = function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>加载方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　require([&apos;math&apos;], function (math)&#123;</span><br><span class="line">　　　　alert(math.add(1,1));</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　define([&apos;myLib&apos;], function(myLib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h2 id="六、加载非规范的模块"><a href="#六、加载非规范的模块" class="headerlink" title="六、加载非规范的模块"></a>六、加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>回答是可以的。</p>
<p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　&apos;underscore&apos;:&#123;</span><br><span class="line">　　　　　　　　exports: &apos;_&apos;</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　&apos;backbone&apos;: &#123;</span><br><span class="line">　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],</span><br><span class="line">　　　　　　　　exports: &apos;Backbone&apos;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义<strong>（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</strong></p>
<p>比如，jQuery的插件可以这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　shim: &#123;</span><br><span class="line">　　　　&apos;jquery.scroll&apos;: &#123;</span><br><span class="line">　　　　　　deps: [&apos;jquery&apos;],</span><br><span class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、require-js插件"><a href="#七、require-js插件" class="headerlink" title="七、require.js插件"></a>七、require.js插件</h2><p>require.js还提供一系列<a href="https://github.com/requirejs/requirejs/wiki/Plugins" target="_blank" rel="external">插件</a>，实现一些特定的功能。</p>
<p>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;domready!&apos;], function (doc)&#123;</span><br><span class="line">　　　　// called once the DOM is ready</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　define([</span><br><span class="line">　　　　&apos;text!review.txt&apos;,</span><br><span class="line">　　　　&apos;image!cat.jpg&apos;</span><br><span class="line">　　　　],</span><br><span class="line"></span><br><span class="line">　　　　function(review,cat)&#123;</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure>
<p>类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范/" >
  阮一峰的网络日志*Javascript模块化编程（二）AMD规范
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范/"><span class="article-date">
  2016-05-31
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h1 id="Javascript模块化编程（二）AMD规范"><a href="#Javascript模块化编程（二）AMD规范" class="headerlink" title="Javascript模块化编程（二）AMD规范"></a>Javascript模块化编程（二）AMD规范</h1><p>原文地址 <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a></p>
<h2 id="七、模块的规范"><a href="#七、模块的规范" class="headerlink" title="七、模块的规范"></a>七、模块的规范</h2><p>先想一想，为什么模块很重要？</p>
<p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p>
<p>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。</p>
<p>目前，通行的Javascript模块规范共有两种：<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>。这里主要介绍AMD，但是要先从CommonJS讲起。</p>
<h2 id="八、CommonJS"><a href="#八、CommonJS" class="headerlink" title="八、CommonJS"></a>八、CommonJS</h2><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p><img src="http://image.beekka.com/blog/201210/bg2012103002.jpg" alt=""></p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br></pre></td></tr></table></figure></p>
<p>然后，就可以调用模块提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br><span class="line">　　math.add(2,3); // 5</span><br></pre></td></tr></table></figure>
<p>因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。</p>
<p>#九、浏览器环境</p>
<p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br><span class="line">　　math.add(2, 3);</span><br></pre></td></tr></table></figure>
<p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h2 id="十、AMD"><a href="#十、AMD" class="headerlink" title="十、AMD"></a>十、AMD</h2><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　require([module], callback);</span><br></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　　　　math.add(2, 3);</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="external">curl.js</a>。本系列的第三部分，将通过介绍require.js，进一步讲解AMD的用法，以及如何将模块化编程投入实战。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法/" >
  阮一峰的网络日志*Javascript模块化编程（一）模块的写法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法/"><span class="article-date">
  2016-05-31
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>原文地址：<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>
<h1 id="Javascript模块化编程（一）模块的写法"><a href="#Javascript模块化编程（一）模块的写法" class="headerlink" title="Javascript模块化编程（一）模块的写法"></a>Javascript模块化编程（一）模块的写法</h1><p>网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。</p>
<p>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还未广泛应用。）</p>
<h2 id="一、原始写法"><a href="#一、原始写法" class="headerlink" title="一、原始写法"></a>一、原始写法</h2><p>模块就是实现特定功能的一组方法。</p>
<p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　function m1()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line">　　function m2()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。</p>
<p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<p>##二、对象写法<br>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = new Object(&#123;</span><br><span class="line">　　　　_count : 0,</span><br><span class="line">　　　　m1 : function ()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　m2 : function ()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　module1.m1();</span><br></pre></td></tr></table></figure>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　module1._count = 5;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、立即执行函数写法"><a href="#三、立即执行函数写法" class="headerlink" title="三、立即执行函数写法"></a>三、立即执行函数写法</h2><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function()&#123;</span><br><span class="line">　　　　var _count = 0;</span><br><span class="line">　　　　var m1 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　var m2 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　m1 : m1,</span><br><span class="line">　　　　　　m2 : m2</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;)();</span><br></pre></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的_count变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></p>
<p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<h2 id="四、放大模式"><a href="#四、放大模式" class="headerlink" title="四、放大模式"></a>四、放大模式</h2><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function (mod)&#123;</span><br><span class="line">　　　　mod.m3 = function () &#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return mod;</span><br><span class="line">　　&#125;)(module1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<h2 id="五、宽放大模式（Loose-augmentation）"><a href="#五、宽放大模式（Loose-augmentation）" class="headerlink" title="五、宽放大模式（Loose augmentation）"></a>五、宽放大模式（Loose augmentation）</h2><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = ( function (mod)&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　　　return mod;</span><br><span class="line">　　&#125;)(window.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<h2 id="六、输入全局变量"><a href="#六、输入全局变量" class="headerlink" title="六、输入全局变量"></a>六、输入全局变量</h2><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function ($, YAHOO) &#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">《JavaScript Module Pattern: In-Depth》</a>。</p>
<p>这个系列的第二部分，将讨论如何在浏览器环境组织不同的模块、管理模块之间的依赖性。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/28/jQuery对象/" >
  
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/28/jQuery对象/"><span class="article-date">
  2016-05-28
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>jQuery对象与原生对象的转换</p>
<p>$(原生对象)变为jQuery对象<br>jQuery对象[0]变为原生对象，即以取数组下标的方式<br>jQuery对象eq(0)获取jQuery对象</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/27/jQuery中animate动画队列的停止和清除/" >
  jQuery中animate动画队列的停止和清除
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/27/jQuery中animate动画队列的停止和清除/"><span class="article-date">
  2016-05-27
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animate动画队列/">animate动画队列</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>jQuery中animate动画队列的停止和清除,转载自<a href="http://www.css88.com/" target="_blank" rel="external">web前端开发</a></p>
<blockquote>
<p>.finish([queue ])<br>描述: 停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画<br>当.finish()在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值（愚人码头注：就是所有动画的目标值）。所有排队的动画将被删除。</p>
</blockquote>
<p>如果第一个参数提供，该字符串表示的队列中的动画将被停止。</p>
<p>.finish()方法和.stop(true, true)很相似，.stop(true, true)将清除队列，并且目前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的CSS属性跳转到他们的最终值。</p>
<p><em>动画可能因为全局的$.fx.off 属性设置为 true而停止。当这样做时，所有动画方法将立即设置元素的css属性为其最终调用后的状态，而不是显示动画效果。</em></p>
<p>例子:</p>
<p>Click the Go button once to start the animation, and then click the other buttons to see how they affect the current and queued animations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;.box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 10px;</span><br><span class="line">  left: 10px;</span><br><span class="line">  width: 15px;</span><br><span class="line">  height: 15px;</span><br><span class="line">  background: black;</span><br><span class="line">&#125;</span><br><span class="line">#path &#123;</span><br><span class="line">  height: 244px;</span><br><span class="line">  font-size: 70%;</span><br><span class="line">  border-left: 2px dashed red;</span><br><span class="line">  border-bottom: 2px dashed green;</span><br><span class="line">  border-right: 2px dashed blue;</span><br><span class="line">&#125;</span><br><span class="line">button &#123;</span><br><span class="line">  width: 12em;</span><br><span class="line">  display: block;</span><br><span class="line">  text-align: left;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;path&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;go&quot;&gt;Go&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bstt&quot; class=&quot;b&quot;&gt;.stop(true,true)&lt;/button&gt;</span><br><span class="line">  &lt;button id=&quot;bcf&quot; class=&quot;b&quot;&gt;.clearQueue().finish()&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bstf&quot; class=&quot;b&quot;&gt;.stop(true, false)&lt;/button&gt;</span><br><span class="line">  &lt;button id=&quot;bcs&quot; class=&quot;b&quot;&gt;.clearQueue().stop()&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bsff&quot; class=&quot;b&quot;&gt;.stop(false, false)&lt;/button&gt;</span><br><span class="line">  &lt;button id=&quot;bs&quot; class=&quot;b&quot;&gt;.stop()&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bsft&quot; class=&quot;b&quot;&gt;.stop(false, true)&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bf&quot; class=&quot;b&quot;&gt;.finish()&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var horiz = $(&quot;#path&quot;).width() - 20,</span><br><span class="line">    vert = $(&quot;#path&quot;).height() - 20;</span><br><span class="line"> </span><br><span class="line">var btns = &#123;</span><br><span class="line">  bstt: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(true, true);</span><br><span class="line">  &#125;,</span><br><span class="line">  bs: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop();</span><br><span class="line">  &#125;,</span><br><span class="line">  bsft: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(false, true);</span><br><span class="line">  &#125;,</span><br><span class="line">  bf: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).finish();</span><br><span class="line">  &#125;,</span><br><span class="line">  bcf: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).clearQueue().finish();</span><br><span class="line">  &#125;,</span><br><span class="line">  bsff: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(false, false);</span><br><span class="line">  &#125;,</span><br><span class="line">  bstf: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(true, false);</span><br><span class="line">  &#125;,</span><br><span class="line">  bcs: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).clearQueue().stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">$(&quot;button.b&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class="line">  btns[this.id]();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">$(&quot;#go&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class="line">  $(&quot;.box&quot;)</span><br><span class="line">    .clearQueue()</span><br><span class="line">    .stop()</span><br><span class="line">    .css(&#123;</span><br><span class="line">    left: 10,</span><br><span class="line">    top: 10</span><br><span class="line">  &#125;)</span><br><span class="line">    .animate(&#123;</span><br><span class="line">    top: vert</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">    .animate(&#123;</span><br><span class="line">    left: horiz</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">    .animate(&#123;</span><br><span class="line">    top: 10</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.css88.com/jqapi-1.9/finish/" target="_blank" rel="external">具体演示效果参看原网页</a></p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/Javascript的this用法/" >
  Javascript的this用法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/Javascript的this用法/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this/">this</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>Javascript的this用法</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">转载-阮一峰的网络日志</a></p>
<ul>
<li>this是Javascript语言的一个关键字。</li>
</ul>
<p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。<br>下面分四种情况，详细讨论this的用法。</p>
<h3 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h3><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。<br>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p>
<p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p>
<p>运行结果还是1。再变一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 0;</span><br><span class="line">　　&#125;</span><br><span class="line">　　test();</span><br><span class="line">　　alert(x); //0</span><br></pre></td></tr></table></figure></p>
<h3 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h3><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = &#123;&#125;;</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m(); // 1</span><br></pre></td></tr></table></figure></p>
<h3 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 作为构造函数调用</h3><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(o.x); // 1</span><br></pre></td></tr></table></figure></p>
<p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 2;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(x); //2</span><br></pre></td></tr></table></figure></p>
<p>运行结果为2，表明全局变量x的值根本没变。</p>
<h3 id="情况四-apply调用"><a href="#情况四-apply调用" class="headerlink" title="情况四 apply调用"></a>情况四 apply调用</h3><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 0;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o=&#123;&#125;;</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m.apply(); //0</span><br></pre></td></tr></table></figure></p>
<p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。<br>如果把最后一行代码修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　o.m.apply(o); //1</span><br></pre></td></tr></table></figure></p>
<p>运行结果就变成了1，证明了这时this代表的是对象o。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/单元测试框架与mock介绍/" >
  单元测试框架与mock介绍*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/单元测试框架与mock介绍/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mock/">mock</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://baidutech.blog.51cto.com/4114344/743740/" target="_blank" rel="external">原文地址</a></p>
<h2 id="单元测试框架的优点与一些问题"><a href="#单元测试框架的优点与一些问题" class="headerlink" title="单元测试框架的优点与一些问题"></a>单元测试框架的优点与一些问题</h2><p>在单元测试中引入单测框架使得编写单测用例时，不需要再关注于如何驱动case的执行，如何收集结果，如何管理case集，只需要关注于如何写好单个测试用例即可；同时，在一些测试框架中通过提供丰富的断言集，公用方法，以及运行参数使得编写单个testcase的过程得到了最大的简化。</p>
<p>那这其中会存在什么样的疑问了？</p>
<p>我在单元测试框架中写一个TestCase，与我单独写一个cpp文件在main()方法里写测试代码有什么本质却别吗？用了单元测试框架，并没有解决我在对复杂系统做单测时遇到的问题。</p>
<p>没错，对于单个case这两者从本质上说是没有区别的。单元测试框架本身并没有告诉你如何去写TestCase，在这一点上他是没有提供任何帮助的。所以对于一些复杂的场景，只用单元测试框架是有点多少显得无能为力的。</p>
<p>使用单元测试框架往往适用于以下场景的测试：单个函数，一个class，或者几个功能相关class的测试，对于纯函数测试，接口级别的测试尤其适用，如房贷计算器公式的测试。</p>
<p>但是，对于一些复杂场景：<br> 被测对象依赖复杂，甚至无法简单new出这个对象<br> 对于一些failure场景的测试<br> 被测对象中涉及多线程合作<br> 被测对象通过消息与外界交互的场景<br> …</p>
<p>单纯依赖单测框架是无法实现单元测试的，而从某种意义上来说，这些场景反而是测试中的重点。</p>
<p>以分布式系统的测试为例，class 与 function级别的单元测试对整个系统的帮助不大，当然，这种单元测试对单个程序的质量有帮助；分布式系统测试的要点是测试进程间的交互：一个进程收到客户请求，该如何处理，然后转发给其他进程；收到响应之后，又修改并应答客户；同时分布式系统测试中通常更关注一些异常路径的测试，这些场景才是测试中的重点，也是难点所在。</p>
<p>Mock方法的引入通常能帮助我们解决以上场景中遇到的难题。</p>
<h2 id="Mock的引入带来了什么"><a href="#Mock的引入带来了什么" class="headerlink" title="Mock的引入带来了什么"></a>Mock的引入带来了什么</h2><p>在维基百科上这样描述Mock：In object-oriented programming, mock objects are simulated objects that mimic the behavior of real objects in controlled ways. A computer programmer typically creates a mock object to test the behavior of some other object, in much the same way that a car designer uses a crash test dummy to simulate the dynamic behavior. of a human in vehicle impacts.</p>
<p>Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。</p>
<p>引入Mock最大的优势在于：Mock的行为固定，它确保当你访问该Mock的某个方法时总是能够获得一个没有任何逻辑的直接就返回的预期结果。</p>
<p>Mock Object的使用通常会带来以下一些好处：</p>
<p> 隔绝其他模块出错引起本模块的测试错误。<br> 隔绝其他模块的开发状态，只要定义好接口，不用管他们开发有没有完成。<br> 一些速度较慢的操作，可以用Mock Object代替，快速返回。<br>对于分布式系统的测试，使用Mock Object会有另外两项很重要的收益：<br> 通过Mock Object可以将一些分布式测试转化为本地的测试<br> 将Mock用于压力测试，可以解决测试集群无法模拟线上集群大规模下的压力</p>
<h2 id="Mock的应用场景"><a href="#Mock的应用场景" class="headerlink" title="Mock的应用场景"></a>Mock的应用场景</h2><p>在使用Mock的过程中，发现Mock是有一些通用性的，对于一些应用场景，是非常适合使用Mock的：</p>
<blockquote>
<p>真实对象具有不可确定的行为(产生不可预测的结果，如股票的行情)<br> 真实对象很难被创建(比如具体的web容器)<br> 真实对象的某些行为很难触发(比如网络错误)<br> 真实情况令程序的运行速度很慢<br> 真实对象有用户界面<br> 测试需要询问真实对象它是如何被调用的(比如测试可能需要验证某个回调函数是否被调用了)<br> 真实对象实际上并不存在(当需要和其他开发小组，或者新的硬件系统打交道的时候，这是一个普遍的问题)<br>当然，也有一些不得不Mock的场景：<br> 一些比较难构造的Object：这类Object通常有很多依赖，在单元测试中构造出这样类通常花费的成本太大。<br> 执行操作的时间较长Object：有一些Object的操作费时，而被测对象依赖于这一个操作的执行结果，例如大文件写操作，数据的更新等等，出于测试的需求，通常将这类操作进行Mock。<br> 异常逻辑：一些异常的逻辑往往在正常测试中是很难触发的，通过Mock可以人为的控制触发异常逻辑。</p>
</blockquote>
<p>在一些压力测试的场景下，也不得不使用Mock，例如在分布式系统测试中，通常需要测试一些单点（如namenode，jobtracker）在压力场景下的工作是否正常。而通常测试集群在正常逻辑下无法提供足够的压力（主要原因是受限于机器数量），这时候就需要应用Mock去满足。</p>
<p>在这些场景下，我们应该如何去做Mock的工作了，一些现有的Mock工具可以帮助我们进行Mock工作。</p>
<h2 id="Mock工具的介绍"><a href="#Mock工具的介绍" class="headerlink" title="Mock工具的介绍"></a>Mock工具的介绍</h2><p>手动的构造 Mock 对象通常带来额外的编码量，而且这些为创建 Mock 对象而编写的代码很有可能引入错误。</p>
<p>目前，有许多开源项目对动态构建 Mock 对象提供了支持，这些项目能够根据现有的接口或类动态生成，这样不仅能避免额外的编码工作，同时也降低了引入错误的可能。</p>
<p>C++: GoogleMock <a href="http://code.google.com/p/googlemock/" target="_blank" rel="external">http://code.google.com/p/googlemock/</a><br>Java: EasyMock <a href="http://easymock.org/" target="_blank" rel="external">http://easymock.org/</a></p>
<p>通常Mock工具通过简单的方法对于给定的接口生成 Mock 对象的类库。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。通过这些Mock工具我们可以方便的构造 Mock 对象从而使单元测试顺利进行，能够应用于更加复杂的测试场景。</p>
<p>以EasyMock为例，通过 EasyMock，我们可以为指定的接口动态的创建 Mock 对象，并利用 Mock 对象来模拟协同模块，从而使单元测试顺利进行。这个过程大致可以划分为以下几个步骤：</p>
<p> 使用 EasyMock 生成 Mock 对象<br> 设定 Mock 对象的预期行为和输出<br> 将 Mock 对象切换到 Replay 状态<br> 调用 Mock 对象方法进行单元测试<br> 对 Mock 对象的行为进行验证</p>
<p>EasyMock的使用和原理： <a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/</a></p>
<p>EasyMock 后台处理的主要原理是利用 java.lang.reflect.Proxy 为指定的接口创建一个动态代理，这个动态代理，就是我们在编码中用到的 Mock 对象。EasyMock 还为这个动态代理提供了一个 InvocationHandler 接口的实现，这个实现类的主要功能就是将动态代理的预期行为记录在某个映射表中和在实际调用时从这个映射表中取出预期输出。</p>
<p>借助类似于EasyMock这样工具，大大降低了编写Mock对象的成本，通常来说Mock工具依赖于单元测试框架，为用户编写TestCase提供便利，但是本身依赖于单元测试框架去驱动，管理case，以及收集测试结果。例如EasyMock依赖于JUint，GoogleMock依赖于Gtest。</p>
<p>那么有了单元测试框架和相应的Mock工具就万事俱备了，还有什么样的问题？正如单元测试框架没有告诉你如何写TestCase一样，Mock工具也没有告诉你如何去选择Mock的点。</p>
<h2 id="如何选择恰当的mock点"><a href="#如何选择恰当的mock点" class="headerlink" title="如何选择恰当的mock点"></a>如何选择恰当的mock点</h2><p>对于Mock这里存在两个误区，1.是Mock的对象越多越好；2.Mock会引入巨大的工作量，通常得不偿失。这都是源于不恰当的Mock点的选取。</p>
<p>这里说的如何选择恰当的mock点，是说对于一个被测对象，我们应当在外围选择恰当的mock对象，以及需要mock的接口。因为对于任意一个对象，任意一段代码逻辑我们都是有办法进行Mock的，而Mock点选择直接决定了我们Mock的工作量以及测试效果。从另外一种意义上来说，不恰当Mock选择反而会对我们的测试产生误导，从而在后期的集成和系统测试中引入更多的问题。</p>
<p>在mock点的选择过程中，以下的一些点会是一些不错的选择</p>
<blockquote>
<p> 网络交互：如果两个被测模块之间是通过网络进行交互的，那么对于网络交互进行Mock通常是比较合适的，如RPC<br> 外部资源：比如文件系统、数据源，如果被测对象对此类外部资源依赖性非常强，而其行为的不可预测性很可能导致测试的随机失败，此类的外部资源也适合进行Mock。<br> UI：因为UI很多时候都是用户行为触发事件，系统本身只是对这些触发事件进行相应，对这类UI做Mock，往往能够实现很好的收益，很多基于关键字驱动的框架都是基于UI进行Mock的<br> 第三方API：当接口属于使用者，通过Mock该接口来确定测试使用者与接口的交互。</p>
</blockquote>
<p>当然如何做Mock一定是与被系统的特性精密关联的，一些强制性的约束和规范是不合适的。这里介绍几个做的比较好的mock的例子。</p>
<ol>
<li>杀毒软件更新部署模块的Mock</li>
</ol>
<p>这个例子源于一款杀毒产品的更新部署模块的测试。对于一个杀毒软件客户端而言，需要通过更新检查模块与病毒库Server进行交互，如果发现病毒库有更新则触发病毒库部署模块的最新病毒库的数据请求和部署工作，要求部署完成后杀毒软件客户端能够正常工作。</p>
<p><img src="/img/191927452.jpg" alt=""></p>
<p>对于这一场景的测试，当时受限于这样一个条件，通常的病毒库server通常最多一天只更新一次病毒库，也就是说如果使用真实的病毒库server，那么针对更新部署模块的测试一天只能被触发一次。这是测试中所不能容忍的，通过对病毒库server进行mock可以解决这个问题。</p>
<p>对于这个场景可以采取这样一种Mock方式：用一个本地文件夹来模拟病毒库server，选择更新部署模块与病毒库server之间交互的两个函数checkVersion()，reqData()函数进行Mock。</p>
<p>checkVersion()工作原先的工作是检查病毒库Server的版本号，以决定是否触发更新，将其行为Mock为检查一个本地文件夹中病毒库的版本号；reqData()原有的行为是从病毒库Server拖取病毒库文件，将其Mock为从本地文件夹中拖取病毒库文件。通过这种方式我们用一个本地文件夹Mock病毒库Server的行为，其带来的产出是：我们可以随意的触发病毒库更新操作以及各种异常。</p>
<p>通过这种方式发现了一个在更新部署过程中，病毒库Server的病毒库版本发生改变造成出错的严重bug，这个是在原有一天才触发一次更新操作的情况下永远也无法发现的。</p>
<ol>
<li>分布式系统中对NameNode模块的测试</li>
</ol>
<p><img src="/img/191936107.jpg" alt=""></p>
<p>在测试NameNode模块的过程中存在这样一个问题，在正常逻辑无压力条件下NameNode模块都是工作正常的。但是线上集群在大压力的情况下，是有可能触发NameNode的问题的。但是原有的测试方法下，我们是无法对NameNode模拟大压力的场景的（因为NameNode的压力主要来源于DateNode数量，而我们测试集群是远远无法达到线上几千台机器的规模的），而NameNode单点的性能瓶颈问题恰恰是测试的重点，真实的DataNode是无法满足测试需求的，我们必须对DataNode进行Mock。</p>
<p><img src="/img/191948572.jpg" alt=""></p>
<p>如何对DateNode进行Mock了，最直观的想法是选择NameNode与DataNode之间的交互接口进行Mock，也就是他们之间的RPC交互，但是由于NameNode与DataNode之间的交互信息种类很多，所以其实这并不是一种很好的选择。<br>换个角度来想，NameNode之上的压力是源于对HDFS的读写操作造成的NameNode上元数据的维护，也就是说，对于NameNode而言，其实他并不关心数据到底写到哪里去了，只关心数据是否读写成功。如果是这种场景Mock就可以变的简单了，我们可以直接将DataNode上对块的操作进行mock，比如，对一次写请求，DataNode并不触发真实的写操作，而直接返回成功。通过这种方式，DataNode去除了执行功能，只保留了消息交互功能，间接的实现了我们的测试需求，且工作量比之第一种方案小很多。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/12种不宜使用的Javascript语法/" >
  12种不宜使用的Javascript语法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/12种不宜使用的Javascript语法/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>12种不宜使用的Javascript语法</p>
<p><a href="">转-阮一峰的网络日志</a></p>
<p>《Javascript语言精粹》的附录B中，Douglas Crockford列出了12种应该避免使用的Javascript语法，非常值得推广。</p>
<ol>
<li>==<br>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。<br>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：<br>　　false == ‘false’<br>　　false == undefined<br>　　false == null<br>　　null == undefined<br>　　0 == ‘’<br>前三个是false，后两个是true。</li>
<li>with<br>with的本意是减少键盘输入。比如<br>　　obj.a = obj.b;<br>　　obj.c = obj.d;<br>可以简写成<br>　　with(obj) {<br>　　　　a = b;<br>　　　　c = d;<br>　　}<br>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</li>
<li>eval<br>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。<br>eval能够做到的事情，不用它也能做到。比如<br>　　eval(“myValue = myObject.” + myKey + “;”);<br>可以直接写成<br>　　myValue = myObject[myKey];<br>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行。</li>
<li>continue<br>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</li>
<li>switch 贯穿<br>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如<br>　　switch(n) {<br>　　　　case 1:<br>　　　　case 2:<br>　　　　　　break;<br>　　}<br>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。<br>　　switch(n) {<br>　　　　case 1:<br>　　　　　　break;<br>　　　　case 2:<br>　　　　　　break;<br>　　}</li>
<li>单行的块结构<br>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如<br>　　if (ok) t = true;<br>甚至写成<br>　　if (ok)<br>　　　　t = true;<br>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。<br>　　if (ok){<br>　　　　t = true;<br>　　}</li>
<li>++和–<br>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</li>
<li>位运算符<br>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。<br>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</li>
<li>function语句<br>在Javascript中定义一个函数，有两种写法：<br>　　function foo() { }<br>和<br>　　var foo = function () { }<br>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</li>
<li>基本数据类型的包装对象<br>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：<br>　　new String(“Hello World”);<br>　　new Number(2000);<br>　　new Boolean(false);<br>这样写完全没有必要，而且非常费解，因此建议不要使用。<br>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</li>
<li>new语句<br>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。<br>类是这样定义的：<br>　　var Cat = function (name) {<br>　　　　this.name = name;<br>　　　　this.saying = ‘meow’ ;<br>　　}<br>然后，再生成一个对象<br>　　var myCat = new Cat(‘mimi’);<br>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。<br>Douglas Crockford给出了一个函数：<br>　　Object.beget = function (o) {<br>　　　　var F = function (o) {};<br>　　　　F.prototype = o ;<br>　　　　return new F;<br>　　};<br>创建对象时就利用这个函数，对原型对象进行操作：<br>　　var Cat = {<br>　　　　name:’’,<br>　　　　saying:’meow’<br>　　};<br>　　var myCat = Object.beget(Cat);<br>对象生成后，可以自行对相关属性进行赋值：<br>　　myCat.name = ‘mimi’;</li>
<li>void<br>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。<br>　　void 0; // undefined<br>这个命令没什么用，而且很令人困惑，建议避免使用。</li>
</ol>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/MVC，MVP 和 MVVM 的图示/" >
  MVC，MVP 和 MVVM 的图示
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/MVC，MVP 和 MVVM 的图示/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/web/">web</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MV模式/">MV模式</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>MVC，MVP 和 MVVM 的图示</p>
<p>[原文地址-阮一峰的网络日志]（<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html）" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html）</a></p>
<p>复杂的软件必须有清晰合理的架构，否则无法开发和维护。<br>MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。</p>
<h2 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h2><p>MVC模式的意思是，软件可以分成三个部分。</p>
<p><img src="/img/mvvm/bg2015020104.png" alt=""></p>
<blockquote>
<p>视图（View）：用户界面。<br>控制器（Controller）：业务逻辑<br>模型（Model）：数据保存</p>
</blockquote>
<p>各部分之间的通信方式如下。</p>
<p><img src="/img/mvvm/bg2015020105.png" alt=""></p>
<blockquote>
<p>View 传送指令到 Controller<br>Controller 完成业务逻辑后，要求 Model 改变状态<br>Model 将新的数据发送到 View，用户得到反馈</p>
</blockquote>
<p>所有通信都是单向的。</p>
<h2 id="二、互动模式"><a href="#二、互动模式" class="headerlink" title="二、互动模式"></a>二、互动模式</h2><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。</p>
<p><img src="/img/mvvm/bg2015020106.png" alt=""></p>
<p>另一种是直接通过controller接受指令。</p>
<p><img src="/img/mvvm/bg2015020107.png" alt=""></p>
<h2 id="三、实例：Backbone"><a href="#三、实例：Backbone" class="headerlink" title="三、实例：Backbone"></a>三、实例：Backbone</h2><p>实际项目往往采用更灵活的方式，以 Backbone.js 为例。</p>
<p><img src="/img/mvvm/bg2015020108.png" alt=""></p>
<ol>
<li>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</li>
<li>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</li>
<li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</li>
</ol>
<h2 id="四、MVP"><a href="#四、MVP" class="headerlink" title="四、MVP"></a>四、MVP</h2><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<p><img src="/img/mvvm/bg2015020109.png" alt=""></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<h2 id="五、MVVM"><a href="#五、MVVM" class="headerlink" title="五、MVVM"></a>五、MVVM</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p><img src="/img/mvvm/bg2015020110.png" alt=""></p>
<p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/界面之下：还原真实的 MVC、MVP、MVVM 模式/" >
  界面之下：还原真实的 MVC、MVP、MVVM 模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/界面之下：还原真实的 MVC、MVP、MVVM 模式/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/web/">web</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MV模式/">MV模式</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>界面之下：还原真实的 MVC、MVP、MVVM 模式</p>
<p>转载自： <a href="https://github.com/livoras/blog/issues/11作者：" target="_blank" rel="external">https://github.com/livoras/blog/issues/11作者：</a> 戴嘉华</p>
<h2 id="GUI程序所面临的问题"><a href="#GUI程序所面临的问题" class="headerlink" title="GUI程序所面临的问题"></a>GUI程序所面临的问题</h2><p>图形界面的应用程序提供给用户可视化的操作界面，这个界面提供给数据和信息。用户输入行为（键盘，鼠标等）会执行一些应用逻辑，应用逻辑（application logic）可能会触发一定的业务逻辑（business logic）对应用程序数据的变更，数据的变更自然需要用户界面的同步变更以提供最准确的信息。例如用户对一个电子表格重新排序的操作，应用程序需要响应用户操作，对数据进行排序，然后需要同步到界面上。</p>
<p>在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离（Speration of Duties）的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会把管理用户界面的层次称为View，应用程序的数据为Model（注意这里的Model指的是Domain Model，这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以简单理解为对象）。Model提供数据操作的接口，执行相应的业务逻辑。</p>
<p><img src="/img/mvvm/687406e67.png" alt=""></p>
<p>有了View和Model的分层，那么问题就来了：View如何同步Model的变更，View和Model之间如何粘合在一起。</p>
<p>带着这个问题开始探索MV<em>模式，会发现这些模式之间的差异可以归纳为对这个问题处理的方式的不同。而几乎所有的MV</em>模式都是经典的Smalltalk-80 MVC的修改版。</p>
<h2 id="Smalltalk-80-MVC"><a href="#Smalltalk-80-MVC" class="headerlink" title="Smalltalk-80 MVC"></a>Smalltalk-80 MVC</h2><h3 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h3><p>早在上个世纪70年代，美国的施乐公司（Xerox）的工程师研发了Smalltalk编程语言，并且开始用它编写图形界面的应用程序。而在Smalltalk-80这个版本的时候，一位叫Trygve Reenskaug的工程师设计了MVC图形应用程序的架构模式，极大地降低了图形应用程序的管理难度。而在四人帮（GoF）的设计模式当中并没有把MVC当做是设计模式，而仅仅是把它看成解决问题的一些类的集合。Smalltalk-80 MVC和GoF描述的MVC是最经典的MVC模式。</p>
<h3 id="MVC的依赖关系"><a href="#MVC的依赖关系" class="headerlink" title="MVC的依赖关系"></a>MVC的依赖关系</h3><p>MVC出了把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责为进行Model和View之间的协作（路由、输入预处理等）的应用逻辑（application logic）；Model进行处理业务逻辑。Model、View、Controller三个层次的依赖关系如下：</p>
<p><img src="/img/mvvm/32d6465702e706e67.png" alt=""></p>
<p>Controller和View都依赖Model层，Controller和View可以互相依赖。在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。</p>
<h3 id="MVC的调用关系"><a href="#MVC的调用关系" class="headerlink" title="MVC的调用关系"></a>MVC的调用关系</h3><p>用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller会对来自View数据进行预处理、决定调用哪个Model的接口；然后由Model执行相关的业务逻辑；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。如下图：</p>
<p><img src="/img/mvvm/d76632d6361706e67.png" alt=""></p>
<p>看似没有什么特别的地方，但是由几个需要特别关注的关键点：</p>
<ol>
<li>View是把控制权交移给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。</li>
<li>Controller操作Model，Model执行业务逻辑对数据进行处理。但不会直接操作View，可以说它是对View无知的。</li>
<li>View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。</li>
</ol>
<p>需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很多对于MVC的描述都没有强调这一点。通过观察者模式的好处就是：不同的MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接受到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。我们每天都在用的观察者模式，在几十年前就已经被大神们整合到MVC的架构当中。</p>
<p>这里有一个MVC模式的JavaScript Demo，实现了一个小的TodoList应用程序。经典的Smalltalk-80 MVC不需要任何框架支持就可以实现。目前Web前端框架当中只有一个号称是严格遵循Smalltalk-80 MVC模式的：maria.js。</p>
<h4 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h4><p>优点：</p>
<ol>
<li>把业务逻辑和展示逻辑分离，模块化程度高。且当应用逻辑需要变更的时候，不需要变更业务逻辑和展示逻辑，只需要Controller换成另外一个Controller就行了（Swappable Controller）。</li>
<li>观察者模式可以做到多视图同时更新。</li>
</ol>
<p>缺点：</p>
<ol>
<li>Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。</li>
<li>View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的</li>
</ol>
<h3 id="MVC-Model-2"><a href="#MVC-Model-2" class="headerlink" title="MVC Model 2"></a>MVC Model 2</h3><p>在Web服务端开发的时候也会接触到MVC模式，而这种MVC模式不能严格称为MVC模式。经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效。服务端的MVC模式又自己特定的名字：MVC Model 2，或者叫JSP Model 2，或者直接就是Model 2 。Model 2客户端服务端的交互模式如下：</p>
<p><img src="/img/mvvm/64656c322e706e67.png" alt=""></p>
<p>服务端接收到来自客户端的请求，服务端通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的应用逻辑，对Model进行操作，Model执行业务逻辑以后；然后用数据去渲染特定的模版，返回给客户端。</p>
<p>因为HTTP协议是单工协议并且是无状态的，服务器无法直接给客户端推送数据。除非客户端再次发起请求，否则服务器端的Model的变更就无法告知客户端。所以可以看到经典的Smalltalk-80 MVC中Model通过观察者模式告知View更新这一环被无情地打破，不能称为严格的MVC。</p>
<p>Model 2模式最早在1998年应用在JSP应用程序当中，JSP Model 1应用管理的混乱诱发了JSP参考了客户端MVC模式，催生了Model 2。</p>
<p><img src="/img/mvvm/06e67.png" alt=""></p>
<p>后来这种模式几乎被应用在所有语言的Web开发框架当中。PHP的ThinkPHP，Python的Dijango、Flask，NodeJS的Express，Ruby的RoR，基本都采纳了这种模式。平常所讲的MVC基本是这种服务端的MVC。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP模式有两种：</p>
<ol>
<li>Passive View</li>
<li>Supervising Controller</li>
</ol>
<p>而大多数情况下讨论的都是Passive View模式。本文会对PV模式进行较为详细的介绍，而SC模式则简单提及。</p>
<h3 id="历史背景-1"><a href="#历史背景-1" class="headerlink" title="历史背景"></a>历史背景</h3><p>MVP模式是MVC模式的改良。在上个世纪90年代，IBM旗下的子公司Taligent在用C/C++开发一个叫CommonPoint的图形界面应用系统的时候提出来的。</p>
<h3 id="MVP（Passive-View）的依赖关系"><a href="#MVP（Passive-View）的依赖关系" class="headerlink" title="MVP（Passive View）的依赖关系"></a>MVP（Passive View）的依赖关系</h3><p>MVP模式把MVC模式中的Controller换成了Presenter。MVP层次之间的依赖关系如下：</p>
<p><img src="/img/mvvm/e706e67.png" alt=""></p>
<p>MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。</p>
<h3 id="MVP（Passive-View）的调用关系"><a href="#MVP（Passive-View）的调用关系" class="headerlink" title="MVP（Passive View）的调用关系"></a>MVP（Passive View）的调用关系</h3><p>既然View对Model的依赖被打破了，那View如何同步Model的变更？看看MVP的调用关系：</p>
<p><img src="/img/mvvm/c6c2e706e67.png" alt=""></p>
<p>和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。</p>
<p>关键点：</p>
<ol>
<li>View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有应用程序逻辑也有同步逻辑。</li>
<li>View需要提供操作界面的接口给Presenter进行调用。（关键）</li>
</ol>
<p>对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口；而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但由Presenter监听而不是View。</p>
<p>MVP模式，这里也提供一个用JavaScript编写的例子。</p>
<h3 id="MVP（Passive-View）的优缺点"><a href="#MVP（Passive-View）的优缺点" class="headerlink" title="MVP（Passive View）的优缺点"></a>MVP（Passive View）的优缺点</h3><p>优点：</p>
<ol>
<li>便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。</li>
<li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li>
</ol>
<p>缺点：</p>
<ol>
<li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</li>
</ol>
<h3 id="MVP（Supervising-Controller）"><a href="#MVP（Supervising-Controller）" class="headerlink" title="MVP（Supervising Controller）"></a>MVP（Supervising Controller）</h3><p>上面讲的是MVP的Passive View模式，该模式下View非常Passive，它几乎什么都不知道，Presenter让它干什么它就干什么。而Supervising Controller模式中，Presenter会把一部分简单的同步逻辑交给View自己去做，Presenter只负责比较复杂的、高层次的UI操作，所以可以把它看成一个Supervising Controller。</p>
<p>Supervising Controller模式下的依赖和调用关系：</p>
<p><img src="/img/mvvm/66f72617327.png" alt=""></p>
<p>因为Supervising Controller用得比较少，对它的讨论就到这里为止。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。</p>
<h3 id="历史背景-2"><a href="#历史背景-2" class="headerlink" title="历史背景"></a>历史背景</h3><p>MVVM模式最早是微软公司提出，并且了大量使用在.NET的WPF和Sliverlight中。2005年微软工程师John Gossman在自己的博客上首次公布了MVVM模式。</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>MVVM代表的是Model-View-ViewModel，这里需要解释一下什么是ViewModel。ViewModel的含义就是 “Model of View”，视图的模型。它的含义包含了领域模型（Domain Model）和视图的状态（State）。 在图形界面应用程序当中，界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态是顺序的还是逆序的，而这是Domain Model所不包含的，但也是需要显示的信息。</p>
<p>可以简单把ViewModel理解为页面上所显示内容的数据抽象，和Domain Model不一样，ViewModel更适合用来描述View。</p>
<h3 id="MVVM的依赖"><a href="#MVVM的依赖" class="headerlink" title="MVVM的依赖"></a>MVVM的依赖</h3><p>MVVM的依赖关系和MVP依赖，只不过是把P换成了VM。</p>
<p><img src="/img/mvvm/e696f2f66e67.png" alt=""></p>
<h3 id="MVVM的调用关系"><a href="#MVVM的调用关系" class="headerlink" title="MVVM的调用关系"></a>MVVM的调用关系</h3><p>MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。</p>
<p><img src="/img/mvvm/632f6d76766.png" alt=""></p>
<p>也就是说，MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。</p>
<p>这里有一个JavaScript MVVM的例子，因为MVVM需要Binder引擎。所以例子中使用了一个MVVM的库：<a href="https://github.com/livoras/MVW-demos/blob/master/src/scripts/mvvm.js" target="_blank" rel="external">Vue.js</a>。</p>
<h3 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h3><p>优点：</p>
<ol>
<li>提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。</li>
<li>简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</li>
</ol>
<p>缺点：</p>
<ol>
<li>过于简单的图形界面不适用，或说牛刀杀鸡。</li>
<li>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。</li>
<li>数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可以看到，从MVC-&gt;MVP-&gt;MVVM，就像一个打怪升级的过程。后者解决了前者遗留的问题，把前者的缺点优化成了优点。同样的Demo功能，代码从最开始的一堆文件，优化成了最后只需要20几行代码就完成。MV*模式之间的区分还是蛮清晰的，希望可以给对这些模式理解比较模糊的同学带来一些参考和思路。</p>

        
      </div>
    </div>

  



  <div class="pagination">
    <a class="extend prev" rel="prev" href="/archives/2016/page/2/">上一页</a><a class="page-number" href="/archives/2016/">1</a><a class="page-number" href="/archives/2016/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/archives/2016/page/4/">4</a><a class="page-number" href="/archives/2016/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2016/page/17/">17</a><a class="extend next" rel="next" href="/archives/2016/page/4/">下一页</a>
  </div>




          <div class="main-footer">
  
    © 2016 findmoon-白色蜗牛 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
