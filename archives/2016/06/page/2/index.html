<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    归档: 2016/6
  
</title>

<meta name="description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
<meta property="og:type" content="website">
<meta property="og:title" content="findmoon-白色蜗牛">
<meta property="og:url" content="//findmoon.github.io/index.html/archives/2016/06/page/2/index.html">
<meta property="og:site_name" content="findmoon-白色蜗牛">
<meta property="og:description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="findmoon-白色蜗牛">
<meta name="twitter:description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">




  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">findmoon-白色蜗牛</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">findmoon-白色蜗牛</a></h1>
    
      <p class="subtitle">
        一个试图专注于自身的成长者
      </p>
    
    <div class="info">
      <div class="content">
        
          <div class="description">人生是一场不断的转换，我们总是不断地试着所向披靡</div>
        
        
          <div class="author">findmoon</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="http://i2.piimg.com/81760750547ee122.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">134</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/方法-实例/">方法/实例</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">10</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFC/">BFC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backbone/">Backbone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3动画/">CSS3动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS解析域名/">DNS解析域名</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOCTYPE/">DOCTYPE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MV模式/">MV模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mocha/">Mocha</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP三次握手/">TCP三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNICODE-ASCII/">UNICODE/ASCII</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate/">animate()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate动画队列/">animate动画队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/background-image/">background-image</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border/">border</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border图形/">border图形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/box-shadow/">box-shadow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console-log/">console.log()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css属性/">css属性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css样式/">css样式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deferred/">deferred</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/delete/">delete</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-child/">first-child</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-of-type/">first-of-type</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/float/">float</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font-face/">font-face</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/form表单/">form表单</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/get/">get</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitbash/">gitbash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git错误/">git错误</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haslayout/">haslayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http状态码/">http状态码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inline-block/">inline-block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/input/">input</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/">instanceof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof-typeof/">instanceof/typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js严格模式/">js严格模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js加载/">js加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js模板引擎/">js模板引擎</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list-style/">list-style</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meta/">meta</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offset/">offset()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overflow/">overflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/placeholder/">placeholder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position/">position</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position文档流/">position文档流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/post/">post</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scopechain/">scopechain</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stringify/">stringify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/">typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/undefined/">undefined</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/url加载/">url加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zoom/">zoom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码书写/">代码书写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列表/">列表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画animation/">动画animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量/">变量</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同源跨域/">同源跨域</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字面量/">字面量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/库与架构/">库与架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学函数/">数学函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据包组装/">数据包组装</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法/">方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记语言/">标记语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化编程/">模块化编程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/立即执行函数/">立即执行函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简历/">简历</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站访问/">网站访问</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/获取路径/">获取路径</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行内元素/">行内元素</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求/">跨域请求</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求处理方法/">跨域请求处理方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择器/">选择器</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">162</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
            
              <li>
                <a href="/work" title="work">work</a>
              </li>
            
          
            
              <li>
                <a href="/about" title="about">about</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="http://findmoon.github.io/" title="findmoon" target="_blank" rel="external">findmoon</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/findmoon/findmoon.github.io" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/archives/2016" class="archive-year">2016</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/09/jQuery动画animate()方法小介绍介绍/" >
  jQuery动画animate()方法小介绍介绍
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/09/jQuery动画animate()方法小介绍介绍/"><span class="article-date">
  2016-06-09
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animate/">animate()</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>.animate()是jQuery实现动画的一种方法，它接受一个必选参数(properties,动画所要改变的属性)，和三个可选参数[, duration ] [, easing ] [, complete ] 。</p>
<ul>
<li>[, duration ] 字符串或者数字决定动画将运行多久,默认: 400。</li>
<li>[, easing ]一个字符串，表示过渡使用哪种缓动函数,jQuery自身提供”linear” 和 “swing”,默认: swing</li>
<li>[, complete ]  Function()在动画完成时执行的函数。</li>
</ul>
<p>Function()函数是一个很重要的参数方法<br>看如下jQuery操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;div&apos;).animate(&#123;height: 0&#125;,500).hide();</span><br></pre></td></tr></table></figure>
<p>div原来宽高是300px和400px，想要实现的功能是让div的高度变为0，然后再隐藏，这里采用jQuery的链式写法。但实际效果是div元素直接消失，也就是直接hide().原因是height的变化有一个持续500毫秒的时间，在这个动画执行时就已经执行.hide()隐藏。所以看不到效果。</p>
<p>要想看到效果就必须把hide()放到动画完成后，所以可以这样改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;div&apos;).animate(&#123;height: 0&#125;,500,function()&#123;</span><br><span class="line">		$(&apos;div&apos;).hide();</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>这样隐藏操作就会在动画完成后执行。<br><strong>这个操作在需要动画完成后进行一些列方法调用的时候用很大的用处</strong></p>
<p>更具体的使用可以参看这个中文文档：<a href="http://www.css88.com/jqapi-1.9/animate/" target="_blank" rel="external">http://www.css88.com/jqapi-1.9/animate/</a></p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/06/字面量简介/" >
  字面量简介
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/06/字面量简介/"><span class="article-date">
  2016-06-06
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字面量/">字面量</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <ul>
<li>字面量简介：</li>
</ul>
<p>在计算机科学中，字面量(literal)是用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如:整数、浮点数以及字符串;而有很多也对布尔类型和字符类型的值也支持字面量表示;还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</p>
<p>在编程语言中，字面量是一种表示值的记法。例如，”Hello, World!” 在许多语言中都表示一个字符串字面量（string literal ），JavaScript也不例外。以下也是JavaScript字面量的例子，如5、true、false和null，它们分别表示一个整数、两个布尔值和一个空对象。</p>
<ul>
<li>JavaScript还支持对象和数组字面量，允许使用一种简洁而可读的记法来创建数组和对象。考虑以下语句，其中创建了一个包含两个属性的对象（firstName和lastName）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">o.name = &apos;Byron&apos;;</span><br><span class="line">o.age = 24;</span><br></pre></td></tr></table></figure>
<p>上面是创建对象的方法，可以使用下面字面量的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Byron&apos;,</span><br><span class="line">    age:24</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上赋值语句的右边是一个对象字面量（object literal）。对象字面量是一个名值对列表，每个名值对之间用逗号分隔，并用一个大括号括起。各名值对表示对象的一个属性，名和值这两部分之间用一个冒号分隔。要创建一个数组，可以创建Array对象的一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a=new Array();</span><br><span class="line">a.push(1,2,3);</span><br></pre></td></tr></table></figure>
<p>不过首选的方法是使用一个数组字面量（array literal），这是一个用逗号分隔的值列表，用中括号括起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br></pre></td></tr></table></figure>
<ul>
<li>函数字面量（function literal）如下构造：前面是一个function关键字，后面是一个函数名（可选）和参数表。然后是函数体，包围在大括号中。</li>
</ul>
<p>赋给team变量的对象有3个属性：name、members和count</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var team = &#123;</span><br><span class="line">	name: &apos;hard&apos;,</span><br><span class="line">	work: &apos;learn&apos;,</span><br><span class="line">	sum: function()&#123; return 1+2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript对象记法（JavaScript Object Notation，JSON），这是一种用于描述文件和数组的记法，由JavaScript字面量的一个子集组成。JSON在Ajax开发人员中越来越流行，因为这种格式可以用于交换数据，通常取代了XML。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">对象字面量：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //只能添加静态属性和方法</span><br><span class="line">   var myObject=&#123;</span><br><span class="line">     propertyA: sha ,</span><br><span class="line">     propertyB: feng ,</span><br><span class="line">     methodA:function()&#123;</span><br><span class="line">      alert(this.propertyA++this.propertyB);</span><br><span class="line">     &#125;,</span><br><span class="line">     methodB:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    myObject.methodA();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //利用prototype属性可以添加公有属性和方法</span><br><span class="line">   </span><br><span class="line">   function myConstructor2()&#123;&#125;;  //声明构造函数，可以使用对象字面量语法来向prototype属性中添加所有公有成员</span><br><span class="line">   </span><br><span class="line">    myConstructor2.prototype=&#123;</span><br><span class="line">     propertyA: sha ,</span><br><span class="line">     propertyB: feng ,</span><br><span class="line">     methodA:function()&#123;</span><br><span class="line">      alert(this.propertyA++this.propertyB);</span><br><span class="line">     &#125;,</span><br><span class="line">     methodB:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   var myconstrustor=new myConstructor2(); //声明对象</span><br><span class="line">    myconstrustor.methodA();</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/yxf2011/archive/2012/04/01/2428225.html" target="_blank" rel="external">参考链接</a></p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/05/JavaSript模块规范-AMD规范与CMD规范介绍/" >
  JavaSript模块规范-AMD规范与CMD规范介绍*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/05/JavaSript模块规范-AMD规范与CMD规范介绍/"><span class="article-date">
  2016-06-05
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deferred/">deferred</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.cnblogs.com/dojo-lzz/p/4707725.html" target="_blank" rel="external">另一篇参考博客地址</a></p>
<p><a href="http://blog.chinaunix.net/uid-26672038-id-4112229.html" target="_blank" rel="external">JavaSript模块规范 - AMD规范与CMD规范介绍</a> </p>
<p>JavaSript模块化</p>
<p>在了解AMD，CMD规范前，还是需要先来简单地了解下什么是模块化，模块化开发？</p>
<p>模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。</p>
<p>还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。</p>
<p>首先，既然是模块化设计，那么作为一个模块化系统所必须的能力：</p>
<blockquote>
<ol>
<li>定义封装的模块。</li>
<li>定义新模块对其他模块的依赖。</li>
<li>可对其他模块的引入支持。</li>
</ol>
</blockquote>
<p>好了，思想有了，那么总要有点什么来建立一个模块化的规范制度吧，不然各式各样的模块加载方式只会将局搅得更为混乱。那么在JavaScript中出现了一些非传统模块开发方式的规范 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。</p>
<h2 id="AMD-与-RequireJS"><a href="#AMD-与-RequireJS" class="headerlink" title="AMD 与 RequireJS"></a>AMD 与 RequireJS</h2><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>Asynchronous Module Definition，用白话文讲就是 异步模块定义，对于 JSer 来说，异步是再也熟悉不过的词了，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<p>AMD规范定义了一个自由变量或者说是全局变量 define 的函数。</p>
<p>define( id?, dependencies?, factory ); </p>
<p>AMD规范  <a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki/AMD</a></p>
<blockquote>
<p>第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。</p>
<p>第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。</p>
<p>第三个参数，factory，是一个需要进行实例化的函数或者一个对象。</p>
</blockquote>
<ul>
<li>创建模块标识为 alpha 的模块，依赖于 require， export，和标识为 beta 的模块 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(&quot;alpha&quot;, [ &quot;require&quot;, &quot;exports&quot;, &quot;beta&quot; ], function( require, exports, beta )&#123;</span><br><span class="line">    export.verb = function()&#123;</span><br><span class="line">        return beta.verb();</span><br><span class="line">        // or:</span><br><span class="line">        return require(&quot;beta&quot;).verb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>一个返回对象字面量的异步模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([&quot;alpha&quot;], function( alpha )&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        verb : function()&#123;</span><br><span class="line">            return alpha.verb() + 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>无依赖模块可以直接使用对象字面量来定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( &#123;</span><br><span class="line">    add : function( x, y )&#123;</span><br><span class="line">        return x + y ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li>类似与 CommonJS 方式定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define( function( require, exports, module)&#123;</span><br><span class="line">    var a = require(&apos;a&apos;),</span><br><span class="line">          b = require(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">    exports.action = function()&#123;&#125;;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="require"><a href="#require" class="headerlink" title="require();"></a>require();</h3><p>require API 介绍 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki/require</a></p>
<p> 在 AMD 规范中的 require 函数与一般的 CommonJS中的 require 不同。由于动态检测依赖关系使加载异步，对于基于回调的 require 需求强烈。</p>
<h4 id="局部-与-全局-的require"><a href="#局部-与-全局-的require" class="headerlink" title="局部 与 全局 的require"></a>局部 与 全局 的require</h4><pre><code>局部的 require 需要在AMD模式中的 define 工厂函数中传入 require。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define( [&apos;require&apos;], function( require )&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125; );</span><br><span class="line">or：</span><br><span class="line">define( function( require, exports, module )&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>局部的 require 需要其他特定的 API 来实现。</p>
<p> 全局的 require 函数是唯一全局作用域下的变量，像 define一样。全局的 require 并不是规范要求的，但是如果实现全局的 require函数，那么其需要具有与局部 require 函数 一样的以下的限定：</p>
<blockquote>
<ol>
<li>模块标识视为绝对的，而不是相对的对应另一个模块标识。</li>
<li>只有在异步情况下，require的回调方式才被用来作为交互操作使用。因为他不可能在同步的情况下通过 require(String) 从顶层加载模块。</li>
</ol>
</blockquote>
<p>依赖相关的API会开始模块加载。如果需要有互操作的多个加载器，那么全局的 reqiure 应该被加载顶层模块来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">require(String)</span><br><span class="line">define( function( require )&#123;</span><br><span class="line">    var a = require(&apos;a&apos;); // 加载模块a</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">require(Array, Function)</span><br><span class="line">define( function( require )&#123;</span><br><span class="line">    require( [&apos;a&apos;, &apos;b&apos;], function( a,b )&#123; // 加载模块a b 使用</span><br><span class="line">        // 依赖 a b 模块的运行代码</span><br><span class="line">    &#125; ); </span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">require.toUrl( Url )</span><br><span class="line">define( function( require )&#123;</span><br><span class="line">    var temp = require.toUrl(&apos;./temp/a.html&apos;); // 加载页面</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>amdjs 的API   <a href="https://github.com/amdjs/amdjs-api/wiki" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki</a></p>
<h3 id="RequireJS"><a href="#RequireJS" class="headerlink" title="RequireJS"></a>RequireJS</h3><p>官网 <a href="http://www.requirejs.org/" target="_blank" rel="external">http://www.requirejs.org/</a> API <a href="http://www.requirejs.org/docs/api.html" target="_blank" rel="external">http://www.requirejs.org/docs/api.html</a></p>
<p> RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范，它的作者就是AMD规范的创始人 James Burke。所以说RequireJS是对AMD规范的阐述一点也不为过。</p>
<p> RequireJS 的基本思想为：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script data-main=&apos;scripts/main&apos; src=&apos;scripts/require.js&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>那么scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。</p>
<p>defined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。</p>
<ul>
<li><ol>
<li>独立模块，不依赖其他模块。直接定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    method1: function()&#123;&#125;,</span><br><span class="line">    method2: function()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>也等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        method1: function()&#123;&#125;,</span><br><span class="line">        method2: function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>非独立模块，对其他模块有依赖。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([ &apos;module1&apos;, &apos;module2&apos; ], function(m1, m2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( function( require )&#123;</span><br><span class="line">    var m1 = require( &apos;module1&apos; ),</span><br><span class="line">          m2 = require( &apos;module2&apos; );</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>简单看了一下RequireJS的实现方式，其 require 实现只不过是将 function 字符串然后提取 require 之后的模块名，将其放入依赖关系之中。</p>
<h3 id="require方法调用模块"><a href="#require方法调用模块" class="headerlink" title="require方法调用模块"></a>require方法调用模块</h3><pre><code>在require进行调用模块时，其参数与define类似。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require( [&apos;foo&apos;, &apos;bar&apos;], function( foo, bar )&#123;</span><br><span class="line">    foo.func();</span><br><span class="line">    bar.func();</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<pre><code>在加载 foo 与 bar 两个模块之后执行回调函数实现具体过程。

当然还可以如之前的例子中的，在define定义模块内部进行require调用模块
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( function( require )&#123;</span><br><span class="line">    var m1 = require( &apos;module1&apos; ),</span><br><span class="line">          m2 = require( &apos;module2&apos; );</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<pre><code>define 和 require 这两个定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。
</code></pre><h2 id="CMD-与-seaJS"><a href="#CMD-与-seaJS" class="headerlink" title="CMD 与 seaJS"></a>CMD 与 seaJS</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>在CMD中，一个模块就是一个文件，格式为：<br><strong> define( factory );</strong></p>
<p>全局函数define，用来定义模块。</p>
<p>参数 factory  可以是一个函数，也可以为对象或者字符串。</p>
<p>当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。</p>
<p>定义JSON数据模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123; &quot;foo&quot;: &quot;bar&quot; &#125;);</span><br></pre></td></tr></table></figure>
<p>通过字符串定义模板模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;this is &#123;&#123;data&#125;&#125;.&apos;);</span><br></pre></td></tr></table></figure>
<p>factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define( function(require, exports, module) &#123; </span><br><span class="line">    // 模块代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="define-id-deps-factory"><a href="#define-id-deps-factory" class="headerlink" title="define( id?, deps?, factory );"></a>define( id?, deps?, factory );</h4><p> define也可以接受两个以上的参数，字符串id为模块标识，数组deps为模块依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define( &apos;module&apos;, [&apos;module1&apos;, &apos;module2&apos;], function( require, exports, module )&#123;</span><br><span class="line">    // 模块代码</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>其与 AMD 规范用法不同。</p>
<p><strong>require 是 factory 的第一个参数。</strong></p>
<p> require( id );<br> 接受模块标识作为唯一的参数，用来获取其他模块提供的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function( require, exports )&#123;</span><br><span class="line">    var a = require(&apos;./a&apos;);</span><br><span class="line">    a.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  require.async( id, callback? );<br>  require是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( function(require, exports, module) &#123; </span><br><span class="line">    require.async(&apos;.a&apos;, function(a)&#123;</span><br><span class="line">        a.doSomething();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> require.resolve( id )<br> 可以使用模块内部的路径机制来返回模块路径，不会加载模块。</p>
<p> exports 是 factory 的第二个参数，用来向外提供模块接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">define(function( require, exports )&#123;</span><br><span class="line">    exports.foo = &apos;bar&apos;; // 向外提供的属性</span><br><span class="line">    exports.do = function()&#123;&#125;; // 向外提供的方法</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 当然也可以使用 return 直接向外提供接口。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define(function( require, exports )&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        foo : &apos;bar&apos;, // 向外提供的属性</span><br><span class="line">        do : function()&#123;&#125; // 向外提供的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">也可以简化为直接对象字面量的形式:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define(&#123;</span><br><span class="line">    foo : &apos;bar&apos;, // 向外提供的属性</span><br><span class="line">    do : function()&#123;&#125; // 向外提供的方法</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 与nodeJS中一样需要注意的是，一下方式是错误的：</span><br></pre></td></tr></table></figure>
<p>define(function( require, exports ){<br>    exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要这么做</span><br></pre></td></tr></table></figure></p>
<p>define(function( require, exports, module ){<br>    module.exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 传入的对象引用可以添加属性，一旦赋值一个新的对象，那么值钱传递进来的对象引用就会失效了。开始之初，exports 是作为 module.exports 的一个引用存在，一切行为只有在这个引用上 factory 才得以正常运行，赋值新的对象后就会断开引用，exports就只是一个新的对象引用，对于factory来说毫无意义，就会出错。</span><br><span class="line"></span><br><span class="line">- module 是factory的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法。</span><br><span class="line">  module.id 为模块的唯一标识。</span><br><span class="line">   module.uri 根据模块系统的路径解析规则得到模块的绝对路径。</span><br><span class="line">  module.dependencies 表示模块的依赖。</span><br><span class="line">  module.exports 当前模块对外提供的接口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## seaJS</span><br><span class="line">    官网 http://seajs.org/docs/</span><br><span class="line">    API快速参考 https://github.com/seajs/seajs/issues/266</span><br><span class="line">    sea.js 核心特征：</span><br><span class="line">        1. 遵循CMD规范，与NodeJS般的书写模块代码。</span><br><span class="line">        2. 依赖自动加载，配置清晰简洁。</span><br><span class="line">    兼容 Chrome 3+，Firefox 2+，Safari 3.2+，Opera 10+，IE 5.5+。</span><br><span class="line"></span><br><span class="line">    seajs.use </span><br><span class="line">    用来在页面中加载一个或者多个模块</span><br></pre></td></tr></table></figure></p>
<p>// 加载一个模块<br>seajs.use(‘./a’);<br>// 加载模块，加载完成时执行回调<br>seajs.use(‘./a’，function(a){<br>    a.doSomething();<br>});<br>// 加载多个模块执行回调<br>seajs.use([‘./a’,’./b’]，function(a , b){<br>    a.doSomething();<br>    b.doSomething();<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    其define 与 require 使用方式基本就是CMD规范中的示例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AMD 与 CMD 区别到底在哪里？</span><br><span class="line"></span><br><span class="line">    看了以上 AMD，requireJS 与 CMD， seaJS的简单介绍会有点感觉模糊，总感觉较为相似。因为像 requireJS 其并不是只是纯粹的AMD固有思想，其也是有CMD规范的思想，只不过是推荐 AMD规范方式而已， seaJS也是一样。</span><br><span class="line"></span><br><span class="line">    下面是玉伯对于 AMD 与 CMD 区别的解释：</span><br><span class="line"></span><br><span class="line">    AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</span><br><span class="line">    CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</span><br><span class="line"></span><br><span class="line">    类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出还有不少??</span><br><span class="line"></span><br><span class="line">    这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。</span><br><span class="line">    目前这些规范的实现都能达成浏览器端模块化开发的目的。</span><br><span class="line"></span><br><span class="line">    区别：</span><br><span class="line"></span><br><span class="line">    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</span><br><span class="line">    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：</span><br></pre></td></tr></table></figure></p>
<p>// CMD<br>define(function(require, exports, module) {<br>    var a = require(‘./a’)<br>    a.doSomething()<br>    // 此处略去 100 行<br>    var b = require(‘./b’) // 依赖可以就近书写<br>    b.doSomething()<br>    // …<br>})</p>
<p>// AMD 默认推荐的是<br>define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好<br>    a.doSomething()<br>    // 此处略去 100 行<br>    b.doSomething()<br>    // …<br>})<br>```</p>
<p>虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。</p>
<pre><code>3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。
</code></pre><p>另外，SeaJS 和 RequireJS 的差异，可以参考：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="external">https://github.com/seajs/seajs/issues/277</a></p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/05/测试驱动开发/" >
  TDD测试驱动开发*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/05/测试驱动开发/"><span class="article-date">
  2016-06-05
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/测试/">测试</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TDD/">TDD</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>另有一篇介绍<a href="http://www.vaikan.com/top-5-tdd-mistakes/" target="_blank" rel="external">测试驱动开发上的五大错误</a>,也可以看看</p>
<p><a href="http://www.360doc.com/content/07/0516/17/15822_503491.shtml" target="_blank" rel="external">转载自360图书馆</a><br>测试驱动开发（Test-Driven Development，TDD）是通过测试定义所要开发的功能的接口，然后实现功能的开发过程。<br>      Test-Driven Development(TDD)，是Extreme Programming (XP)–极限编程的一个重要组成部分。</p>
<h2 id="测试驱动开发TDD简介入门"><a href="#测试驱动开发TDD简介入门" class="headerlink" title="测试驱动开发TDD简介入门"></a>测试驱动开发TDD简介入门</h2><p>测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。</p>
<p>TDD 是通过测试定义所要开发的功能的接口，然后实现功能的开发过程。是<a href="http://www.itisedu.com/phrase/200604231325295.html" target="_blank" rel="external">Extreme Programming (XP)–极限编程</a>的一个重要组成部分。</p>
<p><img src="http://image.360doc.com/DownloadImg/15822/503491_1.jpg" alt=""></p>
<p>在上面的图中，列出的的是XP的12个团队实践。Test-Driven Development是其中之一。</p>
<ul>
<li><p>Kent Beck 的著作TDD(Test Driven Development) 中详细讲述了测试驱动开发。</p>
</li>
<li><p>当你使用TDD的时候一定要说明是测试驱动开发还是测试驱动设计。这两者是有区别的。测试驱动开发，是通过测试定义所要开发的功能的接口，然后实现功能的开发过程。对于测试驱动设计，在XP中似乎已经消失了，而是被测试驱动开发所取代。另外在XP中有用于描述设计的，SimpleDesign ，Design Improvement.</p>
</li>
</ul>
<h3 id="一、测试驱动开发的基本过程"><a href="#一、测试驱动开发的基本过程" class="headerlink" title="一、测试驱动开发的基本过程"></a>一、测试驱动开发的基本过程</h3><pre><code>1） 明确当前要完成的功能。可以记录成一个 TODO 列表。
2） 快速完成针对此功能的测试用例编写。
3） 测试代码编译不通过。
4） 编写对应的功能代码。
5） 测试通过。
6） 对代码进行重构，并保证测试通过。
7） 循环完成所有功能的开发。
</code></pre><h3 id="二、测试驱动开发的原则"><a href="#二、测试驱动开发的原则" class="headerlink" title="二、测试驱动开发的原则"></a>二、测试驱动开发的原则</h3><pre><code>1）测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。

2）一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。

3）测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。

4）测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。

5）先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。

6）可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。

7）及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。
</code></pre><h3 id="三、测试驱动开发的测试范围"><a href="#三、测试驱动开发的测试范围" class="headerlink" title="三、测试驱动开发的测试范围"></a>三、测试驱动开发的测试范围</h3><pre><code>按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试，测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。
</code></pre><h3 id="四、TDD的优点"><a href="#四、TDD的优点" class="headerlink" title="四、TDD的优点"></a>四、TDD的优点</h3><pre><code>『充满吸引力的优点』

完工时完工。表明我可以很清楚的看到自己的这段工作已经结束了，而传统的方式很难知道什么时候编码工作结束了。 
全面正确的认识代码和利用代码，而传统的方式没有这个机会。 
为利用你成果的人提供Sample，无论它是要利用你的源代码，还是直接重用你提供的组件。 
开发小组间降低了交流成本，提高了相互信赖程度。 
避免了过渡设计。 
系统可以与详尽的测试集一起发布，从而对程序的将来版本的修改和扩展提供方便。 
TDD给了我们自信，让我们今天的问题今天解决，明天的问题明天解决，今天不能解决明天的问题，因为明天的问题还没有出现(没有TestCase)，除非有TestCase否则我决不写任何代码；明天也不必担心今天的问题，只要我亮了绿灯。

『不显而易见的优点』

逃避了设计角色。对于一个敏捷的开发小组，每个人都在做设计。 
大部分时间代码处在高质量状态，100％的时间里成果是可见的。 
由于可以保证编写测试和编写代码的是相同的程序员，降低了理解代码所花费的成本。 
为减少文档和代码之间存在的细微的差别和由这种差别所引入的Bug作出杰出贡献。 
在预先设计和紧急设计之间建立一种平衡点，为你区分哪些设计该事先做、哪些设计该迭代时做提供了一个可靠的判断依据。

『有争议的优点』

 事实上提高了开发效率。每一个正在使用TDD并相信TDD的人都会相信这一点，但观望者则不同，不相信TDD的人甚至坚决反对这一点，这很正常，世界总是这样。 
发现比传统测试方式更多的Bug。 
使IDE的调试功能失去意义，或者应该说，避免了令人头痛的调试和节约了调试的时间。 
总是处在要么编程要么重构的状态下，不会使人抓狂。（两顶帽子） 
单元测试非常有趣。
</code></pre><h3 id="五、TDD的-优势"><a href="#五、TDD的-优势" class="headerlink" title="五、TDD的 优势"></a>五、TDD的 优势</h3><pre><code>TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。

需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。

通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。

开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。

快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。

当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。

我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。

那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。
</code></pre><h3 id="六、TDD的原理"><a href="#六、TDD的原理" class="headerlink" title="六、TDD的原理"></a>六、TDD的原理</h3><pre><code>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。

我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。
</code></pre><p><img src="http://image.360doc.com/DownloadImg/15822/503491_2.jpg" alt="图 V测试模型"></p>
<pre><code>在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。

关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。
</code></pre><p><img src="http://image.360doc.com/DownloadImg/15822/503491_3.jpg" alt=""><br>【图 X测试模型】</p>
<pre><code>基本原理应该说非常简单，那么如何进行实际操作哪，下面对开发过程进行详细的介绍。
</code></pre><h3 id="七、测试技术"><a href="#七、测试技术" class="headerlink" title="七、测试技术　"></a>七、测试技术　</h3><pre><code>1. 测试范围、粒度

对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。

测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。

测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。

小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。

2. 怎么编写测试用例

测试用例的编写就用上了传统的测试技术。

操作过程尽量模拟正常使用的过程。 
全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。 
测试数据尽量包括：真实数据、边界数据。 
测试语句和测试数据应该尽量简单，容易理解。 
为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。 
如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。
</code></pre><h3 id="八、Tips"><a href="#八、Tips" class="headerlink" title="八、Tips"></a>八、Tips</h3><pre><code>很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。

软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。
</code></pre><h3 id="九、FAQ"><a href="#九、FAQ" class="headerlink" title="九、FAQ"></a>九、FAQ</h3><p>[什么时候重构？]<br>如果您在软件公司工作，就意味着您成天都会和想通过重构改善代码质量的想法打交道，不仅您如此，您的大部分同事也都如此。可是，究竟什么时候该重构，什么情况下应该重构呢？我相信您和您的同事可能有很多不同的看法，最常见的答案是“该重构时重构”，“写不下去的时候重构”，和“下一次迭代开始之前重构”，或者干脆就是“最近没时间，就不重构了，下次有时间的时候重构吧”。正如您已经预见到我想说的——这些想法都是对重构的误解。重构不是一种构建软件的工具，不是一种设计软件的模式，也不是一个软件开发过程中的环节，正确理解重构的人应该把重构看成一种书写代码的方式，或习惯，重构时时刻刻有可能发生。在TDD中，除去编写测试用例和实现测试用例之外的所有工作都是重构，所以，没有重构任何设计都不能实现。至于什么时候重构嘛，还要分开看，有三句话是我的经验：实现测试用例时重构代码，完成某个特性时重构设计，产品的重构完成后还要记得重构一下测试用例哦。</p>
<p>[什么时候设计？]<br>这个问题比前面一个要难回答的多，实话实说，本人在依照TDD开发软件的时候也常常被这个问题困扰，总是觉得有些问题应该在写测试用例之前定下来，而有些问题应该在新增一个一个测试用例的过程中自然出现，水到渠成。所以，我的建议是，设计的时机应该由开发者自己把握，不要受到TDD方式的限制，但是，不需要事先确定的事一定不能事先确定，免得捆住了自己的手脚。</p>
<p>[什么时候增加新的TestCase？]<br>没事做的时候。通常我们认为，如果你要增加一个新的功能，那么先写一个不能通过的TestCase；如果你发现了一个bug，那么先写一个不能通过的TestCase；如果你现在什么都没有，从0开始，请先写一个不能通过的TestCase。所有的工作都是从一个TestCase开始。此外，还要注意的是，一些大师要求我们每次只允许有一个TestCase亮红灯，在这个TestCase没有Green之前不可以写别的TestCase，这种要求可以适当考虑，但即使有多个TestCase亮红灯也不要紧，并未违反TDD的主要精神。</p>
<p>[TestCase该怎么写？]<br>测试用例的编写实际上就是两个过程：使用尚不存在的代码和定义这些代码的执行结果。所以一个TestCase也就应该包括两个部分——场景和断言。第一次写TestCase的人会有很大的不适应的感觉，因为你之前所写的所有东西都是在解决问题，现在要你提出问题确实不大习惯，不过不用担心，你正在做正确的事情，而这个世界上最难的事情也不在于如何解决问题，而在于ask the right question！</p>
<p>[TDD能帮助我消除Bug吗？]<br>答：不能！千万不要把“测试”和“除虫”混为一谈！“除虫”是指程序员通过自己的努力来减少bug的数量（消除bug这样的字眼我们还是不要讲为好^_^），而“测试”是指程序员书写产品以外的一段代码来确保产品能有效工作。虽然TDD所编写的测试用例在一定程度上为寻找bug提供了依据，但事实上，按照TDD的方式进行的软件开发是不可能通过TDD再找到bug的（想想我们前面说的“完工时完工”），你想啊，当我们的代码完成的时候，所有的测试用例都亮了绿灯，这时隐藏在代码中的bug一个都不会露出马脚来。</p>
<p>但是，如果要问“测试”和“除虫”之间有什么联系，我相信还是有很多话可以讲的，比如TDD事实上减少了bug的数量，把查找bug战役的关注点从全线战场提升到代码战场以上。还有，bug的最可怕之处不在于隐藏之深，而在于满天遍野。如果你发现了一个用户很不容易才能发现的bug，那么不一定对工作做出了什么杰出贡献，但是如果你发现一段代码中，bug的密度或离散程度过高，那么恭喜你，你应该抛弃并重写这段代码了。TDD避免了这种情况，所以将寻找bug的工作降低到了一个新的低度。</p>
<p>[我该为一个Feature编写TestCase还是为一个类编写TestCase？]<br>初学者常问的问题。虽然我们从TDD的说明书上看到应该为一个特性编写相应的TestCase，但为什么著名的TDD大师所写的TestCase都是和类/方法一一对应的呢？为了解释这个问题，我和我的同事们都做了很多试验，最后我们得到了一个结论，虽然我不知道是否正确，但是如果您没有答案，可以姑且相信我们。</p>
<p>我们的研究结果表明，通常在一个特性的开发开始时，我们针对特性编写测试用例，如果您发现这个特性无法用TestCase表达，那么请将这个特性细分，直至您可以为手上的特性写出TestCase为止。从这里开始是最安全的，它不会导致任何设计上重大的失误。但是，随着您不断的重构代码，不断的重构TestCase，不断的依据TDD的思想做下去，最后当产品伴随测试用例集一起发布的时候，您就会不经意的发现经过重构以后的测试用例很可能是和产品中的类/方法一一对应的。</p>
<p>[什么时候应该将全部测试都运行一遍？]<br>Good Question！大师们要求我们每次重构之后都要完整的运行一遍测试用例。这个要求可以理解，因为重构很可能会改变整个代码的结构或设计，从而导致不可预见的后果，但是如果我正在开发的是一个ERP怎么办？运行一遍完整的测试用例可能将花费数个小时，况且现在很多重构都是由工具做到的，这个要求的可行性和前提条件都有所动摇。所以我认为原则上你可以挑几个你觉得可能受到本次重构影响的TestCase去run，但是如果运行整个测试包只要花费数秒的时间，那么不介意你按大师的要求去做。</p>
<p>[什么时候改进一个TestCase？]<br>增加的测试用例或重构以后的代码导致了原来的TestCase的失去了效果，变得无意义，甚至可能导致错误的结果，这时是改进TestCase的最好时机。但是有时你会发现，这样做仅仅导致了原来的TestCase在设计上是臃肿的，或者是冗余的，这都不要紧，只要它没有失效，你仍然不用去改进它。记住，TestCase不是你的产品，它不要好看，也不要怎么太科学，甚至没有性能要求，它只要能完成它的使命就可以了——这也证明了我们后面所说的“用Ctrl-C/Ctrl-V编写测试用例”的可行性。</p>
<p>但是，美国人的想法其实跟我们还是不太一样，拿托尼巴赞的MindMap来说吧，其实画MindMap只是为了表现自己的思路，或记忆某些重要的事情，但托尼却建议大家把MindMap画成一件艺术品，甚至还有很多艺术家把自己画的抽象派MindMap拿出来帮助托尼做宣传。同样，大师们也要求我们把TestCase写的跟代码一样质量精良，可我想说的是，现在国内有几个公司能把产品的代码写的精良？？还是一步一步慢慢来吧。</p>
<p>[为什么原来通过的测试用例现在不能通过了？]<br>这是一个警报，Red Alert！它可能表达了两层意思——都不是什么好意思——1）你刚刚进行的重构可能失败了，或存在一些错误未被发现，至少重构的结果和原来的代码不等价了。2）你刚刚增加的TestCase所表达的意思跟前面已经有的TestCase相冲突，也就是说，新增的功能违背了已有的设计，这种情况大部分可能是之前的设计错了。但无论哪错了，无论是那层意思，想找到这个问题的根源都比TDD的正常工作要难。</p>
<p>[我怎么知道那里该有一个方法还是该有一个类？]<br>这个问题也是常常出现在我的脑海中，无论你是第一次接触TDD或者已经成为TDD专家，这个问题都会缠绕着你不放。不过问题的答案可以参考前面的“什么时候设计”一节，答案不是唯一的。其实多数时候你不必考虑未来，今天只做今天的事，只要有重构工具，从方法到类和从类到方法都很容易。</p>
<p>[我要写一个TestCase，可是不知道从哪里开始？]<br>从最重要的事开始，what matters most？从脚下开始，从手头上的工作开始，从眼前的事开始。从一个没有UI的核心特性开始，从算法开始，或者从最有可能耽误时间的模块开始，从一个最严重的bug开始。这是TDD主义者和鼠目寸光者的一个共同点，不同点是前者早已成竹在胸。</p>
<p>[为什么我的测试总是看起来有点愚蠢？]<br>哦？是吗？来，握个手，我的也是！不必担心这一点，事实上，大师们给的例子也相当愚蠢，比如一个极端的例子是要写一个两个int变量相加的方法，大师先断言2+3=5，再断言5+5=10，难道这些代码不是很愚蠢吗？其实这只是一个极端的例子，当你初次接触TDD时，写这样的代码没什么不好，以后当你熟练时就会发现这样写没必要了，要记住，谦虚是通往TDD的必经之路！从经典开发方法转向TDD就像从面向过程转向面向对象一样困难，你可能什么都懂，但你写出来的类没有一个纯OO的！我的同事还告诉我真正的太极拳，其速度是很快的，不比任何一个快拳要慢，但是初学者（通常是指学习太极拳的前10年）太不容易把每个姿势都做对，所以只能慢慢来。</p>
<p>[什么场合不适用TDD？]<br>问的好，确实有很多场合不适合使用TDD。比如对软件质量要求极高的军事或科研产品——神州六号，人命关天的软件——医疗设备，等等，再比如设计很重要必须提前做好的软件，这些都不适合TDD，但是不适合TDD不代表不能写TestCase，只是作用不同，地位不同罢了</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/04/js模板引擎介绍搜集/" >
  js模板引擎介绍搜集
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/04/js模板引擎介绍搜集/"><span class="article-date">
  2016-06-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js模板引擎/">js模板引擎</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://blog.csdn.net/lybwwp/article/details/18813737" target="_blank" rel="external">js模板引擎介绍搜集*转载</a></p>
<p>s模板引擎越来越多的得到应用，如今已经出现了几十种js模板引擎，国内各大互联网公司也都开发了自己的js模板引擎（淘宝的kissy template，腾讯的artTemplate，百度的baiduTemplate等），如何从这么多纷繁的模板引擎中选择一款适合自己的呢</p>
<p>从这几个指标来比较js模板引擎：<br>1 文件大小 - 影响网络传输时间<br>2 执行速度（性能） - 影响响应速度，涉及模板解析和渲染<br>3 语法简明/易用/灵活/自定义操作符 - 影响开发效率和维护难度<br>4 错误处理/调试 - 影响开发效率和维护难度<br>5 安全（XSS） - 是否防止XSS</p>
<p>1 文件大小（压缩后）<br>Mustache：5k<br>doT：4k<br>juicer：7.65k<br>artTemplate(腾讯)：5k<br>baiduTemplate(百度)：3k<br>Underscore(Arale)：11.7k - 不只是模板，还包含很多js语言增强功能<br>Handlebars(Arale)：30.5k</p>
<p>2 执行速度（不要迷恋速度）<br>对于执行速度，不得不提模板“编译速度”和“渲染速度”。这几个主流模板都支持将模板预编译，然后再渲染。<br>这里有一篇文章《高性能JavaScript模板引擎原理解析》，说artTemplate的速度达到理论极限，实际说的是渲染速度，它的综合速度并不快。<br>一般情况下，每页面只有一两个模板，执行时间差别不大。</p>
<blockquote>
<blockquote>
<p>这里&lt;&lt;有个测试页面，根据artTemplate的测试页面《引擎渲染速度竞赛》改的，揭示了几个主流js模板引擎的性能情况，大致结果截图如下：</p>
</blockquote>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130515201225085" alt=""></p>
<p>可以看出artTemplate,juicer,doT比其他模板引擎快很多。</p>
<p>3 语法 简明/易用/灵活/自定义操作符 - 影响开发效率和维护难度</p>
<p>语法需要一段时间的使用经验才能更深切地体会到优缺点，并且每个人喜欢的语法风格也不同，这部分可能略带个人主观色彩。<br>这几个js模板引擎的语法可以粗略分为两种，一种是类似javascript的语法（doT, artTemplate, underscore），另一种是与javascript差异较大的语法（Mustache, juicer, handlebars）。从易上手的角度来看，类javascript语法更容易被新手掌握，但是熟练掌握之后，各个模板的语法都能满足我们的需求，可以按个人喜好来选择。</p>
<p>Mustache声称是无逻辑（logic-less）模板，没有for、if…else…语法，但实际可以实现循环和分支，还可以实现更复杂的逻辑。<br>doT模板语法灵活，阅读起来很易懂。可以方便地改造成jquery插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[javascript] view plaincopy </span><br><span class="line">&lt;!--Mustache 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;Mustache&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;&#123;#list&#125;&#125;  </span><br><span class="line">        &lt;li&gt;&#123;&#123;&#123;index&#125;&#125;&#125;. 用户: &#123;&#123;&#123;user&#125;&#125;&#125;/ 网站：&#123;&#123;&#123;site&#125;&#125;&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;&#123;/list&#125;&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- doT 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;doT&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;&#123; for (var val, i = 0, l = it.list.length; i &lt; l; i ++) &#123; &#125;&#125;  </span><br><span class="line">        &#123;&#123; val = it.list; &#125;&#125;  </span><br><span class="line">        &lt;li&gt;&#123;&#123;=val[i].index&#125;&#125;. 用户: &#123;&#123;=val[i].user&#125;&#125;/ 网站：&#123;&#123;=val[i].site&#125;&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;&#123; &#125; &#125;&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!--juicer 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;juicer&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;@each list as val&#125;  </span><br><span class="line">        &lt;li&gt;</span><br><span class="line">val.index.用户:</span><br><span class="line">&#123;val.user&#125;/ 网站：$$&#123;val.site&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;@/each&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- artTemplate 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;template&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &lt;% for (i = 0, l = list.length; i &lt; l; i ++) &#123; %&gt;  </span><br><span class="line">        &lt;li&gt;&lt;%=list[i].index%&gt;. 用户: &lt;%=list[i].user%&gt;/ 网站：&lt;%=list[i].site%&gt;&lt;/li&gt;  </span><br><span class="line">    &lt;% &#125; %&gt;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- underscore 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;underscoreTemplate&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &lt;% for (var i = 0, l = list.length; i &lt; l; i ++) &#123; %&gt;  </span><br><span class="line">        &lt;li&gt;&lt;%=list[i].index%&gt;. 用户: &lt;%=list[i].user%&gt;/ 网站：&lt;%=list[i].site%&gt;&lt;/li&gt;  </span><br><span class="line">    &lt;% &#125; %&gt;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- Handlebars 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;Handlebars&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;&#123;#list&#125;&#125;  </span><br><span class="line">        &lt;li&gt;&#123;&#123;&#123;index&#125;&#125;&#125;. 用户: &#123;&#123;&#123;user&#125;&#125;&#125;/ 网站：&#123;&#123;&#123;site&#125;&#125;&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;&#123;/list&#125;&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>4 错误处理/调试 - 影响开发效率和维护难度<br>artTemplate 有详细的错误提示信息，查错方便，不影响后面代码的继续执行<br>kissy template 错误信息直接输出在页面，而不是在控制台。不影响后面代码的继续执行<br>juicer 控制台提示模板渲染出错，不影响后面代码的继续执行<br>mustache 没有任何错误信息，不影响后面代码的继续执行<br>其他控制台报脚本错误 js执行中断，不知道是哪里出错</p>
<p>5 安全- 是否防止XSS<br>以上几个模板引擎全都支持html转义，防止XSS</p>
<p>最终的一个对比：</p>
<p><img src="http://img.blog.csdn.net/20130515202850554" alt=""></p>
<hr>
<p>介绍 X 款 JavaScript 的模板引擎。（排名不分先后顺序）</p>
<ol>
<li><p>Mustache<br>基于javascript 实现的模板引擎,类似于 Microsoft’s jQuery template plugin,但更简单易用!</p>
</li>
<li><p>EasyTemplate<br>在使用过Freemarker模板后，感觉它的 语法比较朴实，平易近人，容易上手，于是决定按它的语法风格实现一个前端的 模板引擎，这就有了下面的EasyTemplate! EasyTemplate模板的函数大小为1.34k（未压缩），暂时只实现了 list，list index，if elseif else等功能，应该可以满足大部分的使用需求了。 EasyTemplate模板 引擎的解析速度测试，渲染1000行数据，在不同的浏览器中，平均速度大约在30豪秒以内（测试机器性能较弱）。</p>
</li>
<li><p>jSmart<br>jSmart 是著名的 PHP 模板引擎 Smarty 的 JavaScript 移植版本。</p>
</li>
<li><p>Trimpath<br>Trimpath JavaScript 是个轻量级的，基于JavaScript的，跨浏览器，采用APL/GPL开放源代码协议的，可以让你轻松进行基于模板编程方式的纯JS引擎。新浪的评论系统使用的就是此模板。</p>
</li>
<li><p>jade<br>Jade是受Haml的影响以JavaScript实现用于node的高性能模板引擎。</p>
</li>
<li><p>Hogan.js<br>来自 Twitter 的 JavaScript 模板引擎。</p>
</li>
<li><p>Handlebars<br>Handlebars 是一个 JavaScript 的页面模板库<br><img src="http://www.php100.com/uploadfile/2012/0416/20120416095203993.jpg" alt=""></p>
</li>
<li><p>doT.js<br>doT.js 包含为浏览器和Node.js 准备的 JavaScript 模板引擎。</p>
</li>
<li><p>dom.js<br>dom.js 是一款可用在客户端和服务器端的 JavaScript 模板引擎</p>
</li>
<li><p>Plates.js<br>Plates.js 是一个轻量级、无逻辑、DSL 的 JavaScript 模板引擎。<br><img src="http://www.php100.com/uploadfile/2012/0416/20120416095203157.png" alt=""></p>
</li>
<li><p>ICanHaz.js<br>ICanHaz.js 是一个简单而且功能强大的客户端的 JavaScript 模板引擎。</p>
</li>
<li><p>dotpl-js<br>Dotpl-JS 是一个纯javascript模板引擎,支持IF和FOR关键字，多循环衔套及字段渲染，跨浏览器支持。是一个实用的javascipt工具,页面静态化利器!</p>
</li>
<li><p>EJS<br>EJS 可以将数据和模板合并然后生成 HTML 文本。</p>
</li>
</ol>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/04/jQuery offset()方法介绍/" >
  jQuery.offset()方法介绍
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/04/jQuery offset()方法介绍/"><span class="article-date">
  2016-06-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/offset/">offset()</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>jQuery.offset()方法介绍</p>
<p>jQuery.offset()方法获取或设置元素的坐标，坐标相对于文档。</p>
<p>.offset()获取一个元素相对于文档（document）的当前位置，相对于文档（document）的当前位置。</p>
<ul>
<li>当通过全局操作（特别是通过拖拽操作）将一个新的元素放置到另一个已经存在的元素的上面时，若要取得这个新的元素的位置，那么使用 .offset() 更合适。</li>
<li>当把一个新元素放在同一个容器里面另一个元素附近时，用.position()更合适。（和offset()使用一样，有一个left和top属性，<strong>.position().left/.position().top或者设置.position({left: 30,top: 30})</strong>）</li>
</ul>
<blockquote>
<p>注意：jQuery不支持获取隐藏元素的偏移坐标。同样的，也无法取得隐藏元素的 border, margin, 或 padding 信息。<br>若元素的属性设置的是 visibility:hidden，那么我们依然可以取得它的坐标。但是若设置的属性是 display:none，由于在绘制 DOM 树时根本就不绘制该元素，所以它的位置属性值是 undefined。</p>
</blockquote>
<ul>
<li>.offset( coordinates )</li>
</ul>
<blockquote>
<p>coordinates<br>类型: PlainObject<br>一个包含top 和 left属性的对象，用整数指明元素的新顶部和左边坐标。</p>
</blockquote>
<p>.offset({left: xx,top: xx})使用键值对方式赋值</p>
<ul>
<li>.offset( function(index, coords) )<blockquote>
<p>function(index, coords)<br>类型: Function()<br>返回用于设置坐标的一个函数。接收元素在匹配的元素集合中的索引位置作为第一个参数，和当前坐标作为第二个参数。这个函数应该返回一个包含top 和 left属性的对象。</p>
</blockquote>
</li>
</ul>
<p>.offset()方法允许我们重新设置元素的位置，这个元素的位置是相对于document对象的。如果对象原先的.position()样式属性是static的话，会被改成relative来实现重定位。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/04/jQuery的deferred对象详解/" >
  jQuery的deferred对象详解*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/04/jQuery的deferred对象详解/"><span class="article-date">
  2016-06-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deferred/">deferred</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="external">jQuery的deferred对象详解*转</a></p>
<ul>
<li>阮一峰的网络日志</li>
</ul>
<h2 id="一、什么是deferred对象？"><a href="#一、什么是deferred对象？" class="headerlink" title="一、什么是deferred对象？"></a>一、什么是deferred对象？</h2><p>开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。</p>
<p>通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。</p>
<p>但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象<a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="external">http://api.jquery.com/category/deferred-object/</a>。</p>
<p>简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。</p>
<p>它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点。下面我们通过示例代码，一步步来学习。</p>
<h2 id="二、ajax操作的链式写法"><a href="#二、ajax操作的链式写法" class="headerlink" title="二、ajax操作的链式写法"></a>二、ajax操作的链式写法</h2><p>首先，回顾一下jQuery的ajax操作的传统写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　$.ajax(&#123;</span><br><span class="line">　　　　url: &quot;test.html&quot;,</span><br><span class="line">　　　　success: function()&#123;</span><br><span class="line">　　　　　　alert(&quot;哈哈，成功了！&quot;);</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　error:function()&#123;</span><br><span class="line">　　　　　　alert(&quot;出错啦！&quot;);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。</p>
<p>$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。</p>
<p>现在，新的写法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　$.ajax(&quot;test.html&quot;)</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，done()相当于success方法，fail()相当于error方法。采用链式写法以后，代码的可读性大大提高。</p>
<h2 id="三、指定同一操作的多个回调函数"><a href="#三、指定同一操作的多个回调函数" class="headerlink" title="三、指定同一操作的多个回调函数"></a>三、指定同一操作的多个回调函数</h2><p>deferred对象的一大好处，就是它允许你自由添加多个回调函数。</p>
<p>还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？</p>
<p>很简单，直接把它加在后面就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　$.ajax(&quot;test.html&quot;)</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;);&#125; )</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125; )</span><br><span class="line">　　.done(function()&#123; alert(&quot;第二个回调函数！&quot;);&#125; );</span><br></pre></td></tr></table></figure></p>
<p>回调函数可以添加任意多个，它们按照添加顺序执行</p>
<h2 id="四、为多个操作指定回调函数"><a href="#四、为多个操作指定回调函数" class="headerlink" title="四、为多个操作指定回调函数"></a>四、为多个操作指定回调函数</h2><p>deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。</p>
<p>请看下面的代码，它用到了一个新的方法<a href="http://api.jquery.com/jQuery.when/" target="_blank" rel="external">$.when()</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　$.when($.ajax(&quot;test1.html&quot;), $.ajax(&quot;test2.html&quot;))</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这段代码的意思是，先执行两个操作$.ajax(“test1.html”)和$.ajax(“test2.html”)，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p>
<h2 id="五、普通操作的回调函数接口（上）"><a href="#五、普通操作的回调函数接口（上）" class="headerlink" title="五、普通操作的回调函数接口（上）"></a>五、普通操作的回调函数接口（上）</h2><p>deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。</p>
<p>我们来看一个具体的例子。假定有一个很耗时的操作wait：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var wait = function()&#123;</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure>
<p>我们为它指定回调函数，应该怎么做呢？</p>
<p>很自然的，你会想到，可以使用$.when()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　$.when(wait())</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure>
<p>但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是deferred对象，所以必须对wait()进行改写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　var dtd = $.Deferred(); // 新建一个deferred对象</span><br><span class="line">　　var wait = function(dtd)&#123;</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　　　dtd.resolve(); // 改变deferred对象的执行状态</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　　　return dtd;</span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　$.when(wait(dtd))</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure>
<p>wait()函数运行完，就会自动运行done()方法指定的回调函数。</p>
<h2 id="六、deferred-resolve-方法和deferred-reject-方法"><a href="#六、deferred-resolve-方法和deferred-reject-方法" class="headerlink" title="六、deferred.resolve()方法和deferred.reject()方法"></a>六、deferred.resolve()方法和deferred.reject()方法</h2><p>如果仔细看，你会发现在上面的wait()函数中，还有一个地方我没讲解。那就是dtd.resolve()的作用是什么？</p>
<p>要说清楚这个问题，就要引入一个新概念”执行状态”。jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数（jQuery1.7版本添加）。</p>
<p>前面部分的ajax操作时，deferred对象会根据返回结果，自动改变自身的执行状态；但是，在wait()函数中，这个执行状态必须由程序员手动指定。dtd.resolve()的意思是，将dtd对象的执行状态从”未完成”改为”已完成”，从而触发done()方法。</p>
<p>类似的，还存在一个deferred.reject()方法，作用是将dtd对象的执行状态从”未完成”改为”已失败”，从而触发fail()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　var dtd = $.Deferred(); // 新建一个Deferred对象</span><br><span class="line">　　var wait = function(dtd)&#123;</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　　　dtd.reject(); // 改变Deferred对象的执行状态</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　　　return dtd;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　$.when(wait(dtd))</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="七、deferred-promise-方法"><a href="#七、deferred-promise-方法" class="headerlink" title="七、deferred.promise()方法"></a>七、deferred.promise()方法</h2><p>上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。</p>
<p>请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　var dtd = $.Deferred(); // 新建一个Deferred对象</span><br><span class="line">　　var wait = function(dtd)&#123;</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　　　dtd.resolve(); // 改变Deferred对象的执行状态</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　　　return dtd;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　$.when(wait(dtd))</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br><span class="line">　　dtd.resolve();</span><br></pre></td></tr></table></figure>
<p>我在代码的尾部加了一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立刻执行，跳出”哈哈，成功了！”的提示框，等5秒之后再跳出”执行完毕！”的提示框。</p>
<p>为了避免这种情况，jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变。</p>
<p>请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　var dtd = $.Deferred(); // 新建一个Deferred对象</span><br><span class="line">　　var wait = function(dtd)&#123;</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　　　dtd.resolve(); // 改变Deferred对象的执行状态</span><br><span class="line">　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　　　return dtd.promise(); // 返回promise对象</span><br><span class="line">　　&#125;;</span><br><span class="line">　　var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作</span><br><span class="line">　　$.when(d)</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br><span class="line">　　d.resolve(); // 此时，这个语句是无效的</span><br></pre></td></tr></table></figure>
<p>在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定在这个对象上面，而不是原来的deferred对象上面。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的deferred对象。</p>
<p>不过，更好的写法是<a href="http://blog.allenm.me/2012/01/jquery_deferred_promise_method/" target="_blank" rel="external">allenm</a>所指出的，将dtd对象变成wait(）函数的内部对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　var wait = function(dtd)&#123;</span><br><span class="line">　　　　var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　　　dtd.resolve(); // 改变Deferred对象的执行状态</span><br><span class="line">　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　　　return dtd.promise(); // 返回promise对象</span><br><span class="line">　　&#125;;</span><br><span class="line">　　$.when(wait())</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="八、普通操作的回调函数接口（中）"><a href="#八、普通操作的回调函数接口（中）" class="headerlink" title="八、普通操作的回调函数接口（中）"></a>八、普通操作的回调函数接口（中）</h2><p>另一种防止执行状态被外部改变的方法，是使用deferred对象的建构函数$.Deferred()。</p>
<p>这时，wait函数还是保持不变，我们直接把它传入$.Deferred()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　$.Deferred(wait)</span><br><span class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br></pre></td></tr></table></figure>
<p>jQuery规定，$.Deferred()可以接受一个函数名（注意，是函数名）作为参数，$.Deferred()所生成的deferred对象将作为这个函数的默认参数。</p>
<h2 id="九、普通操作的回调函数接口（下）"><a href="#九、普通操作的回调函数接口（下）" class="headerlink" title="九、普通操作的回调函数接口（下）"></a>九、普通操作的回调函数接口（下）</h2><p>除了上面两种方法以外，我们还可以直接在wait对象上部署deferred接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　var dtd = $.Deferred(); // 生成Deferred对象</span><br><span class="line">　　var wait = function(dtd)&#123;</span><br><span class="line">　　　　var tasks = function()&#123;</span><br><span class="line">　　　　　　alert(&quot;执行完毕！&quot;);</span><br><span class="line">　　　　　　dtd.resolve(); // 改变Deferred对象的执行状态</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　setTimeout(tasks,5000);</span><br><span class="line">　　&#125;;</span><br><span class="line">　　dtd.promise(wait);</span><br><span class="line">　　wait.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</span><br><span class="line">　　wait(dtd);</span><br></pre></td></tr></table></figure></p>
<p>这里的关键是dtd.promise(wait)这一行，它的作用就是在wait对象上部署Deferred接口。正是因为有了这一行，后面才能直接在wait上面调用done()和fail()。</p>
<h2 id="十、小结：deferred对象的方法"><a href="#十、小结：deferred对象的方法" class="headerlink" title="十、小结：deferred对象的方法"></a>十、小结：deferred对象的方法</h2><p>前面已经讲到了deferred对象的多种方法，下面做一个总结：</p>
<p>　　（1） $.Deferred() 生成一个deferred对象。</p>
<p>　　（2） deferred.done() 指定操作成功时的回调函数</p>
<p>　　（3） deferred.fail() 指定操作失败时的回调函数</p>
<p>　　（4） deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。</p>
<p>　　（5） deferred.resolve() 手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。</p>
<p>　　（6）deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。</p>
<p>　　（7） $.when() 为多个操作指定回调函数。<br>除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。</p>
<p>　　（8）deferred.then()<br>有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。<br>　　$.when($.ajax( “/main.php” ))<br>　　.then(successFunc, failureFunc );<br>如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。</p>
<p>　　（9）deferred.always()<br>这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。<br>　　$.ajax( “test.html” )<br>　　.always( function() { alert(“已执行！”);} );</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/03/测试框架 Mocha 实例教程/" >
  测试框架 Mocha 实例教程*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/03/测试框架 Mocha 实例教程/"><span class="article-date">
  2016-06-03
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/npm/">npm</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mocha/">Mocha</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">测试框架 Mocha 实例教程*转</a></p>
<ul>
<li>转自阮一峰的王若日志</li>
</ul>
<p><a href="https://mochajs.org/" target="_blank" rel="external">Mocha</a>（发音”摩卡”）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。<br>所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。</p>
<p>本文全面介绍如何使用Mocha，让你轻松上手。如果你以前对测试一无所知，本文也可以当作JavaScript单元测试入门。值得说明的是，除了Mocha以外，类似的测试框架还有<a href="http://jasmine.github.io/" target="_blank" rel="external">Jasmine</a>、<a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="external">Karma</a>、<a href="https://github.com/substack/tape/" target="_blank" rel="external">Tape</a>等，也很值得学习。</p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>我为本文写了一个示例库Mocha-demos（<a href="https://github.com/ruanyf/mocha-demos），请先安装这个库。" target="_blank" rel="external">https://github.com/ruanyf/mocha-demos），请先安装这个库。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/ruanyf/mocha-demos.git</span><br></pre></td></tr></table></figure></p>
<p>然后，进入mocha-demos目录，安装依赖（你的电脑必须有Node）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd mocha-demos</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>上面代码会在目录内部安装Mocha，为了操作的方便，请在全面环境也安装一下Mocha。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --global mocha</span><br></pre></td></tr></table></figure></p>
<h2 id="二、测试脚本的写法"><a href="#二、测试脚本的写法" class="headerlink" title="二、测试脚本的写法"></a>二、测试脚本的写法</h2><p>Mocha的作用是运行测试脚本，首先必须学会写测试脚本。所谓”测试脚本”，就是用来测试源码的脚本。</p>
<p>下面是一个加法模块add.js的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// add.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = add;</span><br></pre></td></tr></table></figure></p>
<p>要测试这个加法模块是否正确，就要写测试脚本。</p>
<p>通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。比如，add.js的测试脚本名字就是add.test.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// add.test.js</span><br><span class="line">var add = require(&apos;./add.js&apos;);</span><br><span class="line">var expect = require(&apos;chai&apos;).expect;</span><br><span class="line"></span><br><span class="line">describe(&apos;加法函数的测试&apos;, function() &#123;</span><br><span class="line">  it(&apos;1 加 1 应该等于 2&apos;, function() &#123;</span><br><span class="line">    expect(add(1, 1)).to.be.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。</p>
<p>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。</p>
<p>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。</p>
<h2 id="三、断言库的用法"><a href="#三、断言库的用法" class="headerlink" title="三、断言库的用法"></a>三、断言库的用法</h2><p>上面的测试脚本里面，有一句断言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(add(1, 1)).to.be.equal(2)</span><br></pre></td></tr></table></figure></p>
<p>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。上面这句断言的意思是，调用add(1, 1)，结果应该等于2。</p>
<p>所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expect = require(&apos;chai&apos;).expect;</span><br></pre></td></tr></table></figure></p>
<p>断言库有很多种，Mocha并不限制使用哪一种。上面代码引入的断言库是chai(<a href="http://chaijs.com/)，并且指定使用它的expect(http://chaijs.com/api/bdd/)断言风格。" target="_blank" rel="external">http://chaijs.com/)，并且指定使用它的expect(http://chaijs.com/api/bdd/)断言风格。</a></p>
<p>expect断言的优点是很接近自然语言，下面是一些例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 相等或不相等</span><br><span class="line">expect(4 + 5).to.be.equal(9);</span><br><span class="line">expect(4 + 5).to.be.not.equal(10);</span><br><span class="line">expect(foo).to.be.deep.equal(&#123; bar: &apos;baz&apos; &#125;);</span><br><span class="line"></span><br><span class="line">// 布尔值为true</span><br><span class="line">expect(&apos;everthing&apos;).to.be.ok;</span><br><span class="line">expect(false).to.not.be.ok;</span><br><span class="line"></span><br><span class="line">// typeof</span><br><span class="line">expect(&apos;test&apos;).to.be.a(&apos;string&apos;);</span><br><span class="line">expect(&#123; foo: &apos;bar&apos; &#125;).to.be.an(&apos;object&apos;);</span><br><span class="line">expect(foo).to.be.an.instanceof(Foo);</span><br><span class="line"></span><br><span class="line">// include</span><br><span class="line">expect([1,2,3]).to.include(2);</span><br><span class="line">expect(&apos;foobar&apos;).to.contain(&apos;foo&apos;);</span><br><span class="line">expect(&#123; foo: &apos;bar&apos;, hello: &apos;universe&apos; &#125;).to.include.keys(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">// empty</span><br><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(&apos;&apos;).to.be.empty;</span><br><span class="line">expect(&#123;&#125;).to.be.empty;</span><br><span class="line"></span><br><span class="line">// match</span><br><span class="line">expect(&apos;foobar&apos;).to.match(/^foo/);</span><br></pre></td></tr></table></figure></p>
<p>基本上，expect断言的写法都是一样的。头部是expect方法，尾部是断言方法，比如equal、a/an、ok、match等。两者之间使用to或to.be连接。<br>如果expect断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;1 加 1 应该等于 2&apos;, function() &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的这个测试用例，内部没有任何代码，由于没有抛出了错误，所以还是会通过。</p>
<h2 id="四、Mocha的基本用法"><a href="#四、Mocha的基本用法" class="headerlink" title="四、Mocha的基本用法"></a>四、Mocha的基本用法</h2><p>有了测试脚本以后，就可以用Mocha运行它。请进入demo01子目录，执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mocha add.test.js</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line"></span><br><span class="line">  1 passing (8ms)</span><br></pre></td></tr></table></figure></p>
<p>上面的运行结果表示，测试脚本通过了测试，一共只有1个测试用例，耗时是8毫秒。</p>
<p>mocha命令后面紧跟测试脚本的路径和文件名，可以指定多个测试脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha file1 file2 file3</span><br></pre></td></tr></table></figure>
<p>Mocha默认运行test子目录里面的测试脚本。所以，一般都会把测试脚本放在test目录里面，然后执行mocha就不需要参数了。请进入demo02子目录，运行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line">    ✓ 任何数加0应该等于自身</span><br><span class="line"></span><br><span class="line">  2 passing (9ms)</span><br></pre></td></tr></table></figure>
<p>这时可以看到，test子目录里面的测试脚本执行了。但是，你打开test子目录，会发现下面还有一个test/dir子目录，里面还有一个测试脚本multiply.test.js，并没有得到执行。原来，Mocha默认只执行test子目录下面第一层的测试用例，不会执行更下层的用例。</p>
<p>为了改变这种行为，就必须加上–recursive参数，这时test子目录下面所有的测试用例—-不管在哪一层—-都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --recursive</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line">    ✓ 任何数加0应该等于自身</span><br><span class="line"></span><br><span class="line">  乘法函数的测试</span><br><span class="line">    ✓ 1 乘 1 应该等于 1</span><br><span class="line"></span><br><span class="line">  3 passing (9ms)</span><br></pre></td></tr></table></figure></p>
<h2 id="五、通配符"><a href="#五、通配符" class="headerlink" title="五、通配符"></a>五、通配符</h2><p>命令行指定测试脚本时，可以使用通配符，同时指定多个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mocha spec/&#123;my,awesome&#125;.js</span><br><span class="line">$ mocha test/unit/*.js</span><br></pre></td></tr></table></figure>
<p>上面的第一行命令，指定执行spec目录下面的my.js和awesome.js。第二行命令，指定执行test/unit目录下面的所有js文件。<br>除了使用Shell通配符，还可以使用Node通配符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha &apos;test/**/*.@(js|jsx)&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码指定运行test目录下面任何子目录中、文件后缀名为js或jsx的测试脚本。注意，Node的通配符要放在单引号之中，否则星号（*）会先被Shell解释。</p>
<p>上面这行Node通配符，如果改用Shell通配符，要写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha test/&#123;,**/&#125;*.&#123;js,jsx&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、命令行参数"><a href="#六、命令行参数" class="headerlink" title="六、命令行参数"></a>六、命令行参数</h2><p>除了前面介绍的–recursive，Mocha还可以加上其他命令行参数。请在demo02子目录里面，运行下面的命令，查看效果。</p>
<h3 id="6-1-–help-h"><a href="#6-1-–help-h" class="headerlink" title="6.1 –help, -h"></a>6.1 –help, -h</h3><p>–help或-h参数，用来查看Mocha的所有命令行参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --help</span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-–reporter-R"><a href="#6-2-–reporter-R" class="headerlink" title="6.2 –reporter, -R"></a>6.2 –reporter, -R</h3><p>–reporter参数用来指定测试报告的格式，默认是spec格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br><span class="line"># 等同于</span><br><span class="line">$ mocha --reporter spec</span><br></pre></td></tr></table></figure></p>
<p>除了spec格式，官方网站还提供了其他许多<a href="http://mochajs.org/#reporters" target="_blank" rel="external">报告格式</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --reporter tap</span><br><span class="line"></span><br><span class="line">1..2</span><br><span class="line">ok 1 加法函数的测试 1 加 1 应该等于 2</span><br><span class="line">ok 2 加法函数的测试 任何数加0应该等于自身</span><br><span class="line"># tests 2</span><br><span class="line"># pass 2</span><br><span class="line"># fail 0</span><br></pre></td></tr></table></figure></p>
<p>上面是tap格式报告的显示结果。</p>
<p>–reporters参数可以显示所有内置的报告格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --reporters</span><br></pre></td></tr></table></figure></p>
<p>使用mochawesome模块，可以生成漂亮的HTML格式的报告。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120303.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev mochawesome</span><br><span class="line">$ ../node_modules/.bin/mocha --reporter mochawesome</span><br></pre></td></tr></table></figure>
<p>上面代码中，mocha命令使用了项目内安装的版本，而不是全局安装的版本，因为mochawesome模块是安装在项目内的。</p>
<p>然后，测试结果报告就在mochaawesome-reports子目录生成。</p>
<h3 id="6-3-–growl-G"><a href="#6-3-–growl-G" class="headerlink" title="6.3 –growl, -G"></a>6.3 –growl, -G</h3><p>打开–growl参数，就会将测试结果在桌面显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --growl</span><br></pre></td></tr></table></figure></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120304.png" alt=""></p>
<h3 id="6-4-–watch，-w"><a href="#6-4-–watch，-w" class="headerlink" title="6.4 –watch，-w"></a>6.4 –watch，-w</h3><p>–watch参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --watch</span><br></pre></td></tr></table></figure></p>
<p>上面命令执行以后，并不会退出。你可以另外打开一个终端窗口，修改test目录下面的测试脚本add.test.js，比如删除一个测试用例，一旦保存，Mocha就会再次自动运行。</p>
<h3 id="6-5-–bail-b"><a href="#6-5-–bail-b" class="headerlink" title="6.5 –bail, -b"></a>6.5 –bail, -b</h3><p>–bail参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --bail</span><br></pre></td></tr></table></figure></p>
<h3 id="6-6-–grep-g"><a href="#6-6-–grep-g" class="headerlink" title="6.6 –grep, -g"></a>6.6 –grep, -g</h3><p>–grep参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --grep &quot;1 加 1&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码只测试名称中包含”1 加 1”的测试用例。</p>
<h3 id="6-7-–invert-i"><a href="#6-7-–invert-i" class="headerlink" title="6.7 –invert, -i"></a>6.7 –invert, -i</h3><p>–invert参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --grep &quot;1 加 1&quot; --invert</span><br></pre></td></tr></table></figure></p>
<h2 id="七，配置文件mocha-opts"><a href="#七，配置文件mocha-opts" class="headerlink" title="七，配置文件mocha.opts"></a>七，配置文件mocha.opts</h2><p>Mocha允许在test目录下面，放置配置文件mocha.opts，把命令行参数写在里面。请先进入demo03目录，运行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --recursive --reporter tap --growl</span><br></pre></td></tr></table></figure>
<p>上面这个命令有三个参数–recursive、–reporter tap、–growl。<br>然后，把这三个参数写入test目录下的mocha.opts文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--reporter tap</span><br><span class="line">--recursive</span><br><span class="line">--growl</span><br></pre></td></tr></table></figure>
<p>然后，执行mocha就能取得与第一行命令一样的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br></pre></td></tr></table></figure></p>
<p>如果测试用例不是存放在test子目录，可以在mocha.opts写入以下内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server-tests</span><br><span class="line">--recursive</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定运行server-tests目录及其子目录之中的测试脚本。</p>
<h2 id="八、ES6测试"><a href="#八、ES6测试" class="headerlink" title="八、ES6测试"></a>八、ES6测试</h2><p>如果测试脚本是用ES6写的，那么运行测试之前，需要先用Babel转码。进入demo04目录，打开test/add.test.js文件，可以看到这个测试用例是用ES6写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import add from &apos;../src/add.js&apos;;</span><br><span class="line">import chai from &apos;chai&apos;;</span><br><span class="line"></span><br><span class="line">let expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(&apos;加法函数的测试&apos;, function() &#123;</span><br><span class="line">  it(&apos;1 加 1 应该等于 2&apos;, function() &#123;</span><br><span class="line">    expect(add(1, 1)).to.be.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>ES6转码，需要安装Babel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure></p>
<p>然后，在项目目录下面，新建一个.babelrc配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [ &quot;es2015&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，使用–compilers参数指定测试脚本的转码器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ../node_modules/mocha/bin/mocha --compilers js:babel-core/register</span><br></pre></td></tr></table></figure>
<p>上面代码中，–compilers参数后面紧跟一个用冒号分隔的字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用babel-core/register模块，处理一下.js文件。由于这里的转码器安装在项目内，所以要使用项目内安装的Mocha；如果转码器安装在全局，就可以使用全局的Mocha。</p>
<p>下面是另外一个例子，使用Mocha测试CoffeeScript脚本。测试之前，先将.coffee文件转成.js文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --compilers coffee:coffee-script/register</span><br></pre></td></tr></table></figure>
<p>注意，Babel默认不会对Iterator、Generator、Promise、Map、Set等全局对象，以及一些全局对象的方法（比如Object.assign）转码。如果你想要对这些对象转码，就要安装babel-polyfill。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-polyfill --save</span><br></pre></td></tr></table></figure>
<p>然后，在你的脚本头部加上一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;babel-polyfill&apos;</span><br></pre></td></tr></table></figure>
<h2 id="九、异步测试"><a href="#九、异步测试" class="headerlink" title="九、异步测试"></a>九、异步测试</h2><p>Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或–timeout参数指定超时门槛。</p>
<p>进入demo05子目录，打开测试脚本timeout.test.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;测试应该5000毫秒后结束&apos;, function(done) &#123;</span><br><span class="line">  var x = true;</span><br><span class="line">  var f = function() &#123;</span><br><span class="line">    x = false;</span><br><span class="line">    expect(x).to.be.not.ok;</span><br><span class="line">    done(); // 通知Mocha测试结束</span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(f, 4000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的测试用例，需要4000毫秒之后，才有运行结果。所以，需要用-t或–timeout参数，改变默认的超时设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -t 5000 timeout.test.js</span><br></pre></td></tr></table></figure></p>
<p>上面命令将测试的超时时限指定为5000毫秒。</p>
<p>另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。你可以把这行删除试试看。</p>
<p>Mocha默认会高亮显示超过75毫秒的测试用例，可以用-s或–slow调整这个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -t 5000 -s 1000 timeout.test.js</span><br></pre></td></tr></table></figure>
<p>上面命令指定高亮显示耗时超过1000毫秒的测试用例。</p>
<p>下面是另外一个异步测试的例子async.test.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;异步请求应该返回一个对象&apos;, function(done)&#123;</span><br><span class="line">  request</span><br><span class="line">    .get(&apos;https://api.github.com&apos;)</span><br><span class="line">    .end(function(err, res)&#123;</span><br><span class="line">      expect(res).to.be.an(&apos;object&apos;);</span><br><span class="line">      done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行下面命令，可以看到这个测试会通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -t 10000 async.test.js</span><br></pre></td></tr></table></figure>
<p>另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done方法。请看promise.test.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;异步请求应该返回一个对象&apos;, function() &#123;</span><br><span class="line">  return fetch(&apos;https://api.github.com&apos;)</span><br><span class="line">    .then(function(res) &#123;</span><br><span class="line">      return res.json();</span><br><span class="line">    &#125;).then(function(json) &#123;</span><br><span class="line">      expect(json).to.be.an(&apos;object&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>未转载完，完整内容查看<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">原网页</a></strong></p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/02/blur()/" >
  
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/02/blur()/"><span class="article-date">
  2016-06-02
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>jQuery.blur()事件：当时区焦点时触发该事件</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/01/Ajax POST头部设置/" >
  
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/01/Ajax POST头部设置/"><span class="article-date">
  2016-06-01
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>未指定Content-Type: application/x-www-form-urlencoded将会导致服务端获取Ajax POST数据失败<br>默认情况下Ajax以 Content-Type: text/plain 提交数据，此时服务器将忽略POST实体部分的数据，所以服务端程序无法获取POST数据。</p>
<p>解决方法：<br>指定Content-Type: application/x-www-form-urlencoded 。</p>

        
      </div>
    </div>

  



  <div class="pagination">
    <a class="extend prev" rel="prev" href="/archives/2016/06/">上一页</a><a class="page-number" href="/archives/2016/06/">1</a><span class="page-number current">2</span>
  </div>




          <div class="main-footer">
  
    © 2016 findmoon-白色蜗牛 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
