<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>findmoon白色蜗牛</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
<meta property="og:type" content="website">
<meta property="og:title" content="findmoon白色蜗牛">
<meta property="og:url" content="//findmoon.github.io/index.html/page/6/index.html">
<meta property="og:site_name" content="findmoon白色蜗牛">
<meta property="og:description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="findmoon白色蜗牛">
<meta name="twitter:description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
  
    <link rel="alternative" href="/atom.xml" title="findmoon白色蜗牛" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">findmoon</a></h1>
        </hgroup>

        
        <p class="header-subtitle">一个试图专注于自身的成长者</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/Home">个人简历</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/archives">所有文章</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=hre0vrCwtbG3v77G9-eo5enr" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/findmoon/mywork" title="github">github</a>
                            
                                <a class="fl weibo" target="_blank" href="http://weibo.com/u/2637672265?is_all=1" title="weibo">weibo</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Array/" style="font-size: 11.43px;">Array</a> <a href="/tags/Arry-string-math/" style="font-size: 10px;">Arry/string/math</a> <a href="/tags/BFC/" style="font-size: 11.43px;">BFC</a> <a href="/tags/Backbone/" style="font-size: 10px;">Backbone</a> <a href="/tags/CSS3动画/" style="font-size: 10px;">CSS3动画</a> <a href="/tags/DNS解析域名/" style="font-size: 10px;">DNS解析域名</a> <a href="/tags/DOCTYPE/" style="font-size: 10px;">DOCTYPE</a> <a href="/tags/DOM事件/" style="font-size: 10px;">DOM事件</a> <a href="/tags/Data/" style="font-size: 10px;">Data</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/MV模式/" style="font-size: 12.86px;">MV模式</a> <a href="/tags/Mocha/" style="font-size: 10px;">Mocha</a> <a href="/tags/OO/" style="font-size: 10px;">OO</a> <a href="/tags/TCP-UDP/" style="font-size: 11.43px;">TCP/UDP</a> <a href="/tags/TCP三次握手/" style="font-size: 10px;">TCP三次握手</a> <a href="/tags/TDD/" style="font-size: 10px;">TDD</a> <a href="/tags/UNICODE-ASCII/" style="font-size: 10px;">UNICODE/ASCII</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/animate/" style="font-size: 10px;">animate()</a> <a href="/tags/animate动画队列/" style="font-size: 10px;">animate动画队列</a> <a href="/tags/background-image/" style="font-size: 10px;">background-image</a> <a href="/tags/border/" style="font-size: 12.86px;">border</a> <a href="/tags/border图形/" style="font-size: 10px;">border图形</a> <a href="/tags/box-shadow/" style="font-size: 10px;">box-shadow</a> <a href="/tags/console-log/" style="font-size: 10px;">console.log()</a> <a href="/tags/css/" style="font-size: 12.86px;">css</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/css属性/" style="font-size: 11.43px;">css属性</a> <a href="/tags/css样式/" style="font-size: 10px;">css样式</a> <a href="/tags/deferred/" style="font-size: 11.43px;">deferred</a> <a href="/tags/delete/" style="font-size: 11.43px;">delete</a> <a href="/tags/first-child/" style="font-size: 10px;">first-child</a> <a href="/tags/first-of-type/" style="font-size: 10px;">first-of-type</a> <a href="/tags/float/" style="font-size: 11.43px;">float</a> <a href="/tags/font-face/" style="font-size: 10px;">font-face</a> <a href="/tags/form表单/" style="font-size: 10px;">form表单</a> <a href="/tags/get/" style="font-size: 10px;">get</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gitbash/" style="font-size: 10px;">gitbash</a> <a href="/tags/git错误/" style="font-size: 10px;">git错误</a> <a href="/tags/hack/" style="font-size: 10px;">hack</a> <a href="/tags/haslayout/" style="font-size: 10px;">haslayout</a> <a href="/tags/html/" style="font-size: 17.14px;">html</a> <a href="/tags/html-css/" style="font-size: 11.43px;">html/css</a> <a href="/tags/http/" style="font-size: 12.86px;">http</a> <a href="/tags/http状态码/" style="font-size: 10px;">http状态码</a> <a href="/tags/inline-block/" style="font-size: 10px;">inline-block</a> <a href="/tags/input/" style="font-size: 10px;">input</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/instanceof-typeof/" style="font-size: 11.43px;">instanceof/typeof</a> <a href="/tags/jQuery/" style="font-size: 11.43px;">jQuery</a> <a href="/tags/js/" style="font-size: 18.57px;">js</a> <a href="/tags/json/" style="font-size: 12.86px;">json</a> <a href="/tags/js严格模式/" style="font-size: 10px;">js严格模式</a> <a href="/tags/js加载/" style="font-size: 10px;">js加载</a> <a href="/tags/js模板引擎/" style="font-size: 10px;">js模板引擎</a> <a href="/tags/js鼠标位置/" style="font-size: 10px;">js鼠标位置</a> <a href="/tags/list-style/" style="font-size: 10px;">list-style</a> <a href="/tags/meta/" style="font-size: 10px;">meta</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/offset/" style="font-size: 10px;">offset()</a> <a href="/tags/overflow/" style="font-size: 10px;">overflow</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/placeholder/" style="font-size: 10px;">placeholder</a> <a href="/tags/position/" style="font-size: 10px;">position</a> <a href="/tags/position文档流/" style="font-size: 10px;">position文档流</a> <a href="/tags/post/" style="font-size: 10px;">post</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/requirejs/" style="font-size: 10px;">requirejs</a> <a href="/tags/scopechain/" style="font-size: 10px;">scopechain</a> <a href="/tags/stopImmediatePropagation/" style="font-size: 10px;">stopImmediatePropagation</a> <a href="/tags/stringify/" style="font-size: 10px;">stringify</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/this/" style="font-size: 12.86px;">this</a> <a href="/tags/typeof/" style="font-size: 11.43px;">typeof</a> <a href="/tags/undefined/" style="font-size: 10px;">undefined</a> <a href="/tags/url加载/" style="font-size: 10px;">url加载</a> <a href="/tags/warterfall/" style="font-size: 10px;">warterfall</a> <a href="/tags/zoom/" style="font-size: 10px;">zoom</a> <a href="/tags/代码书写/" style="font-size: 10px;">代码书写</a> <a href="/tags/函数/" style="font-size: 14.29px;">函数</a> <a href="/tags/列表/" style="font-size: 10px;">列表</a> <a href="/tags/前端/" style="font-size: 14.29px;">前端</a> <a href="/tags/前端css/" style="font-size: 12.86px;">前端css</a> <a href="/tags/前端html/" style="font-size: 10px;">前端html</a> <a href="/tags/动画animation/" style="font-size: 10px;">动画animation</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/变量/" style="font-size: 11.43px;">变量</a> <a href="/tags/同源策略/" style="font-size: 10px;">同源策略</a> <a href="/tags/同源跨域/" style="font-size: 15.71px;">同源跨域</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/字面量/" style="font-size: 10px;">字面量</a> <a href="/tags/库与架构/" style="font-size: 10px;">库与架构</a> <a href="/tags/懒加载/" style="font-size: 10px;">懒加载</a> <a href="/tags/数学函数/" style="font-size: 10px;">数学函数</a> <a href="/tags/数据包组装/" style="font-size: 10px;">数据包组装</a> <a href="/tags/数组/" style="font-size: 11.43px;">数组</a> <a href="/tags/方法/" style="font-size: 10px;">方法</a> <a href="/tags/标记语言/" style="font-size: 10px;">标记语言</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/模块化编程/" style="font-size: 12.86px;">模块化编程</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/盒模型/" style="font-size: 10px;">盒模型</a> <a href="/tags/立即执行函数/" style="font-size: 10px;">立即执行函数</a> <a href="/tags/简历/" style="font-size: 10px;">简历</a> <a href="/tags/继承/" style="font-size: 10px;">继承</a> <a href="/tags/网站访问/" style="font-size: 10px;">网站访问</a> <a href="/tags/获取路径/" style="font-size: 14.29px;">获取路径</a> <a href="/tags/行内元素/" style="font-size: 10px;">行内元素</a> <a href="/tags/语法/" style="font-size: 10px;">语法</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/跨域请求/" style="font-size: 11.43px;">跨域请求</a> <a href="/tags/跨域请求处理方法/" style="font-size: 10px;">跨域请求处理方法</a> <a href="/tags/选择器/" style="font-size: 10px;">选择器</a> <a href="/tags/闭包/" style="font-size: 10px;">闭包</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://luuman.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">人生是一场不断的转换，我们总是不断地试着所向披靡</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">findmoon</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">findmoon</a></h1>
            </hgroup>
            
            <p class="header-subtitle">一个试图专注于自身的成长者</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/Home">个人简历</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/archives">所有文章</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=hre0vrCwtbG3v77G9-eo5enr" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/findmoon/mywork" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="http://weibo.com/u/2637672265?is_all=1" title="weibo">weibo</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-测试框架 Mocha 实例教程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/03/测试框架 Mocha 实例教程/" class="article-date">
      <time datetime="2016-06-03T11:17:56.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/测试框架 Mocha 实例教程/">测试框架 Mocha 实例教程*转</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">测试框架 Mocha 实例教程*转</a></p>
<ul>
<li>转自阮一峰的王若日志</li>
</ul>
<p><a href="https://mochajs.org/" target="_blank" rel="external">Mocha</a>（发音”摩卡”）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。<br>所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。</p>
<p>本文全面介绍如何使用Mocha，让你轻松上手。如果你以前对测试一无所知，本文也可以当作JavaScript单元测试入门。值得说明的是，除了Mocha以外，类似的测试框架还有<a href="http://jasmine.github.io/" target="_blank" rel="external">Jasmine</a>、<a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="external">Karma</a>、<a href="https://github.com/substack/tape/" target="_blank" rel="external">Tape</a>等，也很值得学习。</p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>我为本文写了一个示例库Mocha-demos（<a href="https://github.com/ruanyf/mocha-demos），请先安装这个库。" target="_blank" rel="external">https://github.com/ruanyf/mocha-demos），请先安装这个库。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/ruanyf/mocha-demos.git</span><br></pre></td></tr></table></figure></p>
<p>然后，进入mocha-demos目录，安装依赖（你的电脑必须有Node）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd mocha-demos</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>上面代码会在目录内部安装Mocha，为了操作的方便，请在全面环境也安装一下Mocha。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --global mocha</span><br></pre></td></tr></table></figure></p>
<h2 id="二、测试脚本的写法"><a href="#二、测试脚本的写法" class="headerlink" title="二、测试脚本的写法"></a>二、测试脚本的写法</h2><p>Mocha的作用是运行测试脚本，首先必须学会写测试脚本。所谓”测试脚本”，就是用来测试源码的脚本。</p>
<p>下面是一个加法模块add.js的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// add.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = add;</span><br></pre></td></tr></table></figure></p>
<p>要测试这个加法模块是否正确，就要写测试脚本。</p>
<p>通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。比如，add.js的测试脚本名字就是add.test.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// add.test.js</span><br><span class="line">var add = require(&apos;./add.js&apos;);</span><br><span class="line">var expect = require(&apos;chai&apos;).expect;</span><br><span class="line"></span><br><span class="line">describe(&apos;加法函数的测试&apos;, function() &#123;</span><br><span class="line">  it(&apos;1 加 1 应该等于 2&apos;, function() &#123;</span><br><span class="line">    expect(add(1, 1)).to.be.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。</p>
<p>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。</p>
<p>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。</p>
<h2 id="三、断言库的用法"><a href="#三、断言库的用法" class="headerlink" title="三、断言库的用法"></a>三、断言库的用法</h2><p>上面的测试脚本里面，有一句断言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(add(1, 1)).to.be.equal(2)</span><br></pre></td></tr></table></figure></p>
<p>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。上面这句断言的意思是，调用add(1, 1)，结果应该等于2。</p>
<p>所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expect = require(&apos;chai&apos;).expect;</span><br></pre></td></tr></table></figure></p>
<p>断言库有很多种，Mocha并不限制使用哪一种。上面代码引入的断言库是chai(<a href="http://chaijs.com/)，并且指定使用它的expect(http://chaijs.com/api/bdd/)断言风格。" target="_blank" rel="external">http://chaijs.com/)，并且指定使用它的expect(http://chaijs.com/api/bdd/)断言风格。</a></p>
<p>expect断言的优点是很接近自然语言，下面是一些例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 相等或不相等</span><br><span class="line">expect(4 + 5).to.be.equal(9);</span><br><span class="line">expect(4 + 5).to.be.not.equal(10);</span><br><span class="line">expect(foo).to.be.deep.equal(&#123; bar: &apos;baz&apos; &#125;);</span><br><span class="line"></span><br><span class="line">// 布尔值为true</span><br><span class="line">expect(&apos;everthing&apos;).to.be.ok;</span><br><span class="line">expect(false).to.not.be.ok;</span><br><span class="line"></span><br><span class="line">// typeof</span><br><span class="line">expect(&apos;test&apos;).to.be.a(&apos;string&apos;);</span><br><span class="line">expect(&#123; foo: &apos;bar&apos; &#125;).to.be.an(&apos;object&apos;);</span><br><span class="line">expect(foo).to.be.an.instanceof(Foo);</span><br><span class="line"></span><br><span class="line">// include</span><br><span class="line">expect([1,2,3]).to.include(2);</span><br><span class="line">expect(&apos;foobar&apos;).to.contain(&apos;foo&apos;);</span><br><span class="line">expect(&#123; foo: &apos;bar&apos;, hello: &apos;universe&apos; &#125;).to.include.keys(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">// empty</span><br><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(&apos;&apos;).to.be.empty;</span><br><span class="line">expect(&#123;&#125;).to.be.empty;</span><br><span class="line"></span><br><span class="line">// match</span><br><span class="line">expect(&apos;foobar&apos;).to.match(/^foo/);</span><br></pre></td></tr></table></figure></p>
<p>基本上，expect断言的写法都是一样的。头部是expect方法，尾部是断言方法，比如equal、a/an、ok、match等。两者之间使用to或to.be连接。<br>如果expect断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;1 加 1 应该等于 2&apos;, function() &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的这个测试用例，内部没有任何代码，由于没有抛出了错误，所以还是会通过。</p>
<h2 id="四、Mocha的基本用法"><a href="#四、Mocha的基本用法" class="headerlink" title="四、Mocha的基本用法"></a>四、Mocha的基本用法</h2><p>有了测试脚本以后，就可以用Mocha运行它。请进入demo01子目录，执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mocha add.test.js</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line"></span><br><span class="line">  1 passing (8ms)</span><br></pre></td></tr></table></figure></p>
<p>上面的运行结果表示，测试脚本通过了测试，一共只有1个测试用例，耗时是8毫秒。</p>
<p>mocha命令后面紧跟测试脚本的路径和文件名，可以指定多个测试脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha file1 file2 file3</span><br></pre></td></tr></table></figure>
<p>Mocha默认运行test子目录里面的测试脚本。所以，一般都会把测试脚本放在test目录里面，然后执行mocha就不需要参数了。请进入demo02子目录，运行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line">    ✓ 任何数加0应该等于自身</span><br><span class="line"></span><br><span class="line">  2 passing (9ms)</span><br></pre></td></tr></table></figure>
<p>这时可以看到，test子目录里面的测试脚本执行了。但是，你打开test子目录，会发现下面还有一个test/dir子目录，里面还有一个测试脚本multiply.test.js，并没有得到执行。原来，Mocha默认只执行test子目录下面第一层的测试用例，不会执行更下层的用例。</p>
<p>为了改变这种行为，就必须加上–recursive参数，这时test子目录下面所有的测试用例—-不管在哪一层—-都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --recursive</span><br><span class="line"></span><br><span class="line">  加法函数的测试</span><br><span class="line">    ✓ 1 加 1 应该等于 2</span><br><span class="line">    ✓ 任何数加0应该等于自身</span><br><span class="line"></span><br><span class="line">  乘法函数的测试</span><br><span class="line">    ✓ 1 乘 1 应该等于 1</span><br><span class="line"></span><br><span class="line">  3 passing (9ms)</span><br></pre></td></tr></table></figure></p>
<h2 id="五、通配符"><a href="#五、通配符" class="headerlink" title="五、通配符"></a>五、通配符</h2><p>命令行指定测试脚本时，可以使用通配符，同时指定多个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mocha spec/&#123;my,awesome&#125;.js</span><br><span class="line">$ mocha test/unit/*.js</span><br></pre></td></tr></table></figure>
<p>上面的第一行命令，指定执行spec目录下面的my.js和awesome.js。第二行命令，指定执行test/unit目录下面的所有js文件。<br>除了使用Shell通配符，还可以使用Node通配符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha &apos;test/**/*.@(js|jsx)&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码指定运行test目录下面任何子目录中、文件后缀名为js或jsx的测试脚本。注意，Node的通配符要放在单引号之中，否则星号（*）会先被Shell解释。</p>
<p>上面这行Node通配符，如果改用Shell通配符，要写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha test/&#123;,**/&#125;*.&#123;js,jsx&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、命令行参数"><a href="#六、命令行参数" class="headerlink" title="六、命令行参数"></a>六、命令行参数</h2><p>除了前面介绍的–recursive，Mocha还可以加上其他命令行参数。请在demo02子目录里面，运行下面的命令，查看效果。</p>
<h3 id="6-1-–help-h"><a href="#6-1-–help-h" class="headerlink" title="6.1 –help, -h"></a>6.1 –help, -h</h3><p>–help或-h参数，用来查看Mocha的所有命令行参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --help</span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-–reporter-R"><a href="#6-2-–reporter-R" class="headerlink" title="6.2 –reporter, -R"></a>6.2 –reporter, -R</h3><p>–reporter参数用来指定测试报告的格式，默认是spec格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br><span class="line"># 等同于</span><br><span class="line">$ mocha --reporter spec</span><br></pre></td></tr></table></figure></p>
<p>除了spec格式，官方网站还提供了其他许多<a href="http://mochajs.org/#reporters" target="_blank" rel="external">报告格式</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --reporter tap</span><br><span class="line"></span><br><span class="line">1..2</span><br><span class="line">ok 1 加法函数的测试 1 加 1 应该等于 2</span><br><span class="line">ok 2 加法函数的测试 任何数加0应该等于自身</span><br><span class="line"># tests 2</span><br><span class="line"># pass 2</span><br><span class="line"># fail 0</span><br></pre></td></tr></table></figure></p>
<p>上面是tap格式报告的显示结果。</p>
<p>–reporters参数可以显示所有内置的报告格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --reporters</span><br></pre></td></tr></table></figure></p>
<p>使用mochawesome模块，可以生成漂亮的HTML格式的报告。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120303.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev mochawesome</span><br><span class="line">$ ../node_modules/.bin/mocha --reporter mochawesome</span><br></pre></td></tr></table></figure>
<p>上面代码中，mocha命令使用了项目内安装的版本，而不是全局安装的版本，因为mochawesome模块是安装在项目内的。</p>
<p>然后，测试结果报告就在mochaawesome-reports子目录生成。</p>
<h3 id="6-3-–growl-G"><a href="#6-3-–growl-G" class="headerlink" title="6.3 –growl, -G"></a>6.3 –growl, -G</h3><p>打开–growl参数，就会将测试结果在桌面显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --growl</span><br></pre></td></tr></table></figure></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120304.png" alt=""></p>
<h3 id="6-4-–watch，-w"><a href="#6-4-–watch，-w" class="headerlink" title="6.4 –watch，-w"></a>6.4 –watch，-w</h3><p>–watch参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --watch</span><br></pre></td></tr></table></figure></p>
<p>上面命令执行以后，并不会退出。你可以另外打开一个终端窗口，修改test目录下面的测试脚本add.test.js，比如删除一个测试用例，一旦保存，Mocha就会再次自动运行。</p>
<h3 id="6-5-–bail-b"><a href="#6-5-–bail-b" class="headerlink" title="6.5 –bail, -b"></a>6.5 –bail, -b</h3><p>–bail参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --bail</span><br></pre></td></tr></table></figure></p>
<h3 id="6-6-–grep-g"><a href="#6-6-–grep-g" class="headerlink" title="6.6 –grep, -g"></a>6.6 –grep, -g</h3><p>–grep参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --grep &quot;1 加 1&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码只测试名称中包含”1 加 1”的测试用例。</p>
<h3 id="6-7-–invert-i"><a href="#6-7-–invert-i" class="headerlink" title="6.7 –invert, -i"></a>6.7 –invert, -i</h3><p>–invert参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --grep &quot;1 加 1&quot; --invert</span><br></pre></td></tr></table></figure></p>
<h2 id="七，配置文件mocha-opts"><a href="#七，配置文件mocha-opts" class="headerlink" title="七，配置文件mocha.opts"></a>七，配置文件mocha.opts</h2><p>Mocha允许在test目录下面，放置配置文件mocha.opts，把命令行参数写在里面。请先进入demo03目录，运行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --recursive --reporter tap --growl</span><br></pre></td></tr></table></figure>
<p>上面这个命令有三个参数–recursive、–reporter tap、–growl。<br>然后，把这三个参数写入test目录下的mocha.opts文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--reporter tap</span><br><span class="line">--recursive</span><br><span class="line">--growl</span><br></pre></td></tr></table></figure>
<p>然后，执行mocha就能取得与第一行命令一样的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br></pre></td></tr></table></figure></p>
<p>如果测试用例不是存放在test子目录，可以在mocha.opts写入以下内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server-tests</span><br><span class="line">--recursive</span><br></pre></td></tr></table></figure></p>
<p>上面代码指定运行server-tests目录及其子目录之中的测试脚本。</p>
<h2 id="八、ES6测试"><a href="#八、ES6测试" class="headerlink" title="八、ES6测试"></a>八、ES6测试</h2><p>如果测试脚本是用ES6写的，那么运行测试之前，需要先用Babel转码。进入demo04目录，打开test/add.test.js文件，可以看到这个测试用例是用ES6写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import add from &apos;../src/add.js&apos;;</span><br><span class="line">import chai from &apos;chai&apos;;</span><br><span class="line"></span><br><span class="line">let expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(&apos;加法函数的测试&apos;, function() &#123;</span><br><span class="line">  it(&apos;1 加 1 应该等于 2&apos;, function() &#123;</span><br><span class="line">    expect(add(1, 1)).to.be.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>ES6转码，需要安装Babel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure></p>
<p>然后，在项目目录下面，新建一个.babelrc配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [ &quot;es2015&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，使用–compilers参数指定测试脚本的转码器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ../node_modules/mocha/bin/mocha --compilers js:babel-core/register</span><br></pre></td></tr></table></figure>
<p>上面代码中，–compilers参数后面紧跟一个用冒号分隔的字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用babel-core/register模块，处理一下.js文件。由于这里的转码器安装在项目内，所以要使用项目内安装的Mocha；如果转码器安装在全局，就可以使用全局的Mocha。</p>
<p>下面是另外一个例子，使用Mocha测试CoffeeScript脚本。测试之前，先将.coffee文件转成.js文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --compilers coffee:coffee-script/register</span><br></pre></td></tr></table></figure>
<p>注意，Babel默认不会对Iterator、Generator、Promise、Map、Set等全局对象，以及一些全局对象的方法（比如Object.assign）转码。如果你想要对这些对象转码，就要安装babel-polyfill。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-polyfill --save</span><br></pre></td></tr></table></figure>
<p>然后，在你的脚本头部加上一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;babel-polyfill&apos;</span><br></pre></td></tr></table></figure>
<h2 id="九、异步测试"><a href="#九、异步测试" class="headerlink" title="九、异步测试"></a>九、异步测试</h2><p>Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或–timeout参数指定超时门槛。</p>
<p>进入demo05子目录，打开测试脚本timeout.test.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;测试应该5000毫秒后结束&apos;, function(done) &#123;</span><br><span class="line">  var x = true;</span><br><span class="line">  var f = function() &#123;</span><br><span class="line">    x = false;</span><br><span class="line">    expect(x).to.be.not.ok;</span><br><span class="line">    done(); // 通知Mocha测试结束</span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(f, 4000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的测试用例，需要4000毫秒之后，才有运行结果。所以，需要用-t或–timeout参数，改变默认的超时设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -t 5000 timeout.test.js</span><br></pre></td></tr></table></figure></p>
<p>上面命令将测试的超时时限指定为5000毫秒。</p>
<p>另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。你可以把这行删除试试看。</p>
<p>Mocha默认会高亮显示超过75毫秒的测试用例，可以用-s或–slow调整这个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -t 5000 -s 1000 timeout.test.js</span><br></pre></td></tr></table></figure>
<p>上面命令指定高亮显示耗时超过1000毫秒的测试用例。</p>
<p>下面是另外一个异步测试的例子async.test.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;异步请求应该返回一个对象&apos;, function(done)&#123;</span><br><span class="line">  request</span><br><span class="line">    .get(&apos;https://api.github.com&apos;)</span><br><span class="line">    .end(function(err, res)&#123;</span><br><span class="line">      expect(res).to.be.an(&apos;object&apos;);</span><br><span class="line">      done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行下面命令，可以看到这个测试会通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -t 10000 async.test.js</span><br></pre></td></tr></table></figure>
<p>另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done方法。请看promise.test.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;异步请求应该返回一个对象&apos;, function() &#123;</span><br><span class="line">  return fetch(&apos;https://api.github.com&apos;)</span><br><span class="line">    .then(function(res) &#123;</span><br><span class="line">      return res.json();</span><br><span class="line">    &#125;).then(function(json) &#123;</span><br><span class="line">      expect(json).to.be.an(&apos;object&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>未转载完，完整内容查看<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">原网页</a></strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/npm/">npm</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mocha/">Mocha</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-blur()" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/02/blur()/" class="article-date">
      <time datetime="2016-06-02T10:16:40.121Z" itemprop="datePublished">2016-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>jQuery.blur()事件：当时区焦点时触发该事件</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ajax POST头部设置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/01/Ajax POST头部设置/" class="article-date">
      <time datetime="2016-06-01T14:34:30.764Z" itemprop="datePublished">2016-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>未指定Content-Type: application/x-www-form-urlencoded将会导致服务端获取Ajax POST数据失败<br>默认情况下Ajax以 Content-Type: text/plain 提交数据，此时服务器将忽略POST实体部分的数据，所以服务端程序无法获取POST数据。</p>
<p>解决方法：<br>指定Content-Type: application/x-www-form-urlencoded 。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法/" class="article-date">
      <time datetime="2016-05-31T13:17:56.000Z" itemprop="datePublished">2016-05-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法/">阮一峰的网络日志*Javascript模块化编程（三）require.js的用法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Javascript模块化编程（三）require-js的用法"><a href="#Javascript模块化编程（三）require-js的用法" class="headerlink" title="Javascript模块化编程（三）require.js的用法"></a>Javascript模块化编程（三）require.js的用法</h1><p>原文地址：<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a></p>
<h2 id="一、为什么要用require-js？"><a href="#一、为什么要用require-js？" class="headerlink" title="一、为什么要用require.js？"></a>一、为什么要用require.js？</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码依次加载多个js文件。<br>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。<br>require.js的诞生，就是为了解决这两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![](http://image.beekka.com/blog/201211/bg2012110701.png)</span><br><span class="line">	（1）实现js文件的异步加载，避免网页失去响应；</span><br><span class="line">　　（2）管理模块之间的依赖性，便于代码的编写和维护。</span><br></pre></td></tr></table></figure>
<h2 id="二、require-js的加载"><a href="#二、require-js的加载" class="headerlink" title="二、require.js的加载"></a>二、require.js的加载</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。</p>
<p>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h2 id="三、主模块的写法"><a href="#三、主模块的写法" class="headerlink" title="三、主模块的写法"></a>三、主模块的写法</h2><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。</p>
<p>下面就来看，怎么写main.js。</p>
<p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　alert(&quot;加载成功！&quot;);</span><br></pre></td></tr></table></figure>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>下面，我们看一个实际的例子。</p>
<p>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h2 id="四、模块的加载"><a href="#四、模块的加载" class="headerlink" title="四、模块的加载"></a>四、模块的加载</h2><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。</p>
<p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　baseUrl: &quot;js/lib&quot;,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个<a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="external">优化工具</a>，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h2 id="五、AMD模块的写法"><a href="#五、AMD模块的写法" class="headerlink" title="五、AMD模块的写法"></a>五、AMD模块的写法</h2><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>假定现在有一个math.js文件，它定义了一个math模块。那么,math.js就要这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　// math.js</span><br><span class="line">　　define(function ()&#123;</span><br><span class="line">　　　　var add = function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>加载方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　require([&apos;math&apos;], function (math)&#123;</span><br><span class="line">　　　　alert(math.add(1,1));</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　define([&apos;myLib&apos;], function(myLib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h2 id="六、加载非规范的模块"><a href="#六、加载非规范的模块" class="headerlink" title="六、加载非规范的模块"></a>六、加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>回答是可以的。</p>
<p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　&apos;underscore&apos;:&#123;</span><br><span class="line">　　　　　　　　exports: &apos;_&apos;</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　&apos;backbone&apos;: &#123;</span><br><span class="line">　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],</span><br><span class="line">　　　　　　　　exports: &apos;Backbone&apos;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义<strong>（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</strong></p>
<p>比如，jQuery的插件可以这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　shim: &#123;</span><br><span class="line">　　　　&apos;jquery.scroll&apos;: &#123;</span><br><span class="line">　　　　　　deps: [&apos;jquery&apos;],</span><br><span class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、require-js插件"><a href="#七、require-js插件" class="headerlink" title="七、require.js插件"></a>七、require.js插件</h2><p>require.js还提供一系列<a href="https://github.com/requirejs/requirejs/wiki/Plugins" target="_blank" rel="external">插件</a>，实现一些特定的功能。</p>
<p>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;domready!&apos;], function (doc)&#123;</span><br><span class="line">　　　　// called once the DOM is ready</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　define([</span><br><span class="line">　　　　&apos;text!review.txt&apos;,</span><br><span class="line">　　　　&apos;image!cat.jpg&apos;</span><br><span class="line">　　　　],</span><br><span class="line"></span><br><span class="line">　　　　function(review,cat)&#123;</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure>
<p>类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/js/">js</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范/" class="article-date">
      <time datetime="2016-05-31T10:17:56.000Z" itemprop="datePublished">2016-05-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范/">阮一峰的网络日志*Javascript模块化编程（二）AMD规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Javascript模块化编程（二）AMD规范"><a href="#Javascript模块化编程（二）AMD规范" class="headerlink" title="Javascript模块化编程（二）AMD规范"></a>Javascript模块化编程（二）AMD规范</h1><p>原文地址 <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a></p>
<h2 id="七、模块的规范"><a href="#七、模块的规范" class="headerlink" title="七、模块的规范"></a>七、模块的规范</h2><p>先想一想，为什么模块很重要？</p>
<p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p>
<p>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。</p>
<p>目前，通行的Javascript模块规范共有两种：<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>。这里主要介绍AMD，但是要先从CommonJS讲起。</p>
<h2 id="八、CommonJS"><a href="#八、CommonJS" class="headerlink" title="八、CommonJS"></a>八、CommonJS</h2><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p><img src="http://image.beekka.com/blog/201210/bg2012103002.jpg" alt=""></p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br></pre></td></tr></table></figure></p>
<p>然后，就可以调用模块提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br><span class="line">　　math.add(2,3); // 5</span><br></pre></td></tr></table></figure>
<p>因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。</p>
<p>#九、浏览器环境</p>
<p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br><span class="line">　　math.add(2, 3);</span><br></pre></td></tr></table></figure>
<p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h2 id="十、AMD"><a href="#十、AMD" class="headerlink" title="十、AMD"></a>十、AMD</h2><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　require([module], callback);</span><br></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　　　　math.add(2, 3);</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="external">curl.js</a>。本系列的第三部分，将通过介绍require.js，进一步讲解AMD的用法，以及如何将模块化编程投入实战。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/js/">js</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法/" class="article-date">
      <time datetime="2016-05-31T02:17:56.000Z" itemprop="datePublished">2016-05-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法/">阮一峰的网络日志*Javascript模块化编程（一）模块的写法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>原文地址：<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>
<h1 id="Javascript模块化编程（一）模块的写法"><a href="#Javascript模块化编程（一）模块的写法" class="headerlink" title="Javascript模块化编程（一）模块的写法"></a>Javascript模块化编程（一）模块的写法</h1><p>网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。</p>
<p>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还未广泛应用。）</p>
<h2 id="一、原始写法"><a href="#一、原始写法" class="headerlink" title="一、原始写法"></a>一、原始写法</h2><p>模块就是实现特定功能的一组方法。</p>
<p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　function m1()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line">　　function m2()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。</p>
<p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<p>##二、对象写法<br>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = new Object(&#123;</span><br><span class="line">　　　　_count : 0,</span><br><span class="line">　　　　m1 : function ()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　m2 : function ()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　module1.m1();</span><br></pre></td></tr></table></figure>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　module1._count = 5;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、立即执行函数写法"><a href="#三、立即执行函数写法" class="headerlink" title="三、立即执行函数写法"></a>三、立即执行函数写法</h2><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function()&#123;</span><br><span class="line">　　　　var _count = 0;</span><br><span class="line">　　　　var m1 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　var m2 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　m1 : m1,</span><br><span class="line">　　　　　　m2 : m2</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;)();</span><br></pre></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的_count变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></p>
<p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<h2 id="四、放大模式"><a href="#四、放大模式" class="headerlink" title="四、放大模式"></a>四、放大模式</h2><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function (mod)&#123;</span><br><span class="line">　　　　mod.m3 = function () &#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return mod;</span><br><span class="line">　　&#125;)(module1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<h2 id="五、宽放大模式（Loose-augmentation）"><a href="#五、宽放大模式（Loose-augmentation）" class="headerlink" title="五、宽放大模式（Loose augmentation）"></a>五、宽放大模式（Loose augmentation）</h2><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = ( function (mod)&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　　　return mod;</span><br><span class="line">　　&#125;)(window.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<h2 id="六、输入全局变量"><a href="#六、输入全局变量" class="headerlink" title="六、输入全局变量"></a>六、输入全局变量</h2><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function ($, YAHOO) &#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">《JavaScript Module Pattern: In-Depth》</a>。</p>
<p>这个系列的第二部分，将讨论如何在浏览器环境组织不同的模块、管理模块之间的依赖性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/js/">js</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jQuery对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/28/jQuery对象/" class="article-date">
      <time datetime="2016-05-28T06:51:10.391Z" itemprop="datePublished">2016-05-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>jQuery对象与原生对象的转换</p>
<p>$(原生对象)变为jQuery对象<br>jQuery对象[0]变为原生对象，即以取数组下标的方式<br>jQuery对象eq(0)获取jQuery对象</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jQuery中animate动画队列的停止和清除" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/27/jQuery中animate动画队列的停止和清除/" class="article-date">
      <time datetime="2016-05-27T10:15:32.000Z" itemprop="datePublished">2016-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/27/jQuery中animate动画队列的停止和清除/">jQuery中animate动画队列的停止和清除</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>jQuery中animate动画队列的停止和清除,转载自<a href="http://www.css88.com/" target="_blank" rel="external">web前端开发</a></p>
<blockquote>
<p>.finish([queue ])<br>描述: 停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画<br>当.finish()在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值（愚人码头注：就是所有动画的目标值）。所有排队的动画将被删除。</p>
</blockquote>
<p>如果第一个参数提供，该字符串表示的队列中的动画将被停止。</p>
<p>.finish()方法和.stop(true, true)很相似，.stop(true, true)将清除队列，并且目前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的CSS属性跳转到他们的最终值。</p>
<p><em>动画可能因为全局的$.fx.off 属性设置为 true而停止。当这样做时，所有动画方法将立即设置元素的css属性为其最终调用后的状态，而不是显示动画效果。</em></p>
<p>例子:</p>
<p>Click the Go button once to start the animation, and then click the other buttons to see how they affect the current and queued animations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;.box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 10px;</span><br><span class="line">  left: 10px;</span><br><span class="line">  width: 15px;</span><br><span class="line">  height: 15px;</span><br><span class="line">  background: black;</span><br><span class="line">&#125;</span><br><span class="line">#path &#123;</span><br><span class="line">  height: 244px;</span><br><span class="line">  font-size: 70%;</span><br><span class="line">  border-left: 2px dashed red;</span><br><span class="line">  border-bottom: 2px dashed green;</span><br><span class="line">  border-right: 2px dashed blue;</span><br><span class="line">&#125;</span><br><span class="line">button &#123;</span><br><span class="line">  width: 12em;</span><br><span class="line">  display: block;</span><br><span class="line">  text-align: left;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;path&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;go&quot;&gt;Go&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bstt&quot; class=&quot;b&quot;&gt;.stop(true,true)&lt;/button&gt;</span><br><span class="line">  &lt;button id=&quot;bcf&quot; class=&quot;b&quot;&gt;.clearQueue().finish()&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bstf&quot; class=&quot;b&quot;&gt;.stop(true, false)&lt;/button&gt;</span><br><span class="line">  &lt;button id=&quot;bcs&quot; class=&quot;b&quot;&gt;.clearQueue().stop()&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bsff&quot; class=&quot;b&quot;&gt;.stop(false, false)&lt;/button&gt;</span><br><span class="line">  &lt;button id=&quot;bs&quot; class=&quot;b&quot;&gt;.stop()&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bsft&quot; class=&quot;b&quot;&gt;.stop(false, true)&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;bf&quot; class=&quot;b&quot;&gt;.finish()&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var horiz = $(&quot;#path&quot;).width() - 20,</span><br><span class="line">    vert = $(&quot;#path&quot;).height() - 20;</span><br><span class="line"> </span><br><span class="line">var btns = &#123;</span><br><span class="line">  bstt: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(true, true);</span><br><span class="line">  &#125;,</span><br><span class="line">  bs: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop();</span><br><span class="line">  &#125;,</span><br><span class="line">  bsft: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(false, true);</span><br><span class="line">  &#125;,</span><br><span class="line">  bf: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).finish();</span><br><span class="line">  &#125;,</span><br><span class="line">  bcf: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).clearQueue().finish();</span><br><span class="line">  &#125;,</span><br><span class="line">  bsff: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(false, false);</span><br><span class="line">  &#125;,</span><br><span class="line">  bstf: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).stop(true, false);</span><br><span class="line">  &#125;,</span><br><span class="line">  bcs: function () &#123;</span><br><span class="line">    $(&quot;div.box&quot;).clearQueue().stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">$(&quot;button.b&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class="line">  btns[this.id]();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">$(&quot;#go&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class="line">  $(&quot;.box&quot;)</span><br><span class="line">    .clearQueue()</span><br><span class="line">    .stop()</span><br><span class="line">    .css(&#123;</span><br><span class="line">    left: 10,</span><br><span class="line">    top: 10</span><br><span class="line">  &#125;)</span><br><span class="line">    .animate(&#123;</span><br><span class="line">    top: vert</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">    .animate(&#123;</span><br><span class="line">    left: horiz</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">    .animate(&#123;</span><br><span class="line">    top: 10</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.css88.com/jqapi-1.9/finish/" target="_blank" rel="external">具体演示效果参看原网页</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/jQuery/">jQuery</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animate动画队列/">animate动画队列</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Javascript的this用法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/26/Javascript的this用法/" class="article-date">
      <time datetime="2016-05-26T14:07:32.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/Javascript的this用法/">Javascript的this用法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Javascript的this用法</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">转载-阮一峰的网络日志</a></p>
<ul>
<li>this是Javascript语言的一个关键字。</li>
</ul>
<p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。<br>下面分四种情况，详细讨论this的用法。</p>
<h3 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h3><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。<br>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p>
<p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p>
<p>运行结果还是1。再变一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 0;</span><br><span class="line">　　&#125;</span><br><span class="line">　　test();</span><br><span class="line">　　alert(x); //0</span><br></pre></td></tr></table></figure></p>
<h3 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h3><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = &#123;&#125;;</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m(); // 1</span><br></pre></td></tr></table></figure></p>
<h3 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 作为构造函数调用</h3><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(o.x); // 1</span><br></pre></td></tr></table></figure></p>
<p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 2;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(x); //2</span><br></pre></td></tr></table></figure></p>
<p>运行结果为2，表明全局变量x的值根本没变。</p>
<h3 id="情况四-apply调用"><a href="#情况四-apply调用" class="headerlink" title="情况四 apply调用"></a>情况四 apply调用</h3><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 0;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o=&#123;&#125;;</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m.apply(); //0</span><br></pre></td></tr></table></figure></p>
<p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。<br>如果把最后一行代码修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　o.m.apply(o); //1</span><br></pre></td></tr></table></figure></p>
<p>运行结果就变成了1，证明了这时this代表的是对象o。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/js/">js</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this/">this</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-单元测试框架与mock介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/26/单元测试框架与mock介绍/" class="article-date">
      <time datetime="2016-05-26T13:15:32.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/单元测试框架与mock介绍/">单元测试框架与mock介绍*转</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://baidutech.blog.51cto.com/4114344/743740/" target="_blank" rel="external">原文地址</a></p>
<h2 id="单元测试框架的优点与一些问题"><a href="#单元测试框架的优点与一些问题" class="headerlink" title="单元测试框架的优点与一些问题"></a>单元测试框架的优点与一些问题</h2><p>在单元测试中引入单测框架使得编写单测用例时，不需要再关注于如何驱动case的执行，如何收集结果，如何管理case集，只需要关注于如何写好单个测试用例即可；同时，在一些测试框架中通过提供丰富的断言集，公用方法，以及运行参数使得编写单个testcase的过程得到了最大的简化。</p>
<p>那这其中会存在什么样的疑问了？</p>
<p>我在单元测试框架中写一个TestCase，与我单独写一个cpp文件在main()方法里写测试代码有什么本质却别吗？用了单元测试框架，并没有解决我在对复杂系统做单测时遇到的问题。</p>
<p>没错，对于单个case这两者从本质上说是没有区别的。单元测试框架本身并没有告诉你如何去写TestCase，在这一点上他是没有提供任何帮助的。所以对于一些复杂的场景，只用单元测试框架是有点多少显得无能为力的。</p>
<p>使用单元测试框架往往适用于以下场景的测试：单个函数，一个class，或者几个功能相关class的测试，对于纯函数测试，接口级别的测试尤其适用，如房贷计算器公式的测试。</p>
<p>但是，对于一些复杂场景：<br> 被测对象依赖复杂，甚至无法简单new出这个对象<br> 对于一些failure场景的测试<br> 被测对象中涉及多线程合作<br> 被测对象通过消息与外界交互的场景<br> …</p>
<p>单纯依赖单测框架是无法实现单元测试的，而从某种意义上来说，这些场景反而是测试中的重点。</p>
<p>以分布式系统的测试为例，class 与 function级别的单元测试对整个系统的帮助不大，当然，这种单元测试对单个程序的质量有帮助；分布式系统测试的要点是测试进程间的交互：一个进程收到客户请求，该如何处理，然后转发给其他进程；收到响应之后，又修改并应答客户；同时分布式系统测试中通常更关注一些异常路径的测试，这些场景才是测试中的重点，也是难点所在。</p>
<p>Mock方法的引入通常能帮助我们解决以上场景中遇到的难题。</p>
<h2 id="Mock的引入带来了什么"><a href="#Mock的引入带来了什么" class="headerlink" title="Mock的引入带来了什么"></a>Mock的引入带来了什么</h2><p>在维基百科上这样描述Mock：In object-oriented programming, mock objects are simulated objects that mimic the behavior of real objects in controlled ways. A computer programmer typically creates a mock object to test the behavior of some other object, in much the same way that a car designer uses a crash test dummy to simulate the dynamic behavior. of a human in vehicle impacts.</p>
<p>Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。</p>
<p>引入Mock最大的优势在于：Mock的行为固定，它确保当你访问该Mock的某个方法时总是能够获得一个没有任何逻辑的直接就返回的预期结果。</p>
<p>Mock Object的使用通常会带来以下一些好处：</p>
<p> 隔绝其他模块出错引起本模块的测试错误。<br> 隔绝其他模块的开发状态，只要定义好接口，不用管他们开发有没有完成。<br> 一些速度较慢的操作，可以用Mock Object代替，快速返回。<br>对于分布式系统的测试，使用Mock Object会有另外两项很重要的收益：<br> 通过Mock Object可以将一些分布式测试转化为本地的测试<br> 将Mock用于压力测试，可以解决测试集群无法模拟线上集群大规模下的压力</p>
<h2 id="Mock的应用场景"><a href="#Mock的应用场景" class="headerlink" title="Mock的应用场景"></a>Mock的应用场景</h2><p>在使用Mock的过程中，发现Mock是有一些通用性的，对于一些应用场景，是非常适合使用Mock的：</p>
<blockquote>
<p>真实对象具有不可确定的行为(产生不可预测的结果，如股票的行情)<br> 真实对象很难被创建(比如具体的web容器)<br> 真实对象的某些行为很难触发(比如网络错误)<br> 真实情况令程序的运行速度很慢<br> 真实对象有用户界面<br> 测试需要询问真实对象它是如何被调用的(比如测试可能需要验证某个回调函数是否被调用了)<br> 真实对象实际上并不存在(当需要和其他开发小组，或者新的硬件系统打交道的时候，这是一个普遍的问题)<br>当然，也有一些不得不Mock的场景：<br> 一些比较难构造的Object：这类Object通常有很多依赖，在单元测试中构造出这样类通常花费的成本太大。<br> 执行操作的时间较长Object：有一些Object的操作费时，而被测对象依赖于这一个操作的执行结果，例如大文件写操作，数据的更新等等，出于测试的需求，通常将这类操作进行Mock。<br> 异常逻辑：一些异常的逻辑往往在正常测试中是很难触发的，通过Mock可以人为的控制触发异常逻辑。</p>
</blockquote>
<p>在一些压力测试的场景下，也不得不使用Mock，例如在分布式系统测试中，通常需要测试一些单点（如namenode，jobtracker）在压力场景下的工作是否正常。而通常测试集群在正常逻辑下无法提供足够的压力（主要原因是受限于机器数量），这时候就需要应用Mock去满足。</p>
<p>在这些场景下，我们应该如何去做Mock的工作了，一些现有的Mock工具可以帮助我们进行Mock工作。</p>
<h2 id="Mock工具的介绍"><a href="#Mock工具的介绍" class="headerlink" title="Mock工具的介绍"></a>Mock工具的介绍</h2><p>手动的构造 Mock 对象通常带来额外的编码量，而且这些为创建 Mock 对象而编写的代码很有可能引入错误。</p>
<p>目前，有许多开源项目对动态构建 Mock 对象提供了支持，这些项目能够根据现有的接口或类动态生成，这样不仅能避免额外的编码工作，同时也降低了引入错误的可能。</p>
<p>C++: GoogleMock <a href="http://code.google.com/p/googlemock/" target="_blank" rel="external">http://code.google.com/p/googlemock/</a><br>Java: EasyMock <a href="http://easymock.org/" target="_blank" rel="external">http://easymock.org/</a></p>
<p>通常Mock工具通过简单的方法对于给定的接口生成 Mock 对象的类库。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。通过这些Mock工具我们可以方便的构造 Mock 对象从而使单元测试顺利进行，能够应用于更加复杂的测试场景。</p>
<p>以EasyMock为例，通过 EasyMock，我们可以为指定的接口动态的创建 Mock 对象，并利用 Mock 对象来模拟协同模块，从而使单元测试顺利进行。这个过程大致可以划分为以下几个步骤：</p>
<p> 使用 EasyMock 生成 Mock 对象<br> 设定 Mock 对象的预期行为和输出<br> 将 Mock 对象切换到 Replay 状态<br> 调用 Mock 对象方法进行单元测试<br> 对 Mock 对象的行为进行验证</p>
<p>EasyMock的使用和原理： <a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/</a></p>
<p>EasyMock 后台处理的主要原理是利用 java.lang.reflect.Proxy 为指定的接口创建一个动态代理，这个动态代理，就是我们在编码中用到的 Mock 对象。EasyMock 还为这个动态代理提供了一个 InvocationHandler 接口的实现，这个实现类的主要功能就是将动态代理的预期行为记录在某个映射表中和在实际调用时从这个映射表中取出预期输出。</p>
<p>借助类似于EasyMock这样工具，大大降低了编写Mock对象的成本，通常来说Mock工具依赖于单元测试框架，为用户编写TestCase提供便利，但是本身依赖于单元测试框架去驱动，管理case，以及收集测试结果。例如EasyMock依赖于JUint，GoogleMock依赖于Gtest。</p>
<p>那么有了单元测试框架和相应的Mock工具就万事俱备了，还有什么样的问题？正如单元测试框架没有告诉你如何写TestCase一样，Mock工具也没有告诉你如何去选择Mock的点。</p>
<h2 id="如何选择恰当的mock点"><a href="#如何选择恰当的mock点" class="headerlink" title="如何选择恰当的mock点"></a>如何选择恰当的mock点</h2><p>对于Mock这里存在两个误区，1.是Mock的对象越多越好；2.Mock会引入巨大的工作量，通常得不偿失。这都是源于不恰当的Mock点的选取。</p>
<p>这里说的如何选择恰当的mock点，是说对于一个被测对象，我们应当在外围选择恰当的mock对象，以及需要mock的接口。因为对于任意一个对象，任意一段代码逻辑我们都是有办法进行Mock的，而Mock点选择直接决定了我们Mock的工作量以及测试效果。从另外一种意义上来说，不恰当Mock选择反而会对我们的测试产生误导，从而在后期的集成和系统测试中引入更多的问题。</p>
<p>在mock点的选择过程中，以下的一些点会是一些不错的选择</p>
<blockquote>
<p> 网络交互：如果两个被测模块之间是通过网络进行交互的，那么对于网络交互进行Mock通常是比较合适的，如RPC<br> 外部资源：比如文件系统、数据源，如果被测对象对此类外部资源依赖性非常强，而其行为的不可预测性很可能导致测试的随机失败，此类的外部资源也适合进行Mock。<br> UI：因为UI很多时候都是用户行为触发事件，系统本身只是对这些触发事件进行相应，对这类UI做Mock，往往能够实现很好的收益，很多基于关键字驱动的框架都是基于UI进行Mock的<br> 第三方API：当接口属于使用者，通过Mock该接口来确定测试使用者与接口的交互。</p>
</blockquote>
<p>当然如何做Mock一定是与被系统的特性精密关联的，一些强制性的约束和规范是不合适的。这里介绍几个做的比较好的mock的例子。</p>
<ol>
<li>杀毒软件更新部署模块的Mock</li>
</ol>
<p>这个例子源于一款杀毒产品的更新部署模块的测试。对于一个杀毒软件客户端而言，需要通过更新检查模块与病毒库Server进行交互，如果发现病毒库有更新则触发病毒库部署模块的最新病毒库的数据请求和部署工作，要求部署完成后杀毒软件客户端能够正常工作。</p>
<p><img src="/img/191927452.jpg" alt=""></p>
<p>对于这一场景的测试，当时受限于这样一个条件，通常的病毒库server通常最多一天只更新一次病毒库，也就是说如果使用真实的病毒库server，那么针对更新部署模块的测试一天只能被触发一次。这是测试中所不能容忍的，通过对病毒库server进行mock可以解决这个问题。</p>
<p>对于这个场景可以采取这样一种Mock方式：用一个本地文件夹来模拟病毒库server，选择更新部署模块与病毒库server之间交互的两个函数checkVersion()，reqData()函数进行Mock。</p>
<p>checkVersion()工作原先的工作是检查病毒库Server的版本号，以决定是否触发更新，将其行为Mock为检查一个本地文件夹中病毒库的版本号；reqData()原有的行为是从病毒库Server拖取病毒库文件，将其Mock为从本地文件夹中拖取病毒库文件。通过这种方式我们用一个本地文件夹Mock病毒库Server的行为，其带来的产出是：我们可以随意的触发病毒库更新操作以及各种异常。</p>
<p>通过这种方式发现了一个在更新部署过程中，病毒库Server的病毒库版本发生改变造成出错的严重bug，这个是在原有一天才触发一次更新操作的情况下永远也无法发现的。</p>
<ol>
<li>分布式系统中对NameNode模块的测试</li>
</ol>
<p><img src="/img/191936107.jpg" alt=""></p>
<p>在测试NameNode模块的过程中存在这样一个问题，在正常逻辑无压力条件下NameNode模块都是工作正常的。但是线上集群在大压力的情况下，是有可能触发NameNode的问题的。但是原有的测试方法下，我们是无法对NameNode模拟大压力的场景的（因为NameNode的压力主要来源于DateNode数量，而我们测试集群是远远无法达到线上几千台机器的规模的），而NameNode单点的性能瓶颈问题恰恰是测试的重点，真实的DataNode是无法满足测试需求的，我们必须对DataNode进行Mock。</p>
<p><img src="/img/191948572.jpg" alt=""></p>
<p>如何对DateNode进行Mock了，最直观的想法是选择NameNode与DataNode之间的交互接口进行Mock，也就是他们之间的RPC交互，但是由于NameNode与DataNode之间的交互信息种类很多，所以其实这并不是一种很好的选择。<br>换个角度来想，NameNode之上的压力是源于对HDFS的读写操作造成的NameNode上元数据的维护，也就是说，对于NameNode而言，其实他并不关心数据到底写到哪里去了，只关心数据是否读写成功。如果是这种场景Mock就可以变的简单了，我们可以直接将DataNode上对块的操作进行mock，比如，对一次写请求，DataNode并不触发真实的写操作，而直接返回成功。通过这种方式，DataNode去除了执行功能，只保留了消息交互功能，间接的实现了我们的测试需求，且工作量比之第一种方案小很多。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a><a class="article-category-link" href="/categories/技术/网络/">网络</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mock/">mock</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 findmoon
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >外地到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>