<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    分类: 技术
  
</title>

<meta name="description" content="努力、专注、坚信">
<meta property="og:type" content="website">
<meta property="og:title" content="findmoon-白色蜗牛">
<meta property="og:url" content="//findmoon.github.io/index.html/categories/技术/index.html">
<meta property="og:site_name" content="findmoon-白色蜗牛">
<meta property="og:description" content="努力、专注、坚信">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="findmoon-白色蜗牛">
<meta name="twitter:description" content="努力、专注、坚信">




  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">findmoon-白色蜗牛</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">findmoon-白色蜗牛</a></h1>
    
      <p class="subtitle">
        一个试图专注于自身的成长者
      </p>
    
    <div class="info">
      <div class="content">
        
          <div class="description">努力、专注、坚信</div>
        
        
          <div class="author">findmoon</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="http://i2.piimg.com/81760750547ee122.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">132</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/方法-实例/">方法/实例</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">10</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFC/">BFC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backbone/">Backbone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3动画/">CSS3动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS解析域名/">DNS解析域名</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOCTYPE/">DOCTYPE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MV模式/">MV模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mocha/">Mocha</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP三次握手/">TCP三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNICODE-ASCII/">UNICODE/ASCII</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate/">animate()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate动画队列/">animate动画队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/background-image/">background-image</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border/">border</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border图形/">border图形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/box-shadow/">box-shadow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console-log/">console.log()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css属性/">css属性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css样式/">css样式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deferred/">deferred</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/delete/">delete</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-child/">first-child</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-of-type/">first-of-type</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/float/">float</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font-face/">font-face</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/form表单/">form表单</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/get/">get</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitbash/">gitbash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git错误/">git错误</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haslayout/">haslayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http状态码/">http状态码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inline-block/">inline-block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/input/">input</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/">instanceof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof-typeof/">instanceof/typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js严格模式/">js严格模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js加载/">js加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js模板引擎/">js模板引擎</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list-style/">list-style</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meta/">meta</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offset/">offset()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overflow/">overflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/placeholder/">placeholder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position/">position</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position文档流/">position文档流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/post/">post</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scopechain/">scopechain</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stringify/">stringify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/">typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/undefined/">undefined</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/url加载/">url加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zoom/">zoom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码书写/">代码书写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列表/">列表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画animation/">动画animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量/">变量</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同源跨域/">同源跨域</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字面量/">字面量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/库与架构/">库与架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学函数/">数学函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据包组装/">数据包组装</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法/">方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记语言/">标记语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化编程/">模块化编程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/立即执行函数/">立即执行函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站访问/">网站访问</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/获取路径/">获取路径</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行内元素/">行内元素</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求/">跨域请求</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求处理方法/">跨域请求处理方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择器/">选择器</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">161</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
            
              <li>
                <a href="/work" title="work">work</a>
              </li>
            
          
            
              <li>
                <a href="/about" title="about">about</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="http://findmoon.github.io/" title="findmoon" target="_blank" rel="external">findmoon</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/findmoon/findmoon.github.io" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <h1>技术</h1>


  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/14/跨域资源共享 CORS 详解/" >
  阮一峰的网络日志*跨域资源共享 CORS 详解
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/14/跨域资源共享 CORS 详解/"><span class="article-date">
  2016-06-14
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/http/">http</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同源跨域/">同源跨域</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">阮一峰的网络日志*跨域资源共享 CORS 详解</a></p>
<ul>
<li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</li>
</ul>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<ul>
<li>（1) 请求方法是以下三种方法之一：</li>
</ul>
<blockquote>
<p>HEAD<br>GET<br>POST</p>
</blockquote>
<ul>
<li>（2）HTTP的头信息不超出以下几种字段：</li>
</ul>
<blockquote>
<p>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
</blockquote>
<ul>
<li>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</li>
</ul>
<h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p>
<ul>
<li>（1）Access-Control-Allow-Origin</li>
</ul>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<ul>
<li>（2）Access-Control-Allow-Credentials</li>
</ul>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<ul>
<li>（3）Access-Control-Expose-Headers</li>
</ul>
<p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>
<h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<blockquote>
<p>Access-Control-Allow-Credentials: true</p>
</blockquote>
<p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();<br>xhr.withCredentials = true;</p>
</blockquote>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<blockquote>
<p>xhr.withCredentials = false;</p>
</blockquote>
<ul>
<li>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</li>
</ul>
<h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>下面是一段浏览器的JavaScript脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ul>
<li>（1）Access-Control-Request-Method</li>
</ul>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>
<ul>
<li>（2）Access-Control-Request-Headers</li>
</ul>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>
<h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="external">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p>
<blockquote>
<p>Access-Control-Allow-Origin: *</p>
</blockquote>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>
<p>服务器回应的其他CORS相关字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
<ul>
<li>（1）Access-Control-Allow-Methods</li>
</ul>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<ul>
<li>（2）Access-Control-Allow-Headers</li>
</ul>
<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<ul>
<li>（3）Access-Control-Allow-Credentials</li>
</ul>
<p>该字段与简单请求时的含义相同。</p>
<ul>
<li>（4）Access-Control-Max-Age</li>
</ul>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。<br>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>上面头信息的Origin字段是浏览器自动添加的。<br>下面是服务器正常的回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>
<h3 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<ul>
<li>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
</ul>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/14/同源策略和跨域资源请求(二)/" >
  同源策略和跨域资源请求(二)
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/14/同源策略和跨域资源请求(二)/"><span class="article-date">
  2016-06-14
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/http/">http</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同源跨域/">同源跨域</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>jsonp与json没有关系</p>
<p>jsonp：json with padding，打包在函数调用中的 JSON 数据</p>
<p>jsonp实现跨域请求的原理：</p>
<blockquote>
<p>1、a.com可以引用b.com的js文件<br>2、在b.com的js文件中存放数据，这样就像是可以跨域请求一样</p>
</blockquote>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/13/关于js中(function(){…})()立即执行函数/" >
  关于js中(function(){…})()立即执行函数
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/13/关于js中(function(){…})()立即执行函数/"><span class="article-date">
  2016-06-13
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/立即执行函数/">立即执行函数</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>关于js中(function(){…})()立即执行函数</p>
<p>js中的函数有一些基本概念：函数声明、函数表达式、匿名函数</p>
<ul>
<li><p>函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。</p>
</li>
<li><p>函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</p>
</li>
<li><p>匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p>
</li>
</ul>
<p>函数声明和函数表达式不同之处在于:</p>
<ul>
<li>一、Javascript引擎在解析javascript代码时,函数声明会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式，</li>
<li>二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fnName();</span><br><span class="line">function fnName()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;//正常，因为‘提升’了函数声明，函数调用可在函数声明之前</span><br><span class="line"> </span><br><span class="line">fnName();</span><br><span class="line">var fnName=function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后</span><br><span class="line"></span><br><span class="line">var fnName=function()&#123;</span><br><span class="line">    alert(&apos;Hello World&apos;);</span><br><span class="line">&#125;();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数</span><br><span class="line"></span><br><span class="line">function fnName()&#123;</span><br><span class="line">    alert(&apos;Hello World&apos;);</span><br><span class="line">&#125;();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用</span><br><span class="line"></span><br><span class="line">function()&#123;</span><br><span class="line">    console.log(&apos;Hello World&apos;);    </span><br><span class="line">&#125;();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，</span><br><span class="line">//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名</span><br></pre></td></tr></table></figure>
<p>了解了函数声明和函数表达式,接下来看看( function(){…} )()和( function (){…} () )这两种形式的立即执行函数。这种形式的函数之所以可以立即执行，是因为()前面的函数体在一个()运算符之内构成了一个函数表达式，也就是在一个函数表达式后面加一个()就可以变成立即执行函数，()前不能是函数声明。</p>
<blockquote>
<p>表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。约束变量在表达式中已被指定数值，而自由变量则可以在表达式之外另行指定数值。一个表达式代表一个函数，其输入为自由变量的定值，而其输出则为表达式因之后所产生出的数值。 ——维基百科</p>
</blockquote>
<p>这两种形式的运用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出123,使用（）运算符</span><br><span class="line">&#125;)(123);</span><br><span class="line"> </span><br><span class="line">(function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出1234，使用（）运算符</span><br><span class="line">&#125;(1234));</span><br><span class="line"> </span><br><span class="line">!function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出12345,使用！运算符</span><br><span class="line">&#125;(12345);</span><br><span class="line"> </span><br><span class="line">+function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出123456,使用+运算符</span><br><span class="line">&#125;(123456);</span><br><span class="line"> </span><br><span class="line">-function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出1234567,使用-运算符</span><br><span class="line">&#125;(1234567);</span><br><span class="line"> </span><br><span class="line">var fn=function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出12345678，使用=运算符</span><br><span class="line">&#125;(12345678)</span><br></pre></td></tr></table></figure></p>
<p>可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p>
<p>加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</p>
<p><strong>这样的写法可以形成一个独立的作用域？</strong></p>
<p>javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p>
<p>JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…})(window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。</p>
<p>原文参考地址：<a href="http://my.oschina.net/u/2331760/blog/468672?p=" target="_blank" rel="external">http://my.oschina.net/u/2331760/blog/468672?p=</a></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/13/同源策略和跨域/" >
  同源策略和跨域资源请求(一)
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/13/同源策略和跨域/"><span class="article-date">
  2016-06-13
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/http/">http</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同源跨域/">同源跨域</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h3 id="同源策略和跨域资源请求"><a href="#同源策略和跨域资源请求" class="headerlink" title="同源策略和跨域资源请求"></a>同源策略和跨域资源请求</h3><p>url:uniform resource lacator，统一资源定位符，俗称网址</p>
<ul>
<li>http默认端口：80</li>
<li>https默认端口：443<br>（协议默认加上端口）</li>
</ul>
<pre><code>http://user:pass@www.example.jp:80/dir/index.html?uid=1#chl

(http协议方案名，还有https)（user:pass登录信息[认证]，几乎已经不使用）（www.example.jp，服务器地址）（:80，服务器端口号）（/dir/index.html，带层次的文件路径）（?uid=1，查询字符串，键值对的方式）（#chl，片段标示符，#后面为哈希）
</code></pre><ul>
<li>#片段标示符一般为页面内跳转，在a上设置锚点，不刷新页面。对serve来说没有效果，不会传递到服务器，文档内定位。#后面为hash，哈希</li>
</ul>
<p>查看源origin：location.origin查看完整的源，输出域名、协议、端口号。</p>
<ul>
<li>location.origin:IE下不支持这个属性，所以所以可以写成：if(location.origin===undefined){ location.protocol+location.hostname+location.port},这样就可以兼容ie</li>
</ul>
<h2 id="同源策略-same-origin-policy"><a href="#同源策略-same-origin-policy" class="headerlink" title="同源策略(same-origin policy)"></a>同源策略(same-origin policy)</h2><p>同源策略是浏览器的一个功能，<strong>同源就是协议：域名、端口号完全一致</strong></p>
<p>不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源</p>
<p>通过配置hosts文件，可配置本地服务器对应的域名：<br>C:\Windows\System32\drivers\etc\hosts</p>
<p><img src="/img/同源策略/5425134515.png" alt=""></p>
<ul>
<li>如图可以设置本地访问的域名为www.baidu.com,这样浏览器访问baidu.com时就会跳转到本地（本地服务器打开）</li>
</ul>
<blockquote>
<p>http协议的默认端口是80，默认情况下，80端口只有系统管理员才可以监听，mac下系统管理员身份是sudo命令，window下以管理员身份启动命令行</p>
</blockquote>
<h2 id="什么不是同源策略"><a href="#什么不是同源策略" class="headerlink" title="什么不是同源策略"></a>什么不是同源策略</h2><p>a.com/index.html<br>可以引用b.com/main.js或b.com/style.css/b.com/logo.png</p>
<p>但是a.com里面的b.com/main.js不能对b.com的资源进行读写（ajax报错）</p>
<ul>
<li>比如对于一个使用ajax求情数据获取更多内容的操作，可以在本地搭建配置，查看浏览器对不同源策略的限制。</li>
</ul>
<p>1、 设置并开启本地服务器,修改hosts文件，模拟两个不同的域名a.com和b.com：</p>
<p><img src="/img/同源策略/0624165617.png" alt=""></p>
<p>2、使用jQuery的ajax请求，url地址为：’/getmore’,当前目录下请求<br>初始状态有两个内容条，每次点击加载更多，获取六条内容，并添加到dom,本地服务器开启使用8080端口，浏览器输入<a href="http://a.com:8080/jQajax.html，点击可以实现ajax请求：" target="_blank" rel="external">http://a.com:8080/jQajax.html，点击可以实现ajax请求：</a></p>
<p><img src="/img/同源策略/60624173249.png" alt=""></p>
<p>3、修改ajax的url请求地址为url: ‘//b.com:8080/getmore’<br>点击加载浏览器控制台报错，跨域请求不支持</p>
<blockquote>
<p>jQajax.html:1 XMLHttpRequest cannot load <a href="http://b.com:8080/getmore?start=3&amp;len=6" target="_blank" rel="external">http://b.com:8080/getmore?start=3&amp;len=6</a>. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://a.com:8080" target="_blank" rel="external">http://a.com:8080</a>‘ is therefore not allowed access.</p>
</blockquote>
<p>这是一个跨域请求典型的例子，解决跨域请求一共以下几种方法</p>
<blockquote>
<p>降域<br>JSONP<br>Cross-origin resource sharing（CORS，跨域资源共享）<br>HTML5 postMessage<br>其他hack：利用hash；利用windo.name</p>
</blockquote>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/13/JavaScript跨域总结与解决办法/" >
  JavaScript跨域总结与解决办法*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/13/JavaScript跨域总结与解决办法/"><span class="article-date">
  2016-06-13
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/http/">http</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同源跨域/">同源跨域</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>JavaScript跨域总结与解决办法<br><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m1" target="_blank" rel="external">原文地址</a></p>
<p>解决跨域问题的几种方式：<br>1、document.domain+iframe的设置<br>2、动态创建script<br>3、利用iframe和location.hash<br>4、window.name实现的跨域数据传输<br>5、使用HTML5 postMessage<br>6、利用flash</p>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><ul>
<li><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：</p>
</li>
<li><p>首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表：</p>
</li>
</ul>
<blockquote>
<p>特别注意两点：</p>
<p>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，</p>
<p>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</p>
</blockquote>
<p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。</p>
<p>接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》</p>
<h3 id="1、document-domain-iframe的设置"><a href="#1、document-domain-iframe的设置" class="headerlink" title="1、document.domain+iframe的设置"></a>1、document.domain+iframe的设置</h3><p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。</p>
<p>具体的做法是可以在<a href="http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain" target="_blank" rel="external">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain</a> = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！</p>
<p>代码如下：</p>
<ul>
<li>www.a.com上的a.html</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.domain = &apos;a.com&apos;;</span><br><span class="line">var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">ifr.src = &apos;http://script.a.com/b.html&apos;;</span><br><span class="line">ifr.style.display = &apos;none&apos;;</span><br><span class="line">document.body.appendChild(ifr);</span><br><span class="line">ifr.onload = function()&#123;</span><br><span class="line">    var doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    // 在这里操纵b.html</span><br><span class="line">    alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>script.a.com上的b.html</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = &apos;a.com&apos;;</span><br></pre></td></tr></table></figure>
<p>这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。</p>
<blockquote>
<p>备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。</p>
</blockquote>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。</p>
<p>2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</p>
<h2 id="2、动态创建script"><a href="#2、动态创建script" class="headerlink" title="2、动态创建script"></a>2、动态创建script</h2><p>虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility</p>
<p>这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js.onload = js.onreadystatechange = function() &#123;</span><br><span class="line">    if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) &#123;</span><br><span class="line">        // callback在此处执行</span><br><span class="line">        js.onload = js.onreadystatechange = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、利用iframe和location-hash"><a href="#3、利用iframe和location-hash" class="headerlink" title="3、利用iframe和location.hash"></a>3、利用iframe和location.hash</h3><p>这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： <a href="http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。" target="_blank" rel="external">http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。</a></p>
<p>cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下：</p>
<p>先是a.com下的文件cs1.html文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function startRequest()&#123;</span><br><span class="line">    var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    ifr.style.display = &apos;none&apos;;</span><br><span class="line">    ifr.src = &apos;http://www.cnblogs.com/lab/cscript/cs2.html#paramdo&apos;;</span><br><span class="line">    document.body.appendChild(ifr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function checkHash() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var data = location.hash ? location.hash.substring(1) : &apos;&apos;;</span><br><span class="line">        if (console.log) &#123;</span><br><span class="line">            console.log(&apos;Now the data is &apos;+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(checkHash, 2000);</span><br></pre></td></tr></table></figure>
<p>cnblogs.com域名下的cs2.html:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//模拟一个简单的参数处理操作</span><br><span class="line">switch(location.hash)&#123;</span><br><span class="line">    case &apos;#paramdo&apos;:</span><br><span class="line">        callBack();</span><br><span class="line">        break;</span><br><span class="line">    case &apos;#paramset&apos;:</span><br><span class="line">        //do something……</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callBack()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        parent.location.hash = &apos;somedata&apos;;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        // ie、chrome的安全机制无法修改parent.location.hash，</span><br><span class="line">        // 所以要利用一个中间的cnblogs域下的代理iframe</span><br><span class="line">        var ifrproxy = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        ifrproxy.style.display = &apos;none&apos;;</span><br><span class="line">        ifrproxy.src = &apos;http://a.com/test/cscript/cs3.html#somedata&apos;;    // 注意该文件在&quot;a.com&quot;域下</span><br><span class="line">        document.body.appendChild(ifrproxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a.com下的域名cs3.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(1);</span><br></pre></td></tr></table></figure>
<p>当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……</p>
<h2 id="4、window-name实现的跨域数据传输"><a href="#4、window-name实现的跨域数据传输" class="headerlink" title="4、window.name实现的跨域数据传输"></a>4、window.name实现的跨域数据传输</h2><p>文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输。</p>
<h2 id="5、使用HTML5-postMessage"><a href="#5、使用HTML5-postMessage" class="headerlink" title="5、使用HTML5 postMessage"></a>5、使用HTML5 postMessage</h2><p>HTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。</p>
<ol>
<li>otherWindow.postMessage(message, targetOrigin);</li>
<li>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性;</li>
<li>window.open的返回值；通过name或下标从window.frames取到的值。</li>
<li>message: 所要发送的数据，string类型。</li>
<li>targetOrigin: 用于限制otherWindow，“*”表示不作限制</li>
</ol>
<p>a.com/index.html中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    var ifr = document.getElementById(&apos;ifr&apos;);</span><br><span class="line">    var targetOrigin = &apos;http://b.com&apos;;  // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样</span><br><span class="line">                                        // 若写成&apos;http://c.com&apos;就不会执行postMessage了</span><br><span class="line">    ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>b.com/index.html中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(event)&#123;</span><br><span class="line">        // 通过origin属性判断消息来源地址</span><br><span class="line">        if (event.origin == &apos;http://a.com&apos;) &#123;</span><br><span class="line">            alert(event.data);    // 弹出&quot;I was there!&quot;</span><br><span class="line">            alert(event.source);  // 对a.com、index.html中window对象的引用</span><br><span class="line">                                  // 但由于同源策略，这里event.source不可以访问window对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>参考文章：《精通HTML5编程》第五章——跨文档消息机制、<a href="https://developer.mozilla.org/en/dom/window.postmessage" target="_blank" rel="external">https://developer.mozilla.org/en/dom/window.postmessage</a></p>
<h2 id="6、利用flash"><a href="#6、利用flash" class="headerlink" title="6、利用flash"></a>6、利用flash</h2><p>这是从YUI3的IO组件中看到的办法，具体可见<a href="http://developer.yahoo.com/yui/3/io/。" target="_blank" rel="external">http://developer.yahoo.com/yui/3/io/。</a><br>可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/10/stopImmediatePropagation介绍/" >
  stopImmediatePropagation介绍*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/10/stopImmediatePropagation介绍/"><span class="article-date">
  2016-06-10
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>stopImmediatePropagation介绍</p>
<p><a href="http://www.cnblogs.com/zzbo/p/3366264.html" target="_blank" rel="external">原文地址</a></p>
<p>在众多的方法里面，event.stopImmediatePropagation 算是比较少用的一个方法，拼写上感觉一半像 event.stopPropagation。</p>
<p>对于stopPropagation 的用法大家是众所周知的，他是W3C标准事件方法，用于阻止事件冒泡（非标准情况下，用window.event.stopBubble来阻止冒泡）</p>
<p>而stopImmediatePropagation 的功能比stopPropagation 多一些，除了可以阻止事件冒泡之外，还可以把这个元素绑定的同类型事件也阻止了。</p>
<p>先把下面的代码片断（摘自MDN）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            p &#123; height: 30px; width: 150px; background-color: #ccf; &#125;</span><br><span class="line">            div &#123;height: 30px; width: 150px; background-color: #cfc; &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;paragraph&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是p元素上被绑定的第一个监听函数&quot;);</span><br><span class="line">            &#125;, false);</span><br><span class="line">            document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是p元素上被绑定的第二个监听函数&quot;);</span><br><span class="line">                event.stopImmediatePropagation();</span><br><span class="line">                //执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.</span><br><span class="line">            &#125;, false);</span><br><span class="line">            document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是p元素上被绑定的第三个监听函数&quot;);</span><br><span class="line">                //该监听函数排在上个函数后面,该函数不会被执行.</span><br><span class="line">            &#125;, false);</span><br><span class="line">            document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是div元素,我是p元素的上层元素&quot;);</span><br><span class="line">                //p元素的click事件没有向上冒泡,该函数不会被执行.</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>p标签绑定了三个click事件，div绑定了一个click事件。</p>
<ul>
<li>其中p第二个click事件中使用了event.stopImmediatePropagation();</li>
</ul>
<blockquote>
<p>当点击时P标签时，第一和第二个alert会正常出现，<br>第三个alert被event.stopImmediatePropagation();的特性取消了以后的同类型(click)事件<br>第四个alert不出来同被阻止了事件冒泡，所以也不会出现。<br>相当于做了event.stopPropagation()后，再return false;  jQuery对事件代理做了类似的封装。</p>
</blockquote>
<p>我们了解特性之后，看一个简单应用场景:</p>
<p>假设点击一个按钮后，需要检测两个input控件的值，值为空时打印’error’，并停止检测下一个input，同时也需停止提单提交。<br>我们通常可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;txt1&quot;&gt;</span><br><span class="line">　　　　 &lt;input type=&quot;text&quot; id=&quot;txt2&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;button&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var txt1 = document.querySelector(&quot;#txt1&quot;);</span><br><span class="line">　　　　　　　var txt2 = document.querySelector(&quot;#txt2&quot;);</span><br><span class="line">            var btn = document.querySelector(&quot;#btn&quot;);</span><br><span class="line">            btn.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">                if (txt1.value == &apos;&apos;) &#123;</span><br><span class="line">                    alert(&apos;error1&apos;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">　　　　　　　　　 if (txt2.value == &apos;&apos;) &#123; </span><br><span class="line">                    alert(&apos;error2&apos;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>但用了event.stopImmediatePropagation时，可以对代码进行更好的抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;txt1&quot;&gt;</span><br><span class="line">　　　　 &lt;input type=&quot;text&quot; id=&quot;txt2&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;button&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var txt1 = document.querySelector(&quot;#txt1&quot;);</span><br><span class="line">　　　　　　var txt2 = document.querySelector(&quot;#txt2&quot;);</span><br><span class="line">            var btn = document.querySelector(&quot;#btn&quot;);</span><br><span class="line"></span><br><span class="line">            btn.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">                if (txt1.value == &apos;&apos;) &#123;</span><br><span class="line">                    alert(&apos;error1&apos;);</span><br><span class="line">                    event.stopImmediatePropagation();</span><br><span class="line">                &#125;</span><br><span class="line">　　　　　　　　if (txt2.value == &apos;&apos;) &#123; </span><br><span class="line">                    alert(&apos;error2&apos;);</span><br><span class="line">                    event.stopImmediatePropagation();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;, false);</span><br><span class="line">　　　　　　</span><br><span class="line">            btn.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">                 alert(&apos;Done&apos;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>题外：<br>event.isImmediatePropagationStopped 可以用来确定该元素是否有调用过event.stopImmediatePropagation。</p>
<p>浏览器支持情况：<br>Firefox &gt;=10Chrome<br>IE &gt;= 9<br>Opera<br>Safari</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/09/jQuery动画animate()方法小介绍介绍/" >
  jQuery动画animate()方法小介绍介绍
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/09/jQuery动画animate()方法小介绍介绍/"><span class="article-date">
  2016-06-09
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animate/">animate()</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>.animate()是jQuery实现动画的一种方法，它接受一个必选参数(properties,动画所要改变的属性)，和三个可选参数[, duration ] [, easing ] [, complete ] 。</p>
<ul>
<li>[, duration ] 字符串或者数字决定动画将运行多久,默认: 400。</li>
<li>[, easing ]一个字符串，表示过渡使用哪种缓动函数,jQuery自身提供”linear” 和 “swing”,默认: swing</li>
<li>[, complete ]  Function()在动画完成时执行的函数。</li>
</ul>
<p>Function()函数是一个很重要的参数方法<br>看如下jQuery操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;div&apos;).animate(&#123;height: 0&#125;,500).hide();</span><br></pre></td></tr></table></figure>
<p>div原来宽高是300px和400px，想要实现的功能是让div的高度变为0，然后再隐藏，这里采用jQuery的链式写法。但实际效果是div元素直接消失，也就是直接hide().原因是height的变化有一个持续500毫秒的时间，在这个动画执行时就已经执行.hide()隐藏。所以看不到效果。</p>
<p>要想看到效果就必须把hide()放到动画完成后，所以可以这样改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;div&apos;).animate(&#123;height: 0&#125;,500,function()&#123;</span><br><span class="line">		$(&apos;div&apos;).hide();</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>这样隐藏操作就会在动画完成后执行。<br><strong>这个操作在需要动画完成后进行一些列方法调用的时候用很大的用处</strong></p>
<p>更具体的使用可以参看这个中文文档：<a href="http://www.css88.com/jqapi-1.9/animate/" target="_blank" rel="external">http://www.css88.com/jqapi-1.9/animate/</a></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/06/字面量简介/" >
  字面量简介
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/06/字面量简介/"><span class="article-date">
  2016-06-06
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字面量/">字面量</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <ul>
<li>字面量简介：</li>
</ul>
<p>在计算机科学中，字面量(literal)是用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如:整数、浮点数以及字符串;而有很多也对布尔类型和字符类型的值也支持字面量表示;还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</p>
<p>在编程语言中，字面量是一种表示值的记法。例如，”Hello, World!” 在许多语言中都表示一个字符串字面量（string literal ），JavaScript也不例外。以下也是JavaScript字面量的例子，如5、true、false和null，它们分别表示一个整数、两个布尔值和一个空对象。</p>
<ul>
<li>JavaScript还支持对象和数组字面量，允许使用一种简洁而可读的记法来创建数组和对象。考虑以下语句，其中创建了一个包含两个属性的对象（firstName和lastName）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">o.name = &apos;Byron&apos;;</span><br><span class="line">o.age = 24;</span><br></pre></td></tr></table></figure>
<p>上面是创建对象的方法，可以使用下面字面量的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Byron&apos;,</span><br><span class="line">    age:24</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上赋值语句的右边是一个对象字面量（object literal）。对象字面量是一个名值对列表，每个名值对之间用逗号分隔，并用一个大括号括起。各名值对表示对象的一个属性，名和值这两部分之间用一个冒号分隔。要创建一个数组，可以创建Array对象的一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a=new Array();</span><br><span class="line">a.push(1,2,3);</span><br></pre></td></tr></table></figure>
<p>不过首选的方法是使用一个数组字面量（array literal），这是一个用逗号分隔的值列表，用中括号括起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br></pre></td></tr></table></figure>
<ul>
<li>函数字面量（function literal）如下构造：前面是一个function关键字，后面是一个函数名（可选）和参数表。然后是函数体，包围在大括号中。</li>
</ul>
<p>赋给team变量的对象有3个属性：name、members和count</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var team = &#123;</span><br><span class="line">	name: &apos;hard&apos;,</span><br><span class="line">	work: &apos;learn&apos;,</span><br><span class="line">	sum: function()&#123; return 1+2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript对象记法（JavaScript Object Notation，JSON），这是一种用于描述文件和数组的记法，由JavaScript字面量的一个子集组成。JSON在Ajax开发人员中越来越流行，因为这种格式可以用于交换数据，通常取代了XML。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">对象字面量：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //只能添加静态属性和方法</span><br><span class="line">   var myObject=&#123;</span><br><span class="line">     propertyA: sha ,</span><br><span class="line">     propertyB: feng ,</span><br><span class="line">     methodA:function()&#123;</span><br><span class="line">      alert(this.propertyA++this.propertyB);</span><br><span class="line">     &#125;,</span><br><span class="line">     methodB:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    myObject.methodA();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //利用prototype属性可以添加公有属性和方法</span><br><span class="line">   </span><br><span class="line">   function myConstructor2()&#123;&#125;;  //声明构造函数，可以使用对象字面量语法来向prototype属性中添加所有公有成员</span><br><span class="line">   </span><br><span class="line">    myConstructor2.prototype=&#123;</span><br><span class="line">     propertyA: sha ,</span><br><span class="line">     propertyB: feng ,</span><br><span class="line">     methodA:function()&#123;</span><br><span class="line">      alert(this.propertyA++this.propertyB);</span><br><span class="line">     &#125;,</span><br><span class="line">     methodB:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   var myconstrustor=new myConstructor2(); //声明对象</span><br><span class="line">    myconstrustor.methodA();</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/yxf2011/archive/2012/04/01/2428225.html" target="_blank" rel="external">参考链接</a></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/05/JavaSript模块规范-AMD规范与CMD规范介绍/" >
  JavaSript模块规范-AMD规范与CMD规范介绍*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/05/JavaSript模块规范-AMD规范与CMD规范介绍/"><span class="article-date">
  2016-06-05
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/jQuery/">jQuery</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deferred/">deferred</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.cnblogs.com/dojo-lzz/p/4707725.html" target="_blank" rel="external">另一篇参考博客地址</a></p>
<p><a href="http://blog.chinaunix.net/uid-26672038-id-4112229.html" target="_blank" rel="external">JavaSript模块规范 - AMD规范与CMD规范介绍</a> </p>
<p>JavaSript模块化</p>
<p>在了解AMD，CMD规范前，还是需要先来简单地了解下什么是模块化，模块化开发？</p>
<p>模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。</p>
<p>还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。</p>
<p>首先，既然是模块化设计，那么作为一个模块化系统所必须的能力：</p>
<blockquote>
<ol>
<li>定义封装的模块。</li>
<li>定义新模块对其他模块的依赖。</li>
<li>可对其他模块的引入支持。</li>
</ol>
</blockquote>
<p>好了，思想有了，那么总要有点什么来建立一个模块化的规范制度吧，不然各式各样的模块加载方式只会将局搅得更为混乱。那么在JavaScript中出现了一些非传统模块开发方式的规范 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。</p>
<h2 id="AMD-与-RequireJS"><a href="#AMD-与-RequireJS" class="headerlink" title="AMD 与 RequireJS"></a>AMD 与 RequireJS</h2><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>Asynchronous Module Definition，用白话文讲就是 异步模块定义，对于 JSer 来说，异步是再也熟悉不过的词了，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<p>AMD规范定义了一个自由变量或者说是全局变量 define 的函数。</p>
<p>define( id?, dependencies?, factory ); </p>
<p>AMD规范  <a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki/AMD</a></p>
<blockquote>
<p>第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。</p>
<p>第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。</p>
<p>第三个参数，factory，是一个需要进行实例化的函数或者一个对象。</p>
</blockquote>
<ul>
<li>创建模块标识为 alpha 的模块，依赖于 require， export，和标识为 beta 的模块 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(&quot;alpha&quot;, [ &quot;require&quot;, &quot;exports&quot;, &quot;beta&quot; ], function( require, exports, beta )&#123;</span><br><span class="line">    export.verb = function()&#123;</span><br><span class="line">        return beta.verb();</span><br><span class="line">        // or:</span><br><span class="line">        return require(&quot;beta&quot;).verb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>一个返回对象字面量的异步模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([&quot;alpha&quot;], function( alpha )&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        verb : function()&#123;</span><br><span class="line">            return alpha.verb() + 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>无依赖模块可以直接使用对象字面量来定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( &#123;</span><br><span class="line">    add : function( x, y )&#123;</span><br><span class="line">        return x + y ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li>类似与 CommonJS 方式定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define( function( require, exports, module)&#123;</span><br><span class="line">    var a = require(&apos;a&apos;),</span><br><span class="line">          b = require(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">    exports.action = function()&#123;&#125;;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="require"><a href="#require" class="headerlink" title="require();"></a>require();</h3><p>require API 介绍 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki/require</a></p>
<p> 在 AMD 规范中的 require 函数与一般的 CommonJS中的 require 不同。由于动态检测依赖关系使加载异步，对于基于回调的 require 需求强烈。</p>
<h4 id="局部-与-全局-的require"><a href="#局部-与-全局-的require" class="headerlink" title="局部 与 全局 的require"></a>局部 与 全局 的require</h4><pre><code>局部的 require 需要在AMD模式中的 define 工厂函数中传入 require。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define( [&apos;require&apos;], function( require )&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125; );</span><br><span class="line">or：</span><br><span class="line">define( function( require, exports, module )&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>局部的 require 需要其他特定的 API 来实现。</p>
<p> 全局的 require 函数是唯一全局作用域下的变量，像 define一样。全局的 require 并不是规范要求的，但是如果实现全局的 require函数，那么其需要具有与局部 require 函数 一样的以下的限定：</p>
<blockquote>
<ol>
<li>模块标识视为绝对的，而不是相对的对应另一个模块标识。</li>
<li>只有在异步情况下，require的回调方式才被用来作为交互操作使用。因为他不可能在同步的情况下通过 require(String) 从顶层加载模块。</li>
</ol>
</blockquote>
<p>依赖相关的API会开始模块加载。如果需要有互操作的多个加载器，那么全局的 reqiure 应该被加载顶层模块来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">require(String)</span><br><span class="line">define( function( require )&#123;</span><br><span class="line">    var a = require(&apos;a&apos;); // 加载模块a</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">require(Array, Function)</span><br><span class="line">define( function( require )&#123;</span><br><span class="line">    require( [&apos;a&apos;, &apos;b&apos;], function( a,b )&#123; // 加载模块a b 使用</span><br><span class="line">        // 依赖 a b 模块的运行代码</span><br><span class="line">    &#125; ); </span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">require.toUrl( Url )</span><br><span class="line">define( function( require )&#123;</span><br><span class="line">    var temp = require.toUrl(&apos;./temp/a.html&apos;); // 加载页面</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>amdjs 的API   <a href="https://github.com/amdjs/amdjs-api/wiki" target="_blank" rel="external">https://github.com/amdjs/amdjs-api/wiki</a></p>
<h3 id="RequireJS"><a href="#RequireJS" class="headerlink" title="RequireJS"></a>RequireJS</h3><p>官网 <a href="http://www.requirejs.org/" target="_blank" rel="external">http://www.requirejs.org/</a> API <a href="http://www.requirejs.org/docs/api.html" target="_blank" rel="external">http://www.requirejs.org/docs/api.html</a></p>
<p> RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范，它的作者就是AMD规范的创始人 James Burke。所以说RequireJS是对AMD规范的阐述一点也不为过。</p>
<p> RequireJS 的基本思想为：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script data-main=&apos;scripts/main&apos; src=&apos;scripts/require.js&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>那么scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。</p>
<p>defined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。</p>
<ul>
<li><ol>
<li>独立模块，不依赖其他模块。直接定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    method1: function()&#123;&#125;,</span><br><span class="line">    method2: function()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>也等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        method1: function()&#123;&#125;,</span><br><span class="line">        method2: function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>非独立模块，对其他模块有依赖。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([ &apos;module1&apos;, &apos;module2&apos; ], function(m1, m2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( function( require )&#123;</span><br><span class="line">    var m1 = require( &apos;module1&apos; ),</span><br><span class="line">          m2 = require( &apos;module2&apos; );</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>简单看了一下RequireJS的实现方式，其 require 实现只不过是将 function 字符串然后提取 require 之后的模块名，将其放入依赖关系之中。</p>
<h3 id="require方法调用模块"><a href="#require方法调用模块" class="headerlink" title="require方法调用模块"></a>require方法调用模块</h3><pre><code>在require进行调用模块时，其参数与define类似。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require( [&apos;foo&apos;, &apos;bar&apos;], function( foo, bar )&#123;</span><br><span class="line">    foo.func();</span><br><span class="line">    bar.func();</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<pre><code>在加载 foo 与 bar 两个模块之后执行回调函数实现具体过程。

当然还可以如之前的例子中的，在define定义模块内部进行require调用模块
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( function( require )&#123;</span><br><span class="line">    var m1 = require( &apos;module1&apos; ),</span><br><span class="line">          m2 = require( &apos;module2&apos; );</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<pre><code>define 和 require 这两个定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。
</code></pre><h2 id="CMD-与-seaJS"><a href="#CMD-与-seaJS" class="headerlink" title="CMD 与 seaJS"></a>CMD 与 seaJS</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>在CMD中，一个模块就是一个文件，格式为：<br><strong> define( factory );</strong></p>
<p>全局函数define，用来定义模块。</p>
<p>参数 factory  可以是一个函数，也可以为对象或者字符串。</p>
<p>当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。</p>
<p>定义JSON数据模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123; &quot;foo&quot;: &quot;bar&quot; &#125;);</span><br></pre></td></tr></table></figure>
<p>通过字符串定义模板模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;this is &#123;&#123;data&#125;&#125;.&apos;);</span><br></pre></td></tr></table></figure>
<p>factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define( function(require, exports, module) &#123; </span><br><span class="line">    // 模块代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="define-id-deps-factory"><a href="#define-id-deps-factory" class="headerlink" title="define( id?, deps?, factory );"></a>define( id?, deps?, factory );</h4><p> define也可以接受两个以上的参数，字符串id为模块标识，数组deps为模块依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define( &apos;module&apos;, [&apos;module1&apos;, &apos;module2&apos;], function( require, exports, module )&#123;</span><br><span class="line">    // 模块代码</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>其与 AMD 规范用法不同。</p>
<p><strong>require 是 factory 的第一个参数。</strong></p>
<p> require( id );<br> 接受模块标识作为唯一的参数，用来获取其他模块提供的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function( require, exports )&#123;</span><br><span class="line">    var a = require(&apos;./a&apos;);</span><br><span class="line">    a.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  require.async( id, callback? );<br>  require是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define( function(require, exports, module) &#123; </span><br><span class="line">    require.async(&apos;.a&apos;, function(a)&#123;</span><br><span class="line">        a.doSomething();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> require.resolve( id )<br> 可以使用模块内部的路径机制来返回模块路径，不会加载模块。</p>
<p> exports 是 factory 的第二个参数，用来向外提供模块接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">define(function( require, exports )&#123;</span><br><span class="line">    exports.foo = &apos;bar&apos;; // 向外提供的属性</span><br><span class="line">    exports.do = function()&#123;&#125;; // 向外提供的方法</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 当然也可以使用 return 直接向外提供接口。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define(function( require, exports )&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        foo : &apos;bar&apos;, // 向外提供的属性</span><br><span class="line">        do : function()&#123;&#125; // 向外提供的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">也可以简化为直接对象字面量的形式:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define(&#123;</span><br><span class="line">    foo : &apos;bar&apos;, // 向外提供的属性</span><br><span class="line">    do : function()&#123;&#125; // 向外提供的方法</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 与nodeJS中一样需要注意的是，一下方式是错误的：</span><br></pre></td></tr></table></figure>
<p>define(function( require, exports ){<br>    exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要这么做</span><br></pre></td></tr></table></figure></p>
<p>define(function( require, exports, module ){<br>    module.exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 传入的对象引用可以添加属性，一旦赋值一个新的对象，那么值钱传递进来的对象引用就会失效了。开始之初，exports 是作为 module.exports 的一个引用存在，一切行为只有在这个引用上 factory 才得以正常运行，赋值新的对象后就会断开引用，exports就只是一个新的对象引用，对于factory来说毫无意义，就会出错。</span><br><span class="line"></span><br><span class="line">- module 是factory的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法。</span><br><span class="line">  module.id 为模块的唯一标识。</span><br><span class="line">   module.uri 根据模块系统的路径解析规则得到模块的绝对路径。</span><br><span class="line">  module.dependencies 表示模块的依赖。</span><br><span class="line">  module.exports 当前模块对外提供的接口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## seaJS</span><br><span class="line">    官网 http://seajs.org/docs/</span><br><span class="line">    API快速参考 https://github.com/seajs/seajs/issues/266</span><br><span class="line">    sea.js 核心特征：</span><br><span class="line">        1. 遵循CMD规范，与NodeJS般的书写模块代码。</span><br><span class="line">        2. 依赖自动加载，配置清晰简洁。</span><br><span class="line">    兼容 Chrome 3+，Firefox 2+，Safari 3.2+，Opera 10+，IE 5.5+。</span><br><span class="line"></span><br><span class="line">    seajs.use </span><br><span class="line">    用来在页面中加载一个或者多个模块</span><br></pre></td></tr></table></figure></p>
<p>// 加载一个模块<br>seajs.use(‘./a’);<br>// 加载模块，加载完成时执行回调<br>seajs.use(‘./a’，function(a){<br>    a.doSomething();<br>});<br>// 加载多个模块执行回调<br>seajs.use([‘./a’,’./b’]，function(a , b){<br>    a.doSomething();<br>    b.doSomething();<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    其define 与 require 使用方式基本就是CMD规范中的示例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AMD 与 CMD 区别到底在哪里？</span><br><span class="line"></span><br><span class="line">    看了以上 AMD，requireJS 与 CMD， seaJS的简单介绍会有点感觉模糊，总感觉较为相似。因为像 requireJS 其并不是只是纯粹的AMD固有思想，其也是有CMD规范的思想，只不过是推荐 AMD规范方式而已， seaJS也是一样。</span><br><span class="line"></span><br><span class="line">    下面是玉伯对于 AMD 与 CMD 区别的解释：</span><br><span class="line"></span><br><span class="line">    AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</span><br><span class="line">    CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</span><br><span class="line"></span><br><span class="line">    类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出还有不少??</span><br><span class="line"></span><br><span class="line">    这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。</span><br><span class="line">    目前这些规范的实现都能达成浏览器端模块化开发的目的。</span><br><span class="line"></span><br><span class="line">    区别：</span><br><span class="line"></span><br><span class="line">    1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</span><br><span class="line">    2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：</span><br></pre></td></tr></table></figure></p>
<p>// CMD<br>define(function(require, exports, module) {<br>    var a = require(‘./a’)<br>    a.doSomething()<br>    // 此处略去 100 行<br>    var b = require(‘./b’) // 依赖可以就近书写<br>    b.doSomething()<br>    // …<br>})</p>
<p>// AMD 默认推荐的是<br>define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好<br>    a.doSomething()<br>    // 此处略去 100 行<br>    b.doSomething()<br>    // …<br>})<br>```</p>
<p>虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。</p>
<pre><code>3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。
</code></pre><p>另外，SeaJS 和 RequireJS 的差异，可以参考：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="external">https://github.com/seajs/seajs/issues/277</a></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/05/测试驱动开发/" >
  TDD测试驱动开发*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/05/测试驱动开发/"><span class="article-date">
  2016-06-05
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/测试/">测试</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TDD/">TDD</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>另有一篇介绍<a href="http://www.vaikan.com/top-5-tdd-mistakes/" target="_blank" rel="external">测试驱动开发上的五大错误</a>,也可以看看</p>
<p><a href="http://www.360doc.com/content/07/0516/17/15822_503491.shtml" target="_blank" rel="external">转载自360图书馆</a><br>测试驱动开发（Test-Driven Development，TDD）是通过测试定义所要开发的功能的接口，然后实现功能的开发过程。<br>      Test-Driven Development(TDD)，是Extreme Programming (XP)–极限编程的一个重要组成部分。</p>
<h2 id="测试驱动开发TDD简介入门"><a href="#测试驱动开发TDD简介入门" class="headerlink" title="测试驱动开发TDD简介入门"></a>测试驱动开发TDD简介入门</h2><p>测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。</p>
<p>TDD 是通过测试定义所要开发的功能的接口，然后实现功能的开发过程。是<a href="http://www.itisedu.com/phrase/200604231325295.html" target="_blank" rel="external">Extreme Programming (XP)–极限编程</a>的一个重要组成部分。</p>
<p><img src="http://image.360doc.com/DownloadImg/15822/503491_1.jpg" alt=""></p>
<p>在上面的图中，列出的的是XP的12个团队实践。Test-Driven Development是其中之一。</p>
<ul>
<li><p>Kent Beck 的著作TDD(Test Driven Development) 中详细讲述了测试驱动开发。</p>
</li>
<li><p>当你使用TDD的时候一定要说明是测试驱动开发还是测试驱动设计。这两者是有区别的。测试驱动开发，是通过测试定义所要开发的功能的接口，然后实现功能的开发过程。对于测试驱动设计，在XP中似乎已经消失了，而是被测试驱动开发所取代。另外在XP中有用于描述设计的，SimpleDesign ，Design Improvement.</p>
</li>
</ul>
<h3 id="一、测试驱动开发的基本过程"><a href="#一、测试驱动开发的基本过程" class="headerlink" title="一、测试驱动开发的基本过程"></a>一、测试驱动开发的基本过程</h3><pre><code>1） 明确当前要完成的功能。可以记录成一个 TODO 列表。
2） 快速完成针对此功能的测试用例编写。
3） 测试代码编译不通过。
4） 编写对应的功能代码。
5） 测试通过。
6） 对代码进行重构，并保证测试通过。
7） 循环完成所有功能的开发。
</code></pre><h3 id="二、测试驱动开发的原则"><a href="#二、测试驱动开发的原则" class="headerlink" title="二、测试驱动开发的原则"></a>二、测试驱动开发的原则</h3><pre><code>1）测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。

2）一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。

3）测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。

4）测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。

5）先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。

6）可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。

7）及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。
</code></pre><h3 id="三、测试驱动开发的测试范围"><a href="#三、测试驱动开发的测试范围" class="headerlink" title="三、测试驱动开发的测试范围"></a>三、测试驱动开发的测试范围</h3><pre><code>按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试，测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。
</code></pre><h3 id="四、TDD的优点"><a href="#四、TDD的优点" class="headerlink" title="四、TDD的优点"></a>四、TDD的优点</h3><pre><code>『充满吸引力的优点』

完工时完工。表明我可以很清楚的看到自己的这段工作已经结束了，而传统的方式很难知道什么时候编码工作结束了。 
全面正确的认识代码和利用代码，而传统的方式没有这个机会。 
为利用你成果的人提供Sample，无论它是要利用你的源代码，还是直接重用你提供的组件。 
开发小组间降低了交流成本，提高了相互信赖程度。 
避免了过渡设计。 
系统可以与详尽的测试集一起发布，从而对程序的将来版本的修改和扩展提供方便。 
TDD给了我们自信，让我们今天的问题今天解决，明天的问题明天解决，今天不能解决明天的问题，因为明天的问题还没有出现(没有TestCase)，除非有TestCase否则我决不写任何代码；明天也不必担心今天的问题，只要我亮了绿灯。

『不显而易见的优点』

逃避了设计角色。对于一个敏捷的开发小组，每个人都在做设计。 
大部分时间代码处在高质量状态，100％的时间里成果是可见的。 
由于可以保证编写测试和编写代码的是相同的程序员，降低了理解代码所花费的成本。 
为减少文档和代码之间存在的细微的差别和由这种差别所引入的Bug作出杰出贡献。 
在预先设计和紧急设计之间建立一种平衡点，为你区分哪些设计该事先做、哪些设计该迭代时做提供了一个可靠的判断依据。

『有争议的优点』

 事实上提高了开发效率。每一个正在使用TDD并相信TDD的人都会相信这一点，但观望者则不同，不相信TDD的人甚至坚决反对这一点，这很正常，世界总是这样。 
发现比传统测试方式更多的Bug。 
使IDE的调试功能失去意义，或者应该说，避免了令人头痛的调试和节约了调试的时间。 
总是处在要么编程要么重构的状态下，不会使人抓狂。（两顶帽子） 
单元测试非常有趣。
</code></pre><h3 id="五、TDD的-优势"><a href="#五、TDD的-优势" class="headerlink" title="五、TDD的 优势"></a>五、TDD的 优势</h3><pre><code>TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。

需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。

通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。

开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。

快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。

当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。

我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。

那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。
</code></pre><h3 id="六、TDD的原理"><a href="#六、TDD的原理" class="headerlink" title="六、TDD的原理"></a>六、TDD的原理</h3><pre><code>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。

我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。
</code></pre><p><img src="http://image.360doc.com/DownloadImg/15822/503491_2.jpg" alt="图 V测试模型"></p>
<pre><code>在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。

关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。
</code></pre><p><img src="http://image.360doc.com/DownloadImg/15822/503491_3.jpg" alt=""><br>【图 X测试模型】</p>
<pre><code>基本原理应该说非常简单，那么如何进行实际操作哪，下面对开发过程进行详细的介绍。
</code></pre><h3 id="七、测试技术"><a href="#七、测试技术" class="headerlink" title="七、测试技术　"></a>七、测试技术　</h3><pre><code>1. 测试范围、粒度

对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。

测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。

测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。

小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。

2. 怎么编写测试用例

测试用例的编写就用上了传统的测试技术。

操作过程尽量模拟正常使用的过程。 
全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。 
测试数据尽量包括：真实数据、边界数据。 
测试语句和测试数据应该尽量简单，容易理解。 
为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。 
如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。
</code></pre><h3 id="八、Tips"><a href="#八、Tips" class="headerlink" title="八、Tips"></a>八、Tips</h3><pre><code>很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。

软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。
</code></pre><h3 id="九、FAQ"><a href="#九、FAQ" class="headerlink" title="九、FAQ"></a>九、FAQ</h3><p>[什么时候重构？]<br>如果您在软件公司工作，就意味着您成天都会和想通过重构改善代码质量的想法打交道，不仅您如此，您的大部分同事也都如此。可是，究竟什么时候该重构，什么情况下应该重构呢？我相信您和您的同事可能有很多不同的看法，最常见的答案是“该重构时重构”，“写不下去的时候重构”，和“下一次迭代开始之前重构”，或者干脆就是“最近没时间，就不重构了，下次有时间的时候重构吧”。正如您已经预见到我想说的——这些想法都是对重构的误解。重构不是一种构建软件的工具，不是一种设计软件的模式，也不是一个软件开发过程中的环节，正确理解重构的人应该把重构看成一种书写代码的方式，或习惯，重构时时刻刻有可能发生。在TDD中，除去编写测试用例和实现测试用例之外的所有工作都是重构，所以，没有重构任何设计都不能实现。至于什么时候重构嘛，还要分开看，有三句话是我的经验：实现测试用例时重构代码，完成某个特性时重构设计，产品的重构完成后还要记得重构一下测试用例哦。</p>
<p>[什么时候设计？]<br>这个问题比前面一个要难回答的多，实话实说，本人在依照TDD开发软件的时候也常常被这个问题困扰，总是觉得有些问题应该在写测试用例之前定下来，而有些问题应该在新增一个一个测试用例的过程中自然出现，水到渠成。所以，我的建议是，设计的时机应该由开发者自己把握，不要受到TDD方式的限制，但是，不需要事先确定的事一定不能事先确定，免得捆住了自己的手脚。</p>
<p>[什么时候增加新的TestCase？]<br>没事做的时候。通常我们认为，如果你要增加一个新的功能，那么先写一个不能通过的TestCase；如果你发现了一个bug，那么先写一个不能通过的TestCase；如果你现在什么都没有，从0开始，请先写一个不能通过的TestCase。所有的工作都是从一个TestCase开始。此外，还要注意的是，一些大师要求我们每次只允许有一个TestCase亮红灯，在这个TestCase没有Green之前不可以写别的TestCase，这种要求可以适当考虑，但即使有多个TestCase亮红灯也不要紧，并未违反TDD的主要精神。</p>
<p>[TestCase该怎么写？]<br>测试用例的编写实际上就是两个过程：使用尚不存在的代码和定义这些代码的执行结果。所以一个TestCase也就应该包括两个部分——场景和断言。第一次写TestCase的人会有很大的不适应的感觉，因为你之前所写的所有东西都是在解决问题，现在要你提出问题确实不大习惯，不过不用担心，你正在做正确的事情，而这个世界上最难的事情也不在于如何解决问题，而在于ask the right question！</p>
<p>[TDD能帮助我消除Bug吗？]<br>答：不能！千万不要把“测试”和“除虫”混为一谈！“除虫”是指程序员通过自己的努力来减少bug的数量（消除bug这样的字眼我们还是不要讲为好^_^），而“测试”是指程序员书写产品以外的一段代码来确保产品能有效工作。虽然TDD所编写的测试用例在一定程度上为寻找bug提供了依据，但事实上，按照TDD的方式进行的软件开发是不可能通过TDD再找到bug的（想想我们前面说的“完工时完工”），你想啊，当我们的代码完成的时候，所有的测试用例都亮了绿灯，这时隐藏在代码中的bug一个都不会露出马脚来。</p>
<p>但是，如果要问“测试”和“除虫”之间有什么联系，我相信还是有很多话可以讲的，比如TDD事实上减少了bug的数量，把查找bug战役的关注点从全线战场提升到代码战场以上。还有，bug的最可怕之处不在于隐藏之深，而在于满天遍野。如果你发现了一个用户很不容易才能发现的bug，那么不一定对工作做出了什么杰出贡献，但是如果你发现一段代码中，bug的密度或离散程度过高，那么恭喜你，你应该抛弃并重写这段代码了。TDD避免了这种情况，所以将寻找bug的工作降低到了一个新的低度。</p>
<p>[我该为一个Feature编写TestCase还是为一个类编写TestCase？]<br>初学者常问的问题。虽然我们从TDD的说明书上看到应该为一个特性编写相应的TestCase，但为什么著名的TDD大师所写的TestCase都是和类/方法一一对应的呢？为了解释这个问题，我和我的同事们都做了很多试验，最后我们得到了一个结论，虽然我不知道是否正确，但是如果您没有答案，可以姑且相信我们。</p>
<p>我们的研究结果表明，通常在一个特性的开发开始时，我们针对特性编写测试用例，如果您发现这个特性无法用TestCase表达，那么请将这个特性细分，直至您可以为手上的特性写出TestCase为止。从这里开始是最安全的，它不会导致任何设计上重大的失误。但是，随着您不断的重构代码，不断的重构TestCase，不断的依据TDD的思想做下去，最后当产品伴随测试用例集一起发布的时候，您就会不经意的发现经过重构以后的测试用例很可能是和产品中的类/方法一一对应的。</p>
<p>[什么时候应该将全部测试都运行一遍？]<br>Good Question！大师们要求我们每次重构之后都要完整的运行一遍测试用例。这个要求可以理解，因为重构很可能会改变整个代码的结构或设计，从而导致不可预见的后果，但是如果我正在开发的是一个ERP怎么办？运行一遍完整的测试用例可能将花费数个小时，况且现在很多重构都是由工具做到的，这个要求的可行性和前提条件都有所动摇。所以我认为原则上你可以挑几个你觉得可能受到本次重构影响的TestCase去run，但是如果运行整个测试包只要花费数秒的时间，那么不介意你按大师的要求去做。</p>
<p>[什么时候改进一个TestCase？]<br>增加的测试用例或重构以后的代码导致了原来的TestCase的失去了效果，变得无意义，甚至可能导致错误的结果，这时是改进TestCase的最好时机。但是有时你会发现，这样做仅仅导致了原来的TestCase在设计上是臃肿的，或者是冗余的，这都不要紧，只要它没有失效，你仍然不用去改进它。记住，TestCase不是你的产品，它不要好看，也不要怎么太科学，甚至没有性能要求，它只要能完成它的使命就可以了——这也证明了我们后面所说的“用Ctrl-C/Ctrl-V编写测试用例”的可行性。</p>
<p>但是，美国人的想法其实跟我们还是不太一样，拿托尼巴赞的MindMap来说吧，其实画MindMap只是为了表现自己的思路，或记忆某些重要的事情，但托尼却建议大家把MindMap画成一件艺术品，甚至还有很多艺术家把自己画的抽象派MindMap拿出来帮助托尼做宣传。同样，大师们也要求我们把TestCase写的跟代码一样质量精良，可我想说的是，现在国内有几个公司能把产品的代码写的精良？？还是一步一步慢慢来吧。</p>
<p>[为什么原来通过的测试用例现在不能通过了？]<br>这是一个警报，Red Alert！它可能表达了两层意思——都不是什么好意思——1）你刚刚进行的重构可能失败了，或存在一些错误未被发现，至少重构的结果和原来的代码不等价了。2）你刚刚增加的TestCase所表达的意思跟前面已经有的TestCase相冲突，也就是说，新增的功能违背了已有的设计，这种情况大部分可能是之前的设计错了。但无论哪错了，无论是那层意思，想找到这个问题的根源都比TDD的正常工作要难。</p>
<p>[我怎么知道那里该有一个方法还是该有一个类？]<br>这个问题也是常常出现在我的脑海中，无论你是第一次接触TDD或者已经成为TDD专家，这个问题都会缠绕着你不放。不过问题的答案可以参考前面的“什么时候设计”一节，答案不是唯一的。其实多数时候你不必考虑未来，今天只做今天的事，只要有重构工具，从方法到类和从类到方法都很容易。</p>
<p>[我要写一个TestCase，可是不知道从哪里开始？]<br>从最重要的事开始，what matters most？从脚下开始，从手头上的工作开始，从眼前的事开始。从一个没有UI的核心特性开始，从算法开始，或者从最有可能耽误时间的模块开始，从一个最严重的bug开始。这是TDD主义者和鼠目寸光者的一个共同点，不同点是前者早已成竹在胸。</p>
<p>[为什么我的测试总是看起来有点愚蠢？]<br>哦？是吗？来，握个手，我的也是！不必担心这一点，事实上，大师们给的例子也相当愚蠢，比如一个极端的例子是要写一个两个int变量相加的方法，大师先断言2+3=5，再断言5+5=10，难道这些代码不是很愚蠢吗？其实这只是一个极端的例子，当你初次接触TDD时，写这样的代码没什么不好，以后当你熟练时就会发现这样写没必要了，要记住，谦虚是通往TDD的必经之路！从经典开发方法转向TDD就像从面向过程转向面向对象一样困难，你可能什么都懂，但你写出来的类没有一个纯OO的！我的同事还告诉我真正的太极拳，其速度是很快的，不比任何一个快拳要慢，但是初学者（通常是指学习太极拳的前10年）太不容易把每个姿势都做对，所以只能慢慢来。</p>
<p>[什么场合不适用TDD？]<br>问的好，确实有很多场合不适合使用TDD。比如对软件质量要求极高的军事或科研产品——神州六号，人命关天的软件——医疗设备，等等，再比如设计很重要必须提前做好的软件，这些都不适合TDD，但是不适合TDD不代表不能写TestCase，只是作用不同，地位不同罢了</p>

        
      </div>
    </div>

  
    </div>
  



  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/categories/技术/page/2/">2</a><a class="page-number" href="/categories/技术/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/categories/技术/page/14/">14</a><a class="extend next" rel="next" href="/categories/技术/page/2/">下一页</a>
  </div>




          <div class="main-footer">
  
    © 2016 findmoon-白色蜗牛 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
