<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    分类: js
  
</title>

<meta name="description" content="人生是一场不断的转换，我们试着所向披靡">
<meta property="og:type" content="website">
<meta property="og:title" content="findmoon-白色蜗牛">
<meta property="og:url" content="//findmoon.github.io/index.html/categories/技术/js/index.html">
<meta property="og:site_name" content="findmoon-白色蜗牛">
<meta property="og:description" content="人生是一场不断的转换，我们试着所向披靡">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="findmoon-白色蜗牛">
<meta name="twitter:description" content="人生是一场不断的转换，我们试着所向披靡">




  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">findmoon-白色蜗牛</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">findmoon-白色蜗牛</a></h1>
    
      <p class="subtitle">
        一个试图专注于自身的成长者
      </p>
    
    <div class="info">
      <div class="content">
        
          <div class="description">人生是一场不断的转换，我们试着所向披靡</div>
        
        
          <div class="author">findmoon</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="http://i2.piimg.com/81760750547ee122.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">133</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/方法-实例/">方法/实例</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">10</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFC/">BFC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backbone/">Backbone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3动画/">CSS3动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS解析域名/">DNS解析域名</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOCTYPE/">DOCTYPE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MV模式/">MV模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mocha/">Mocha</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP三次握手/">TCP三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNICODE-ASCII/">UNICODE/ASCII</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate/">animate()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate动画队列/">animate动画队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/background-image/">background-image</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border/">border</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border图形/">border图形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/box-shadow/">box-shadow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console-log/">console.log()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css属性/">css属性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css样式/">css样式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deferred/">deferred</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/delete/">delete</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-child/">first-child</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-of-type/">first-of-type</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/float/">float</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font-face/">font-face</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/form表单/">form表单</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/get/">get</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitbash/">gitbash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git错误/">git错误</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haslayout/">haslayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http状态码/">http状态码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inline-block/">inline-block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/input/">input</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/">instanceof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof-typeof/">instanceof/typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js严格模式/">js严格模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js加载/">js加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js模板引擎/">js模板引擎</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list-style/">list-style</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meta/">meta</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offset/">offset()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overflow/">overflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/placeholder/">placeholder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position/">position</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position文档流/">position文档流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/post/">post</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scopechain/">scopechain</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stringify/">stringify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/">typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/undefined/">undefined</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/url加载/">url加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zoom/">zoom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码书写/">代码书写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列表/">列表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画animation/">动画animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量/">变量</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同源跨域/">同源跨域</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字面量/">字面量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/库与架构/">库与架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学函数/">数学函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据包组装/">数据包组装</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法/">方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记语言/">标记语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化编程/">模块化编程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/立即执行函数/">立即执行函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站访问/">网站访问</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/获取路径/">获取路径</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行内元素/">行内元素</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求/">跨域请求</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求处理方法/">跨域请求处理方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择器/">选择器</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">161</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
            
              <li>
                <a href="/work" title="work">work</a>
              </li>
            
          
            
              <li>
                <a href="/about" title="about">about</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="http://findmoon.github.io/" title="findmoon" target="_blank" rel="external">findmoon</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/findmoon/findmoon.github.io" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <h1>js</h1>


  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/13/关于js中(function(){…})()立即执行函数/" >
  关于js中(function(){…})()立即执行函数
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/13/关于js中(function(){…})()立即执行函数/"><span class="article-date">
  2016-06-13
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/立即执行函数/">立即执行函数</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>关于js中(function(){…})()立即执行函数</p>
<p>js中的函数有一些基本概念：函数声明、函数表达式、匿名函数</p>
<ul>
<li><p>函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。</p>
</li>
<li><p>函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</p>
</li>
<li><p>匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p>
</li>
</ul>
<p>函数声明和函数表达式不同之处在于:</p>
<ul>
<li>一、Javascript引擎在解析javascript代码时,函数声明会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式，</li>
<li>二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fnName();</span><br><span class="line">function fnName()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;//正常，因为‘提升’了函数声明，函数调用可在函数声明之前</span><br><span class="line"> </span><br><span class="line">fnName();</span><br><span class="line">var fnName=function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后</span><br><span class="line"></span><br><span class="line">var fnName=function()&#123;</span><br><span class="line">    alert(&apos;Hello World&apos;);</span><br><span class="line">&#125;();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数</span><br><span class="line"></span><br><span class="line">function fnName()&#123;</span><br><span class="line">    alert(&apos;Hello World&apos;);</span><br><span class="line">&#125;();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用</span><br><span class="line"></span><br><span class="line">function()&#123;</span><br><span class="line">    console.log(&apos;Hello World&apos;);    </span><br><span class="line">&#125;();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，</span><br><span class="line">//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名</span><br></pre></td></tr></table></figure>
<p>了解了函数声明和函数表达式,接下来看看( function(){…} )()和( function (){…} () )这两种形式的立即执行函数。这种形式的函数之所以可以立即执行，是因为()前面的函数体在一个()运算符之内构成了一个函数表达式，也就是在一个函数表达式后面加一个()就可以变成立即执行函数，()前不能是函数声明。</p>
<blockquote>
<p>表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。约束变量在表达式中已被指定数值，而自由变量则可以在表达式之外另行指定数值。一个表达式代表一个函数，其输入为自由变量的定值，而其输出则为表达式因之后所产生出的数值。 ——维基百科</p>
</blockquote>
<p>这两种形式的运用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出123,使用（）运算符</span><br><span class="line">&#125;)(123);</span><br><span class="line"> </span><br><span class="line">(function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出1234，使用（）运算符</span><br><span class="line">&#125;(1234));</span><br><span class="line"> </span><br><span class="line">!function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出12345,使用！运算符</span><br><span class="line">&#125;(12345);</span><br><span class="line"> </span><br><span class="line">+function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出123456,使用+运算符</span><br><span class="line">&#125;(123456);</span><br><span class="line"> </span><br><span class="line">-function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出1234567,使用-运算符</span><br><span class="line">&#125;(1234567);</span><br><span class="line"> </span><br><span class="line">var fn=function(a)&#123;</span><br><span class="line">    console.log(a);   //firebug输出12345678，使用=运算符</span><br><span class="line">&#125;(12345678)</span><br></pre></td></tr></table></figure></p>
<p>可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p>
<p>加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</p>
<p><strong>这样的写法可以形成一个独立的作用域？</strong></p>
<p>javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p>
<p>JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…})(window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。</p>
<p>原文参考地址：<a href="http://my.oschina.net/u/2331760/blog/468672?p=" target="_blank" rel="external">http://my.oschina.net/u/2331760/blog/468672?p=</a></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/10/stopImmediatePropagation介绍/" >
  stopImmediatePropagation介绍*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/10/stopImmediatePropagation介绍/"><span class="article-date">
  2016-06-10
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>stopImmediatePropagation介绍</p>
<p><a href="http://www.cnblogs.com/zzbo/p/3366264.html" target="_blank" rel="external">原文地址</a></p>
<p>在众多的方法里面，event.stopImmediatePropagation 算是比较少用的一个方法，拼写上感觉一半像 event.stopPropagation。</p>
<p>对于stopPropagation 的用法大家是众所周知的，他是W3C标准事件方法，用于阻止事件冒泡（非标准情况下，用window.event.stopBubble来阻止冒泡）</p>
<p>而stopImmediatePropagation 的功能比stopPropagation 多一些，除了可以阻止事件冒泡之外，还可以把这个元素绑定的同类型事件也阻止了。</p>
<p>先把下面的代码片断（摘自MDN）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            p &#123; height: 30px; width: 150px; background-color: #ccf; &#125;</span><br><span class="line">            div &#123;height: 30px; width: 150px; background-color: #cfc; &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;paragraph&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是p元素上被绑定的第一个监听函数&quot;);</span><br><span class="line">            &#125;, false);</span><br><span class="line">            document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是p元素上被绑定的第二个监听函数&quot;);</span><br><span class="line">                event.stopImmediatePropagation();</span><br><span class="line">                //执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.</span><br><span class="line">            &#125;, false);</span><br><span class="line">            document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是p元素上被绑定的第三个监听函数&quot;);</span><br><span class="line">                //该监听函数排在上个函数后面,该函数不会被执行.</span><br><span class="line">            &#125;, false);</span><br><span class="line">            document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, function(event)</span><br><span class="line">            &#123;</span><br><span class="line">                alert(&quot;我是div元素,我是p元素的上层元素&quot;);</span><br><span class="line">                //p元素的click事件没有向上冒泡,该函数不会被执行.</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>p标签绑定了三个click事件，div绑定了一个click事件。</p>
<ul>
<li>其中p第二个click事件中使用了event.stopImmediatePropagation();</li>
</ul>
<blockquote>
<p>当点击时P标签时，第一和第二个alert会正常出现，<br>第三个alert被event.stopImmediatePropagation();的特性取消了以后的同类型(click)事件<br>第四个alert不出来同被阻止了事件冒泡，所以也不会出现。<br>相当于做了event.stopPropagation()后，再return false;  jQuery对事件代理做了类似的封装。</p>
</blockquote>
<p>我们了解特性之后，看一个简单应用场景:</p>
<p>假设点击一个按钮后，需要检测两个input控件的值，值为空时打印’error’，并停止检测下一个input，同时也需停止提单提交。<br>我们通常可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;txt1&quot;&gt;</span><br><span class="line">　　　　 &lt;input type=&quot;text&quot; id=&quot;txt2&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;button&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var txt1 = document.querySelector(&quot;#txt1&quot;);</span><br><span class="line">　　　　　　　var txt2 = document.querySelector(&quot;#txt2&quot;);</span><br><span class="line">            var btn = document.querySelector(&quot;#btn&quot;);</span><br><span class="line">            btn.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">                if (txt1.value == &apos;&apos;) &#123;</span><br><span class="line">                    alert(&apos;error1&apos;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">　　　　　　　　　 if (txt2.value == &apos;&apos;) &#123; </span><br><span class="line">                    alert(&apos;error2&apos;);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;, false);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>但用了event.stopImmediatePropagation时，可以对代码进行更好的抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;txt1&quot;&gt;</span><br><span class="line">　　　　 &lt;input type=&quot;text&quot; id=&quot;txt2&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;button&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var txt1 = document.querySelector(&quot;#txt1&quot;);</span><br><span class="line">　　　　　　var txt2 = document.querySelector(&quot;#txt2&quot;);</span><br><span class="line">            var btn = document.querySelector(&quot;#btn&quot;);</span><br><span class="line"></span><br><span class="line">            btn.addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">                if (txt1.value == &apos;&apos;) &#123;</span><br><span class="line">                    alert(&apos;error1&apos;);</span><br><span class="line">                    event.stopImmediatePropagation();</span><br><span class="line">                &#125;</span><br><span class="line">　　　　　　　　if (txt2.value == &apos;&apos;) &#123; </span><br><span class="line">                    alert(&apos;error2&apos;);</span><br><span class="line">                    event.stopImmediatePropagation();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;, false);</span><br><span class="line">　　　　　　</span><br><span class="line">            btn.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">                 alert(&apos;Done&apos;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>题外：<br>event.isImmediatePropagationStopped 可以用来确定该元素是否有调用过event.stopImmediatePropagation。</p>
<p>浏览器支持情况：<br>Firefox &gt;=10Chrome<br>IE &gt;= 9<br>Opera<br>Safari</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/06/字面量简介/" >
  字面量简介
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/06/字面量简介/"><span class="article-date">
  2016-06-06
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字面量/">字面量</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <ul>
<li>字面量简介：</li>
</ul>
<p>在计算机科学中，字面量(literal)是用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如:整数、浮点数以及字符串;而有很多也对布尔类型和字符类型的值也支持字面量表示;还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</p>
<p>在编程语言中，字面量是一种表示值的记法。例如，”Hello, World!” 在许多语言中都表示一个字符串字面量（string literal ），JavaScript也不例外。以下也是JavaScript字面量的例子，如5、true、false和null，它们分别表示一个整数、两个布尔值和一个空对象。</p>
<ul>
<li>JavaScript还支持对象和数组字面量，允许使用一种简洁而可读的记法来创建数组和对象。考虑以下语句，其中创建了一个包含两个属性的对象（firstName和lastName）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();</span><br><span class="line">o.name = &apos;Byron&apos;;</span><br><span class="line">o.age = 24;</span><br></pre></td></tr></table></figure>
<p>上面是创建对象的方法，可以使用下面字面量的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Byron&apos;,</span><br><span class="line">    age:24</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上赋值语句的右边是一个对象字面量（object literal）。对象字面量是一个名值对列表，每个名值对之间用逗号分隔，并用一个大括号括起。各名值对表示对象的一个属性，名和值这两部分之间用一个冒号分隔。要创建一个数组，可以创建Array对象的一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a=new Array();</span><br><span class="line">a.push(1,2,3);</span><br></pre></td></tr></table></figure>
<p>不过首选的方法是使用一个数组字面量（array literal），这是一个用逗号分隔的值列表，用中括号括起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br></pre></td></tr></table></figure>
<ul>
<li>函数字面量（function literal）如下构造：前面是一个function关键字，后面是一个函数名（可选）和参数表。然后是函数体，包围在大括号中。</li>
</ul>
<p>赋给team变量的对象有3个属性：name、members和count</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var team = &#123;</span><br><span class="line">	name: &apos;hard&apos;,</span><br><span class="line">	work: &apos;learn&apos;,</span><br><span class="line">	sum: function()&#123; return 1+2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript对象记法（JavaScript Object Notation，JSON），这是一种用于描述文件和数组的记法，由JavaScript字面量的一个子集组成。JSON在Ajax开发人员中越来越流行，因为这种格式可以用于交换数据，通常取代了XML。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">对象字面量：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //只能添加静态属性和方法</span><br><span class="line">   var myObject=&#123;</span><br><span class="line">     propertyA: sha ,</span><br><span class="line">     propertyB: feng ,</span><br><span class="line">     methodA:function()&#123;</span><br><span class="line">      alert(this.propertyA++this.propertyB);</span><br><span class="line">     &#125;,</span><br><span class="line">     methodB:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    myObject.methodA();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //利用prototype属性可以添加公有属性和方法</span><br><span class="line">   </span><br><span class="line">   function myConstructor2()&#123;&#125;;  //声明构造函数，可以使用对象字面量语法来向prototype属性中添加所有公有成员</span><br><span class="line">   </span><br><span class="line">    myConstructor2.prototype=&#123;</span><br><span class="line">     propertyA: sha ,</span><br><span class="line">     propertyB: feng ,</span><br><span class="line">     methodA:function()&#123;</span><br><span class="line">      alert(this.propertyA++this.propertyB);</span><br><span class="line">     &#125;,</span><br><span class="line">     methodB:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   var myconstrustor=new myConstructor2(); //声明对象</span><br><span class="line">    myconstrustor.methodA();</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/yxf2011/archive/2012/04/01/2428225.html" target="_blank" rel="external">参考链接</a></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/06/04/js模板引擎介绍搜集/" >
  js模板引擎介绍搜集
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/06/04/js模板引擎介绍搜集/"><span class="article-date">
  2016-06-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js模板引擎/">js模板引擎</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://blog.csdn.net/lybwwp/article/details/18813737" target="_blank" rel="external">js模板引擎介绍搜集*转载</a></p>
<p>s模板引擎越来越多的得到应用，如今已经出现了几十种js模板引擎，国内各大互联网公司也都开发了自己的js模板引擎（淘宝的kissy template，腾讯的artTemplate，百度的baiduTemplate等），如何从这么多纷繁的模板引擎中选择一款适合自己的呢</p>
<p>从这几个指标来比较js模板引擎：<br>1 文件大小 - 影响网络传输时间<br>2 执行速度（性能） - 影响响应速度，涉及模板解析和渲染<br>3 语法简明/易用/灵活/自定义操作符 - 影响开发效率和维护难度<br>4 错误处理/调试 - 影响开发效率和维护难度<br>5 安全（XSS） - 是否防止XSS</p>
<p>1 文件大小（压缩后）<br>Mustache：5k<br>doT：4k<br>juicer：7.65k<br>artTemplate(腾讯)：5k<br>baiduTemplate(百度)：3k<br>Underscore(Arale)：11.7k - 不只是模板，还包含很多js语言增强功能<br>Handlebars(Arale)：30.5k</p>
<p>2 执行速度（不要迷恋速度）<br>对于执行速度，不得不提模板“编译速度”和“渲染速度”。这几个主流模板都支持将模板预编译，然后再渲染。<br>这里有一篇文章《高性能JavaScript模板引擎原理解析》，说artTemplate的速度达到理论极限，实际说的是渲染速度，它的综合速度并不快。<br>一般情况下，每页面只有一两个模板，执行时间差别不大。</p>
<blockquote>
<blockquote>
<p>这里&lt;&lt;有个测试页面，根据artTemplate的测试页面《引擎渲染速度竞赛》改的，揭示了几个主流js模板引擎的性能情况，大致结果截图如下：</p>
</blockquote>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130515201225085" alt=""></p>
<p>可以看出artTemplate,juicer,doT比其他模板引擎快很多。</p>
<p>3 语法 简明/易用/灵活/自定义操作符 - 影响开发效率和维护难度</p>
<p>语法需要一段时间的使用经验才能更深切地体会到优缺点，并且每个人喜欢的语法风格也不同，这部分可能略带个人主观色彩。<br>这几个js模板引擎的语法可以粗略分为两种，一种是类似javascript的语法（doT, artTemplate, underscore），另一种是与javascript差异较大的语法（Mustache, juicer, handlebars）。从易上手的角度来看，类javascript语法更容易被新手掌握，但是熟练掌握之后，各个模板的语法都能满足我们的需求，可以按个人喜好来选择。</p>
<p>Mustache声称是无逻辑（logic-less）模板，没有for、if…else…语法，但实际可以实现循环和分支，还可以实现更复杂的逻辑。<br>doT模板语法灵活，阅读起来很易懂。可以方便地改造成jquery插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[javascript] view plaincopy </span><br><span class="line">&lt;!--Mustache 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;Mustache&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;&#123;#list&#125;&#125;  </span><br><span class="line">        &lt;li&gt;&#123;&#123;&#123;index&#125;&#125;&#125;. 用户: &#123;&#123;&#123;user&#125;&#125;&#125;/ 网站：&#123;&#123;&#123;site&#125;&#125;&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;&#123;/list&#125;&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- doT 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;doT&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;&#123; for (var val, i = 0, l = it.list.length; i &lt; l; i ++) &#123; &#125;&#125;  </span><br><span class="line">        &#123;&#123; val = it.list; &#125;&#125;  </span><br><span class="line">        &lt;li&gt;&#123;&#123;=val[i].index&#125;&#125;. 用户: &#123;&#123;=val[i].user&#125;&#125;/ 网站：&#123;&#123;=val[i].site&#125;&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;&#123; &#125; &#125;&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!--juicer 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;juicer&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;@each list as val&#125;  </span><br><span class="line">        &lt;li&gt;</span><br><span class="line">val.index.用户:</span><br><span class="line">&#123;val.user&#125;/ 网站：$$&#123;val.site&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;@/each&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- artTemplate 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;template&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &lt;% for (i = 0, l = list.length; i &lt; l; i ++) &#123; %&gt;  </span><br><span class="line">        &lt;li&gt;&lt;%=list[i].index%&gt;. 用户: &lt;%=list[i].user%&gt;/ 网站：&lt;%=list[i].site%&gt;&lt;/li&gt;  </span><br><span class="line">    &lt;% &#125; %&gt;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- underscore 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;underscoreTemplate&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &lt;% for (var i = 0, l = list.length; i &lt; l; i ++) &#123; %&gt;  </span><br><span class="line">        &lt;li&gt;&lt;%=list[i].index%&gt;. 用户: &lt;%=list[i].user%&gt;/ 网站：&lt;%=list[i].site%&gt;&lt;/li&gt;  </span><br><span class="line">    &lt;% &#125; %&gt;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!-- Handlebars 的模板 --&gt;  </span><br><span class="line">&lt;script id=&quot;Handlebars&quot; type=&quot;text/tmpl&quot;&gt;  </span><br><span class="line">&lt;ul&gt;  </span><br><span class="line">    &#123;&#123;#list&#125;&#125;  </span><br><span class="line">        &lt;li&gt;&#123;&#123;&#123;index&#125;&#125;&#125;. 用户: &#123;&#123;&#123;user&#125;&#125;&#125;/ 网站：&#123;&#123;&#123;site&#125;&#125;&#125;&lt;/li&gt;  </span><br><span class="line">    &#123;&#123;/list&#125;&#125;  </span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>4 错误处理/调试 - 影响开发效率和维护难度<br>artTemplate 有详细的错误提示信息，查错方便，不影响后面代码的继续执行<br>kissy template 错误信息直接输出在页面，而不是在控制台。不影响后面代码的继续执行<br>juicer 控制台提示模板渲染出错，不影响后面代码的继续执行<br>mustache 没有任何错误信息，不影响后面代码的继续执行<br>其他控制台报脚本错误 js执行中断，不知道是哪里出错</p>
<p>5 安全- 是否防止XSS<br>以上几个模板引擎全都支持html转义，防止XSS</p>
<p>最终的一个对比：</p>
<p><img src="http://img.blog.csdn.net/20130515202850554" alt=""></p>
<hr>
<p>介绍 X 款 JavaScript 的模板引擎。（排名不分先后顺序）</p>
<ol>
<li><p>Mustache<br>基于javascript 实现的模板引擎,类似于 Microsoft’s jQuery template plugin,但更简单易用!</p>
</li>
<li><p>EasyTemplate<br>在使用过Freemarker模板后，感觉它的 语法比较朴实，平易近人，容易上手，于是决定按它的语法风格实现一个前端的 模板引擎，这就有了下面的EasyTemplate! EasyTemplate模板的函数大小为1.34k（未压缩），暂时只实现了 list，list index，if elseif else等功能，应该可以满足大部分的使用需求了。 EasyTemplate模板 引擎的解析速度测试，渲染1000行数据，在不同的浏览器中，平均速度大约在30豪秒以内（测试机器性能较弱）。</p>
</li>
<li><p>jSmart<br>jSmart 是著名的 PHP 模板引擎 Smarty 的 JavaScript 移植版本。</p>
</li>
<li><p>Trimpath<br>Trimpath JavaScript 是个轻量级的，基于JavaScript的，跨浏览器，采用APL/GPL开放源代码协议的，可以让你轻松进行基于模板编程方式的纯JS引擎。新浪的评论系统使用的就是此模板。</p>
</li>
<li><p>jade<br>Jade是受Haml的影响以JavaScript实现用于node的高性能模板引擎。</p>
</li>
<li><p>Hogan.js<br>来自 Twitter 的 JavaScript 模板引擎。</p>
</li>
<li><p>Handlebars<br>Handlebars 是一个 JavaScript 的页面模板库<br><img src="http://www.php100.com/uploadfile/2012/0416/20120416095203993.jpg" alt=""></p>
</li>
<li><p>doT.js<br>doT.js 包含为浏览器和Node.js 准备的 JavaScript 模板引擎。</p>
</li>
<li><p>dom.js<br>dom.js 是一款可用在客户端和服务器端的 JavaScript 模板引擎</p>
</li>
<li><p>Plates.js<br>Plates.js 是一个轻量级、无逻辑、DSL 的 JavaScript 模板引擎。<br><img src="http://www.php100.com/uploadfile/2012/0416/20120416095203157.png" alt=""></p>
</li>
<li><p>ICanHaz.js<br>ICanHaz.js 是一个简单而且功能强大的客户端的 JavaScript 模板引擎。</p>
</li>
<li><p>dotpl-js<br>Dotpl-JS 是一个纯javascript模板引擎,支持IF和FOR关键字，多循环衔套及字段渲染，跨浏览器支持。是一个实用的javascipt工具,页面静态化利器!</p>
</li>
<li><p>EJS<br>EJS 可以将数据和模板合并然后生成 HTML 文本。</p>
</li>
</ol>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法/" >
  阮一峰的网络日志*Javascript模块化编程（三）require.js的用法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（三）：require.js的用法/"><span class="article-date">
  2016-05-31
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h1 id="Javascript模块化编程（三）require-js的用法"><a href="#Javascript模块化编程（三）require-js的用法" class="headerlink" title="Javascript模块化编程（三）require.js的用法"></a>Javascript模块化编程（三）require.js的用法</h1><p>原文地址：<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a></p>
<h2 id="一、为什么要用require-js？"><a href="#一、为什么要用require-js？" class="headerlink" title="一、为什么要用require.js？"></a>一、为什么要用require.js？</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码依次加载多个js文件。<br>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。<br>require.js的诞生，就是为了解决这两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![](http://image.beekka.com/blog/201211/bg2012110701.png)</span><br><span class="line">	（1）实现js文件的异步加载，避免网页失去响应；</span><br><span class="line">　　（2）管理模块之间的依赖性，便于代码的编写和维护。</span><br></pre></td></tr></table></figure>
<h2 id="二、require-js的加载"><a href="#二、require-js的加载" class="headerlink" title="二、require.js的加载"></a>二、require.js的加载</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。</p>
<p>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h2 id="三、主模块的写法"><a href="#三、主模块的写法" class="headerlink" title="三、主模块的写法"></a>三、主模块的写法</h2><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。</p>
<p>下面就来看，怎么写main.js。</p>
<p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　alert(&quot;加载成功！&quot;);</span><br></pre></td></tr></table></figure>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>下面，我们看一个实际的例子。</p>
<p>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</span><br><span class="line">　　　　// some code here</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h2 id="四、模块的加载"><a href="#四、模块的加载" class="headerlink" title="四、模块的加载"></a>四、模块的加载</h2><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。</p>
<p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　baseUrl: &quot;js/lib&quot;,</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</span><br><span class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</span><br><span class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个<a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="external">优化工具</a>，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h2 id="五、AMD模块的写法"><a href="#五、AMD模块的写法" class="headerlink" title="五、AMD模块的写法"></a>五、AMD模块的写法</h2><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>假定现在有一个math.js文件，它定义了一个math模块。那么,math.js就要这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　// math.js</span><br><span class="line">　　define(function ()&#123;</span><br><span class="line">　　　　var add = function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>加载方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// main.js</span><br><span class="line">　　require([&apos;math&apos;], function (math)&#123;</span><br><span class="line">　　　　alert(math.add(1,1));</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　define([&apos;myLib&apos;], function(myLib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　myLib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h2 id="六、加载非规范的模块"><a href="#六、加载非规范的模块" class="headerlink" title="六、加载非规范的模块"></a>六、加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>回答是可以的。</p>
<p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　require.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　&apos;underscore&apos;:&#123;</span><br><span class="line">　　　　　　　　exports: &apos;_&apos;</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　&apos;backbone&apos;: &#123;</span><br><span class="line">　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],</span><br><span class="line">　　　　　　　　exports: &apos;Backbone&apos;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义<strong>（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</strong></p>
<p>比如，jQuery的插件可以这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　shim: &#123;</span><br><span class="line">　　　　&apos;jquery.scroll&apos;: &#123;</span><br><span class="line">　　　　　　deps: [&apos;jquery&apos;],</span><br><span class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、require-js插件"><a href="#七、require-js插件" class="headerlink" title="七、require.js插件"></a>七、require.js插件</h2><p>require.js还提供一系列<a href="https://github.com/requirejs/requirejs/wiki/Plugins" target="_blank" rel="external">插件</a>，实现一些特定的功能。</p>
<p>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;domready!&apos;], function (doc)&#123;</span><br><span class="line">　　　　// called once the DOM is ready</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　define([</span><br><span class="line">　　　　&apos;text!review.txt&apos;,</span><br><span class="line">　　　　&apos;image!cat.jpg&apos;</span><br><span class="line">　　　　],</span><br><span class="line"></span><br><span class="line">　　　　function(review,cat)&#123;</span><br><span class="line">　　　　　　console.log(review);</span><br><span class="line">　　　　　　document.body.appendChild(cat);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　);</span><br></pre></td></tr></table></figure>
<p>类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范/" >
  阮一峰的网络日志*Javascript模块化编程（二）AMD规范
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（二）：AMD规范/"><span class="article-date">
  2016-05-31
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h1 id="Javascript模块化编程（二）AMD规范"><a href="#Javascript模块化编程（二）AMD规范" class="headerlink" title="Javascript模块化编程（二）AMD规范"></a>Javascript模块化编程（二）AMD规范</h1><p>原文地址 <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a></p>
<h2 id="七、模块的规范"><a href="#七、模块的规范" class="headerlink" title="七、模块的规范"></a>七、模块的规范</h2><p>先想一想，为什么模块很重要？</p>
<p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p>
<p>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。</p>
<p>目前，通行的Javascript模块规范共有两种：<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>。这里主要介绍AMD，但是要先从CommonJS讲起。</p>
<h2 id="八、CommonJS"><a href="#八、CommonJS" class="headerlink" title="八、CommonJS"></a>八、CommonJS</h2><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p><img src="http://image.beekka.com/blog/201210/bg2012103002.jpg" alt=""></p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br></pre></td></tr></table></figure></p>
<p>然后，就可以调用模块提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br><span class="line">　　math.add(2,3); // 5</span><br></pre></td></tr></table></figure>
<p>因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。</p>
<p>#九、浏览器环境</p>
<p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　var math = require(&apos;math&apos;);</span><br><span class="line">　　math.add(2, 3);</span><br></pre></td></tr></table></figure>
<p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h2 id="十、AMD"><a href="#十、AMD" class="headerlink" title="十、AMD"></a>十、AMD</h2><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　require([module], callback);</span><br></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">　　　　math.add(2, 3);</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="external">curl.js</a>。本系列的第三部分，将通过介绍require.js，进一步讲解AMD的用法，以及如何将模块化编程投入实战。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法/" >
  阮一峰的网络日志*Javascript模块化编程（一）模块的写法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/31/[阮一峰的网络日志]Javascript模块化编程（一）：模块的写法/"><span class="article-date">
  2016-05-31
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化编程/">模块化编程</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>原文地址：<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>
<h1 id="Javascript模块化编程（一）模块的写法"><a href="#Javascript模块化编程（一）模块的写法" class="headerlink" title="Javascript模块化编程（一）模块的写法"></a>Javascript模块化编程（一）模块的写法</h1><p>网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。</p>
<p>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还未广泛应用。）</p>
<h2 id="一、原始写法"><a href="#一、原始写法" class="headerlink" title="一、原始写法"></a>一、原始写法</h2><p>模块就是实现特定功能的一组方法。</p>
<p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　function m1()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line">　　function m2()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。</p>
<p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<p>##二、对象写法<br>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = new Object(&#123;</span><br><span class="line">　　　　_count : 0,</span><br><span class="line">　　　　m1 : function ()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　m2 : function ()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　module1.m1();</span><br></pre></td></tr></table></figure>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　module1._count = 5;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、立即执行函数写法"><a href="#三、立即执行函数写法" class="headerlink" title="三、立即执行函数写法"></a>三、立即执行函数写法</h2><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function()&#123;</span><br><span class="line">　　　　var _count = 0;</span><br><span class="line">　　　　var m1 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　var m2 = function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　m1 : m1,</span><br><span class="line">　　　　　　m2 : m2</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;)();</span><br></pre></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的_count变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></p>
<p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<h2 id="四、放大模式"><a href="#四、放大模式" class="headerlink" title="四、放大模式"></a>四、放大模式</h2><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function (mod)&#123;</span><br><span class="line">　　　　mod.m3 = function () &#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return mod;</span><br><span class="line">　　&#125;)(module1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<h2 id="五、宽放大模式（Loose-augmentation）"><a href="#五、宽放大模式（Loose-augmentation）" class="headerlink" title="五、宽放大模式（Loose augmentation）"></a>五、宽放大模式（Loose augmentation）</h2><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = ( function (mod)&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　　　return mod;</span><br><span class="line">　　&#125;)(window.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<h2 id="六、输入全局变量"><a href="#六、输入全局变量" class="headerlink" title="六、输入全局变量"></a>六、输入全局变量</h2><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　var module1 = (function ($, YAHOO) &#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">《JavaScript Module Pattern: In-Depth》</a>。</p>
<p>这个系列的第二部分，将讨论如何在浏览器环境组织不同的模块、管理模块之间的依赖性。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/Javascript的this用法/" >
  Javascript的this用法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/Javascript的this用法/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this/">this</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>Javascript的this用法</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">转载-阮一峰的网络日志</a></p>
<ul>
<li>this是Javascript语言的一个关键字。</li>
</ul>
<p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。<br>下面分四种情况，详细讨论this的用法。</p>
<h3 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h3><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。<br>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p>
<p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　test(); // 1</span><br></pre></td></tr></table></figure></p>
<p>运行结果还是1。再变一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 1;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 0;</span><br><span class="line">　　&#125;</span><br><span class="line">　　test();</span><br><span class="line">　　alert(x); //0</span><br></pre></td></tr></table></figure></p>
<h3 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h3><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = &#123;&#125;;</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m(); // 1</span><br></pre></td></tr></table></figure></p>
<h3 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 作为构造函数调用</h3><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(o.x); // 1</span><br></pre></td></tr></table></figure></p>
<p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 2;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(x); //2</span><br></pre></td></tr></table></figure></p>
<p>运行结果为2，表明全局变量x的值根本没变。</p>
<h3 id="情况四-apply调用"><a href="#情况四-apply调用" class="headerlink" title="情况四 apply调用"></a>情况四 apply调用</h3><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　var x = 0;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o=&#123;&#125;;</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m.apply(); //0</span><br></pre></td></tr></table></figure></p>
<p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。<br>如果把最后一行代码修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　o.m.apply(o); //1</span><br></pre></td></tr></table></figure></p>
<p>运行结果就变成了1，证明了这时this代表的是对象o。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/12种不宜使用的Javascript语法/" >
  12种不宜使用的Javascript语法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/12种不宜使用的Javascript语法/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>12种不宜使用的Javascript语法</p>
<p><a href="">转-阮一峰的网络日志</a></p>
<p>《Javascript语言精粹》的附录B中，Douglas Crockford列出了12种应该避免使用的Javascript语法，非常值得推广。</p>
<ol>
<li>==<br>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。<br>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：<br>　　false == ‘false’<br>　　false == undefined<br>　　false == null<br>　　null == undefined<br>　　0 == ‘’<br>前三个是false，后两个是true。</li>
<li>with<br>with的本意是减少键盘输入。比如<br>　　obj.a = obj.b;<br>　　obj.c = obj.d;<br>可以简写成<br>　　with(obj) {<br>　　　　a = b;<br>　　　　c = d;<br>　　}<br>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</li>
<li>eval<br>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。<br>eval能够做到的事情，不用它也能做到。比如<br>　　eval(“myValue = myObject.” + myKey + “;”);<br>可以直接写成<br>　　myValue = myObject[myKey];<br>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行。</li>
<li>continue<br>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</li>
<li>switch 贯穿<br>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如<br>　　switch(n) {<br>　　　　case 1:<br>　　　　case 2:<br>　　　　　　break;<br>　　}<br>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。<br>　　switch(n) {<br>　　　　case 1:<br>　　　　　　break;<br>　　　　case 2:<br>　　　　　　break;<br>　　}</li>
<li>单行的块结构<br>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如<br>　　if (ok) t = true;<br>甚至写成<br>　　if (ok)<br>　　　　t = true;<br>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。<br>　　if (ok){<br>　　　　t = true;<br>　　}</li>
<li>++和–<br>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</li>
<li>位运算符<br>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。<br>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</li>
<li>function语句<br>在Javascript中定义一个函数，有两种写法：<br>　　function foo() { }<br>和<br>　　var foo = function () { }<br>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</li>
<li>基本数据类型的包装对象<br>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：<br>　　new String(“Hello World”);<br>　　new Number(2000);<br>　　new Boolean(false);<br>这样写完全没有必要，而且非常费解，因此建议不要使用。<br>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</li>
<li>new语句<br>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。<br>类是这样定义的：<br>　　var Cat = function (name) {<br>　　　　this.name = name;<br>　　　　this.saying = ‘meow’ ;<br>　　}<br>然后，再生成一个对象<br>　　var myCat = new Cat(‘mimi’);<br>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。<br>Douglas Crockford给出了一个函数：<br>　　Object.beget = function (o) {<br>　　　　var F = function (o) {};<br>　　　　F.prototype = o ;<br>　　　　return new F;<br>　　};<br>创建对象时就利用这个函数，对原型对象进行操作：<br>　　var Cat = {<br>　　　　name:’’,<br>　　　　saying:’meow’<br>　　};<br>　　var myCat = Object.beget(Cat);<br>对象生成后，可以自行对相关属性进行赋值：<br>　　myCat.name = ‘mimi’;</li>
<li>void<br>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。<br>　　void 0; // undefined<br>这个命令没什么用，而且很令人困惑，建议避免使用。</li>
</ol>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/14/Backbone入门/" >
  Backbone入门
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/14/Backbone入门/"><span class="article-date">
  2016-05-14
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/js/">js</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Backbone/">Backbone</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p> Backbone入门（Model,Collection）<br>原文地址：<a href="http://blog.csdn.net/feng88724/article/details/7290338" target="_blank" rel="external">http://blog.csdn.net/feng88724/article/details/7290338</a></p>
<pre><code>Backbone 是一个前端 JS 代码 MVC 框架，被著名的 37signals 用来构建他们的移动客户端。它不可取代 jQuery，不可取代现有的 template 库。而是和这些结合起来构建复杂的 web 前端交互应用。

如果项目涉及大量的 JavaScript 代码，实现很多复杂的前端交互功能，首先你会想到把数据和展示分离。使用 Jquery 的 selector 和 callback 可以轻松做到这点。但是对于富客户端的WEB应用大量代码的结构化组织非常必要。
</code></pre><p>Backbone 就提供了 javascript 代码的组织的功能。Backbone 主要包括 models, collections, views 和 events, controller 。<br>Backbone官方网站： <a href="http://backbonejs.org/" target="_blank" rel="external">http://backbonejs.org/</a></p>
<p>###Model（模型）<br>Models 用来创建数据，校验数据，存储数据到服务器端。Models 还可以绑定事件。比如用户动作变化触发 models 的 change 事件，所有展示此model 数据的 views 都会接收到 这个 change 事件，进行重绘。<br>最简单的定义如下：<br>var Game = Backbone.Model.extend({});  </p>
<p>稍微发杂一点</p>
<p>var Game = Backbone.Model.extend({<br>        initialize: function(){<br>            alert(“Oh hey! “);<br>        },<br>          defaults: {<br>            name: ‘Default title’,<br>            releaseDate: 2011,<br>        }<br>    });  </p>
<p>initialize 相当于构造方法，初始化时调用<br>简单实用：</p>
<p>// Create a new game<br>var portal = new Game({ name: “Portal 2”, releaseDate: 2011});  </p>
<p>// release will hold the releaseDate value – 2011 here<br>var release = portal.get(‘releaseDate’);  </p>
<p>// Changes the name attribute<br>portal.set({ name: “Portal 2 by Valve”});  </p>
<p>此时数据还都在内存中，需要执行save方法才会提交到服务器。（还未理解）<br>portal.save();  </p>
<p>Collection（集合）<br>实际上，相当于Model的集合。定义方法如下：</p>
<p>var GamesCollection = Backbone.Collection.extend({<br>  model : Game,<br>  }<br>});  </p>
<p>需要注意的是，定义Collection的时候，一定要指定Model。 下面让我们为这个集合添加一个方法，如下：</p>
<p>var GamesCollection = Backbone.Collection.extend({<br>  model : Game,<br>  old : function() {<br>    return this.filter(function(game) {<br>      return game.get(‘releaseDate’) &lt; 2009;<br>    });<br>  }<br>  }<br>});  </p>
<p>集合的使用方法如下：</p>
<p>var games = new GamesCollection<br>games.get(0);  </p>
<p>当然，也可以动态构成集合，如下：</p>
<p>var GamesCollection = Backbone.Collection.extend({<br>  model : Game,<br>  url: ‘/games’<br>  }<br>});  </p>
<p>var games = new GamesCollection<br>games.fetch();  </p>
<p>这边的url告诉collection到哪去获取数据，fetch方法会发出一个异步请求到服务器，从而获取数据构成集合。（fetch实际上就是调用jquery的ajax方法）</p>
<p>参考：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/getting-started-with-backbone-js/" target="_blank" rel="external">http://net.tutsplus.com/tutorials/javascript-ajax/getting-started-with-backbone-js/</a></p>

        
      </div>
    </div>

  
    </div>
  



  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/categories/技术/js/page/2/">2</a><a class="page-number" href="/categories/技术/js/page/3/">3</a><a class="extend next" rel="next" href="/categories/技术/js/page/2/">下一页</a>
  </div>




          <div class="main-footer">
  
    © 2016 findmoon-白色蜗牛 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
