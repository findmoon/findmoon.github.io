<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    分类: 网络
  
</title>

<meta name="description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
<meta property="og:type" content="website">
<meta property="og:title" content="findmoon-白色蜗牛">
<meta property="og:url" content="//findmoon.github.io/index.html/categories/技术/网络/index.html">
<meta property="og:site_name" content="findmoon-白色蜗牛">
<meta property="og:description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="findmoon-白色蜗牛">
<meta name="twitter:description" content="人生是一场不断的转换，我们总是不断地试着所向披靡">




  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">findmoon-白色蜗牛</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">findmoon-白色蜗牛</a></h1>
    
      <p class="subtitle">
        一个试图专注于自身的成长者
      </p>
    
    <div class="info">
      <div class="content">
        
          <div class="description">人生是一场不断的转换，我们总是不断地试着所向披靡</div>
        
        
          <div class="author">findmoon</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="http://i2.piimg.com/81760750547ee122.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">134</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/方法-实例/">方法/实例</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">10</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFC/">BFC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backbone/">Backbone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3动画/">CSS3动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS解析域名/">DNS解析域名</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOCTYPE/">DOCTYPE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MV模式/">MV模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mocha/">Mocha</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP三次握手/">TCP三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNICODE-ASCII/">UNICODE/ASCII</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate/">animate()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animate动画队列/">animate动画队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/background-image/">background-image</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border/">border</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/border图形/">border图形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/box-shadow/">box-shadow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console-log/">console.log()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css属性/">css属性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css样式/">css样式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deferred/">deferred</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/delete/">delete</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-child/">first-child</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/first-of-type/">first-of-type</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/float/">float</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font-face/">font-face</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/form表单/">form表单</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/get/">get</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitbash/">gitbash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git错误/">git错误</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haslayout/">haslayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http状态码/">http状态码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inline-block/">inline-block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/input/">input</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/">instanceof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof-typeof/">instanceof/typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js严格模式/">js严格模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js加载/">js加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js模板引擎/">js模板引擎</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list-style/">list-style</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meta/">meta</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offset/">offset()</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/overflow/">overflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/placeholder/">placeholder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position/">position</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/position文档流/">position文档流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/post/">post</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scopechain/">scopechain</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stopImmediatePropagation/">stopImmediatePropagation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stringify/">stringify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/">this</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/">typeof</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/undefined/">undefined</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/url加载/">url加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zoom/">zoom</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码书写/">代码书写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/列表/">列表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画animation/">动画animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量/">变量</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同源跨域/">同源跨域</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字面量/">字面量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/库与架构/">库与架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学函数/">数学函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据包组装/">数据包组装</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方法/">方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记语言/">标记语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化编程/">模块化编程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/立即执行函数/">立即执行函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简历/">简历</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站访问/">网站访问</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/获取路径/">获取路径</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行内元素/">行内元素</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求/">跨域请求</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域请求处理方法/">跨域请求处理方法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择器/">选择器</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">162</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
            
              <li>
                <a href="/work" title="work">work</a>
              </li>
            
          
            
              <li>
                <a href="/about" title="about">about</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="http://findmoon.github.io/" title="findmoon" target="_blank" rel="external">findmoon</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/findmoon/findmoon.github.io" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <h1>网络</h1>


  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/26/单元测试框架与mock介绍/" >
  单元测试框架与mock介绍*转
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/26/单元测试框架与mock介绍/"><span class="article-date">
  2016-05-26
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mock/">mock</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://baidutech.blog.51cto.com/4114344/743740/" target="_blank" rel="external">原文地址</a></p>
<h2 id="单元测试框架的优点与一些问题"><a href="#单元测试框架的优点与一些问题" class="headerlink" title="单元测试框架的优点与一些问题"></a>单元测试框架的优点与一些问题</h2><p>在单元测试中引入单测框架使得编写单测用例时，不需要再关注于如何驱动case的执行，如何收集结果，如何管理case集，只需要关注于如何写好单个测试用例即可；同时，在一些测试框架中通过提供丰富的断言集，公用方法，以及运行参数使得编写单个testcase的过程得到了最大的简化。</p>
<p>那这其中会存在什么样的疑问了？</p>
<p>我在单元测试框架中写一个TestCase，与我单独写一个cpp文件在main()方法里写测试代码有什么本质却别吗？用了单元测试框架，并没有解决我在对复杂系统做单测时遇到的问题。</p>
<p>没错，对于单个case这两者从本质上说是没有区别的。单元测试框架本身并没有告诉你如何去写TestCase，在这一点上他是没有提供任何帮助的。所以对于一些复杂的场景，只用单元测试框架是有点多少显得无能为力的。</p>
<p>使用单元测试框架往往适用于以下场景的测试：单个函数，一个class，或者几个功能相关class的测试，对于纯函数测试，接口级别的测试尤其适用，如房贷计算器公式的测试。</p>
<p>但是，对于一些复杂场景：<br> 被测对象依赖复杂，甚至无法简单new出这个对象<br> 对于一些failure场景的测试<br> 被测对象中涉及多线程合作<br> 被测对象通过消息与外界交互的场景<br> …</p>
<p>单纯依赖单测框架是无法实现单元测试的，而从某种意义上来说，这些场景反而是测试中的重点。</p>
<p>以分布式系统的测试为例，class 与 function级别的单元测试对整个系统的帮助不大，当然，这种单元测试对单个程序的质量有帮助；分布式系统测试的要点是测试进程间的交互：一个进程收到客户请求，该如何处理，然后转发给其他进程；收到响应之后，又修改并应答客户；同时分布式系统测试中通常更关注一些异常路径的测试，这些场景才是测试中的重点，也是难点所在。</p>
<p>Mock方法的引入通常能帮助我们解决以上场景中遇到的难题。</p>
<h2 id="Mock的引入带来了什么"><a href="#Mock的引入带来了什么" class="headerlink" title="Mock的引入带来了什么"></a>Mock的引入带来了什么</h2><p>在维基百科上这样描述Mock：In object-oriented programming, mock objects are simulated objects that mimic the behavior of real objects in controlled ways. A computer programmer typically creates a mock object to test the behavior of some other object, in much the same way that a car designer uses a crash test dummy to simulate the dynamic behavior. of a human in vehicle impacts.</p>
<p>Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。</p>
<p>引入Mock最大的优势在于：Mock的行为固定，它确保当你访问该Mock的某个方法时总是能够获得一个没有任何逻辑的直接就返回的预期结果。</p>
<p>Mock Object的使用通常会带来以下一些好处：</p>
<p> 隔绝其他模块出错引起本模块的测试错误。<br> 隔绝其他模块的开发状态，只要定义好接口，不用管他们开发有没有完成。<br> 一些速度较慢的操作，可以用Mock Object代替，快速返回。<br>对于分布式系统的测试，使用Mock Object会有另外两项很重要的收益：<br> 通过Mock Object可以将一些分布式测试转化为本地的测试<br> 将Mock用于压力测试，可以解决测试集群无法模拟线上集群大规模下的压力</p>
<h2 id="Mock的应用场景"><a href="#Mock的应用场景" class="headerlink" title="Mock的应用场景"></a>Mock的应用场景</h2><p>在使用Mock的过程中，发现Mock是有一些通用性的，对于一些应用场景，是非常适合使用Mock的：</p>
<blockquote>
<p>真实对象具有不可确定的行为(产生不可预测的结果，如股票的行情)<br> 真实对象很难被创建(比如具体的web容器)<br> 真实对象的某些行为很难触发(比如网络错误)<br> 真实情况令程序的运行速度很慢<br> 真实对象有用户界面<br> 测试需要询问真实对象它是如何被调用的(比如测试可能需要验证某个回调函数是否被调用了)<br> 真实对象实际上并不存在(当需要和其他开发小组，或者新的硬件系统打交道的时候，这是一个普遍的问题)<br>当然，也有一些不得不Mock的场景：<br> 一些比较难构造的Object：这类Object通常有很多依赖，在单元测试中构造出这样类通常花费的成本太大。<br> 执行操作的时间较长Object：有一些Object的操作费时，而被测对象依赖于这一个操作的执行结果，例如大文件写操作，数据的更新等等，出于测试的需求，通常将这类操作进行Mock。<br> 异常逻辑：一些异常的逻辑往往在正常测试中是很难触发的，通过Mock可以人为的控制触发异常逻辑。</p>
</blockquote>
<p>在一些压力测试的场景下，也不得不使用Mock，例如在分布式系统测试中，通常需要测试一些单点（如namenode，jobtracker）在压力场景下的工作是否正常。而通常测试集群在正常逻辑下无法提供足够的压力（主要原因是受限于机器数量），这时候就需要应用Mock去满足。</p>
<p>在这些场景下，我们应该如何去做Mock的工作了，一些现有的Mock工具可以帮助我们进行Mock工作。</p>
<h2 id="Mock工具的介绍"><a href="#Mock工具的介绍" class="headerlink" title="Mock工具的介绍"></a>Mock工具的介绍</h2><p>手动的构造 Mock 对象通常带来额外的编码量，而且这些为创建 Mock 对象而编写的代码很有可能引入错误。</p>
<p>目前，有许多开源项目对动态构建 Mock 对象提供了支持，这些项目能够根据现有的接口或类动态生成，这样不仅能避免额外的编码工作，同时也降低了引入错误的可能。</p>
<p>C++: GoogleMock <a href="http://code.google.com/p/googlemock/" target="_blank" rel="external">http://code.google.com/p/googlemock/</a><br>Java: EasyMock <a href="http://easymock.org/" target="_blank" rel="external">http://easymock.org/</a></p>
<p>通常Mock工具通过简单的方法对于给定的接口生成 Mock 对象的类库。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。通过这些Mock工具我们可以方便的构造 Mock 对象从而使单元测试顺利进行，能够应用于更加复杂的测试场景。</p>
<p>以EasyMock为例，通过 EasyMock，我们可以为指定的接口动态的创建 Mock 对象，并利用 Mock 对象来模拟协同模块，从而使单元测试顺利进行。这个过程大致可以划分为以下几个步骤：</p>
<p> 使用 EasyMock 生成 Mock 对象<br> 设定 Mock 对象的预期行为和输出<br> 将 Mock 对象切换到 Replay 状态<br> 调用 Mock 对象方法进行单元测试<br> 对 Mock 对象的行为进行验证</p>
<p>EasyMock的使用和原理： <a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/</a></p>
<p>EasyMock 后台处理的主要原理是利用 java.lang.reflect.Proxy 为指定的接口创建一个动态代理，这个动态代理，就是我们在编码中用到的 Mock 对象。EasyMock 还为这个动态代理提供了一个 InvocationHandler 接口的实现，这个实现类的主要功能就是将动态代理的预期行为记录在某个映射表中和在实际调用时从这个映射表中取出预期输出。</p>
<p>借助类似于EasyMock这样工具，大大降低了编写Mock对象的成本，通常来说Mock工具依赖于单元测试框架，为用户编写TestCase提供便利，但是本身依赖于单元测试框架去驱动，管理case，以及收集测试结果。例如EasyMock依赖于JUint，GoogleMock依赖于Gtest。</p>
<p>那么有了单元测试框架和相应的Mock工具就万事俱备了，还有什么样的问题？正如单元测试框架没有告诉你如何写TestCase一样，Mock工具也没有告诉你如何去选择Mock的点。</p>
<h2 id="如何选择恰当的mock点"><a href="#如何选择恰当的mock点" class="headerlink" title="如何选择恰当的mock点"></a>如何选择恰当的mock点</h2><p>对于Mock这里存在两个误区，1.是Mock的对象越多越好；2.Mock会引入巨大的工作量，通常得不偿失。这都是源于不恰当的Mock点的选取。</p>
<p>这里说的如何选择恰当的mock点，是说对于一个被测对象，我们应当在外围选择恰当的mock对象，以及需要mock的接口。因为对于任意一个对象，任意一段代码逻辑我们都是有办法进行Mock的，而Mock点选择直接决定了我们Mock的工作量以及测试效果。从另外一种意义上来说，不恰当Mock选择反而会对我们的测试产生误导，从而在后期的集成和系统测试中引入更多的问题。</p>
<p>在mock点的选择过程中，以下的一些点会是一些不错的选择</p>
<blockquote>
<p> 网络交互：如果两个被测模块之间是通过网络进行交互的，那么对于网络交互进行Mock通常是比较合适的，如RPC<br> 外部资源：比如文件系统、数据源，如果被测对象对此类外部资源依赖性非常强，而其行为的不可预测性很可能导致测试的随机失败，此类的外部资源也适合进行Mock。<br> UI：因为UI很多时候都是用户行为触发事件，系统本身只是对这些触发事件进行相应，对这类UI做Mock，往往能够实现很好的收益，很多基于关键字驱动的框架都是基于UI进行Mock的<br> 第三方API：当接口属于使用者，通过Mock该接口来确定测试使用者与接口的交互。</p>
</blockquote>
<p>当然如何做Mock一定是与被系统的特性精密关联的，一些强制性的约束和规范是不合适的。这里介绍几个做的比较好的mock的例子。</p>
<ol>
<li>杀毒软件更新部署模块的Mock</li>
</ol>
<p>这个例子源于一款杀毒产品的更新部署模块的测试。对于一个杀毒软件客户端而言，需要通过更新检查模块与病毒库Server进行交互，如果发现病毒库有更新则触发病毒库部署模块的最新病毒库的数据请求和部署工作，要求部署完成后杀毒软件客户端能够正常工作。</p>
<p><img src="/img/191927452.jpg" alt=""></p>
<p>对于这一场景的测试，当时受限于这样一个条件，通常的病毒库server通常最多一天只更新一次病毒库，也就是说如果使用真实的病毒库server，那么针对更新部署模块的测试一天只能被触发一次。这是测试中所不能容忍的，通过对病毒库server进行mock可以解决这个问题。</p>
<p>对于这个场景可以采取这样一种Mock方式：用一个本地文件夹来模拟病毒库server，选择更新部署模块与病毒库server之间交互的两个函数checkVersion()，reqData()函数进行Mock。</p>
<p>checkVersion()工作原先的工作是检查病毒库Server的版本号，以决定是否触发更新，将其行为Mock为检查一个本地文件夹中病毒库的版本号；reqData()原有的行为是从病毒库Server拖取病毒库文件，将其Mock为从本地文件夹中拖取病毒库文件。通过这种方式我们用一个本地文件夹Mock病毒库Server的行为，其带来的产出是：我们可以随意的触发病毒库更新操作以及各种异常。</p>
<p>通过这种方式发现了一个在更新部署过程中，病毒库Server的病毒库版本发生改变造成出错的严重bug，这个是在原有一天才触发一次更新操作的情况下永远也无法发现的。</p>
<ol>
<li>分布式系统中对NameNode模块的测试</li>
</ol>
<p><img src="/img/191936107.jpg" alt=""></p>
<p>在测试NameNode模块的过程中存在这样一个问题，在正常逻辑无压力条件下NameNode模块都是工作正常的。但是线上集群在大压力的情况下，是有可能触发NameNode的问题的。但是原有的测试方法下，我们是无法对NameNode模拟大压力的场景的（因为NameNode的压力主要来源于DateNode数量，而我们测试集群是远远无法达到线上几千台机器的规模的），而NameNode单点的性能瓶颈问题恰恰是测试的重点，真实的DataNode是无法满足测试需求的，我们必须对DataNode进行Mock。</p>
<p><img src="/img/191948572.jpg" alt=""></p>
<p>如何对DateNode进行Mock了，最直观的想法是选择NameNode与DataNode之间的交互接口进行Mock，也就是他们之间的RPC交互，但是由于NameNode与DataNode之间的交互信息种类很多，所以其实这并不是一种很好的选择。<br>换个角度来想，NameNode之上的压力是源于对HDFS的读写操作造成的NameNode上元数据的维护，也就是说，对于NameNode而言，其实他并不关心数据到底写到哪里去了，只关心数据是否读写成功。如果是这种场景Mock就可以变的简单了，我们可以直接将DataNode上对块的操作进行mock，比如，对一次写请求，DataNode并不触发真实的写操作，而直接返回成功。通过这种方式，DataNode去除了执行功能，只保留了消息交互功能，间接的实现了我们的测试需求，且工作量比之第一种方案小很多。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/js跨域总结与解决办法/" >
  js跨域总结与解决办法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/js跨域总结与解决办法/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域请求/">跨域请求</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">原文链接</a><br>什么是跨域<br>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：</p>
<p>首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表：<br><img src="/img/php/QQ截图20160529204200.png" alt=""></p>
<p>特别注意两点：<br>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，<br>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。<br>接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：<a href="http://developer.yahoo.com/javascript/howto-proxy.html" target="_blank" rel="external">《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》</a></p>
<p>1、document.domain+iframe的设置<br>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在<a href="http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain" target="_blank" rel="external">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain</a> = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！代码如下：</p>
<p>www.a.com上的a.html</p>
<p>document.domain = ‘a.com’;<br>var ifr = document.createElement(‘iframe’);<br>ifr.src = ‘<a href="http://script.a.com/b.html" target="_blank" rel="external">http://script.a.com/b.html</a>‘;<br>ifr.style.display = ‘none’;<br>document.body.appendChild(ifr);<br>ifr.onload = function(){<br>    var doc = ifr.contentDocument || ifr.contentWindow.document;<br>    // 在这里操纵b.html<br>    alert(doc.getElementsByTagName(“h1”)[0].childNodes[0].nodeValue);<br>};<br>script.a.com上的b.html</p>
<p>document.domain = ‘a.com’;<br>这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。</p>
<p>备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。</p>
<p>问题：<br>1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。<br>2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。<br>2、动态创建script<br>虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility</p>
<p>这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。</p>
<p>js.onload = js.onreadystatechange = function() {<br>    if (!this.readyState || this.readyState === ‘loaded’ || this.readyState === ‘complete’) {<br>        // callback在此处执行<br>        js.onload = js.onreadystatechange = null;<br>    }<br>};<br>3、利用iframe和location.hash<br>这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： <a href="http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下：" target="_blank" rel="external">http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下：</a></p>
<p>先是a.com下的文件cs1.html文件：</p>
<p>function startRequest(){<br>    var ifr = document.createElement(‘iframe’);<br>    ifr.style.display = ‘none’;<br>    ifr.src = ‘<a href="http://www.cnblogs.com/lab/cscript/cs2.html#paramdo" target="_blank" rel="external">http://www.cnblogs.com/lab/cscript/cs2.html#paramdo</a>‘;<br>    document.body.appendChild(ifr);<br>}</p>
<p>function checkHash() {<br>    try {<br>        var data = location.hash ? location.hash.substring(1) : ‘’;<br>        if (console.log) {<br>            console.log(‘Now the data is ‘+data);<br>        }<br>    } catch(e) {};<br>}<br>setInterval(checkHash, 2000);<br>cnblogs.com域名下的cs2.html:</p>
<p>//模拟一个简单的参数处理操作<br>switch(location.hash){<br>    case ‘#paramdo’:<br>        callBack();<br>        break;<br>    case ‘#paramset’:<br>        //do something……<br>        break;<br>}</p>
<p>function callBack(){<br>    try {<br>        parent.location.hash = ‘somedata’;<br>    } catch (e) {<br>        // ie、chrome的安全机制无法修改parent.location.hash，<br>        // 所以要利用一个中间的cnblogs域下的代理iframe<br>        var ifrproxy = document.createElement(‘iframe’);<br>        ifrproxy.style.display = ‘none’;<br>        ifrproxy.src = ‘<a href="http://a.com/test/cscript/cs3.html#somedata" target="_blank" rel="external">http://a.com/test/cscript/cs3.html#somedata</a>‘;    // 注意该文件在”a.com”域下<br>        document.body.appendChild(ifrproxy);<br>    }<br>}<br>a.com下的域名cs3.html</p>
<p>//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值<br>parent.parent.location.hash = self.location.hash.substring(1);<br>当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……</p>
<p>4、window.name实现的跨域数据传输<br>文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输。</p>
<p>5、使用HTML5 postMessage<br>HTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。</p>
<p>otherWindow.postMessage(message, targetOrigin);<br>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message: 所要发送的数据，string类型。<br>targetOrigin: 用于限制otherWindow，“*”表示不作限制<br>a.com/index.html中的代码：</p>
<p><iframe id="ifr" src="b.com/index.html"></iframe></p>
<p><script type="text/javascript"><br>window.onload = function() {<br>    var ifr = document.getElementById(‘ifr’);<br>    var targetOrigin = ‘<a href="http://b.com">http://b.com</a>‘;  // 若写成’<a href="http://b.com/c/proxy.html&#39;效果一样">http://b.com/c/proxy.html&#39;效果一样</a><br>                                        // 若写成’<a href="http://c.com&#39;就不会执行postMessage了">http://c.com&#39;就不会执行postMessage了</a><br>    ifr.contentWindow.postMessage(‘I was there!’, targetOrigin);<br>};<br></script><br>b.com/index.html中的代码：</p>
<p><script type="text/javascript"><br>    window.addEventListener(‘message’, function(event){<br>        // 通过origin属性判断消息来源地址<br>        if (event.origin == ‘<a href="http://a.com">http://a.com</a>‘) {<br>            alert(event.data);    // 弹出”I was there!”<br>            alert(event.source);  // 对a.com、index.html中window对象的引用<br>                                  // 但由于同源策略，这里event.source不可以访问window对象<br>        }<br>    }, false);<br></script><br>参考文章：《精通HTML5编程》第五章——跨文档消息机制、<a href="https://developer.mozilla.org/en/dom/window.postmessage" target="_blank" rel="external">https://developer.mozilla.org/en/dom/window.postmessage</a></p>
<p>6、利用flash<br>这是从YUI3的IO组件中看到的办法，具体可见<a href="http://developer.yahoo.com/yui/3/io/。" target="_blank" rel="external">http://developer.yahoo.com/yui/3/io/。</a><br>可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/js跨域请求/" >
  js跨域请求
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/js跨域请求/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域请求/">跨域请求</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://blog.csdn.net/chosen0ne/article/details/7333626" target="_blank" rel="external">js跨域请求,原文地址</a></p>
<ol>
<li><p>同源策略</p>
<pre><code>所有的浏览器都遵守同源策略，这个策略能够保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，这就使浏览器隔离了来自不同源的内容，防止它们互相操作。所谓同源是指协议、域名和端口都一致的情况。举例来说，首先在Nginx上配置两个虚拟主机，一个监听80端口，另一个监听81端口：
</code></pre><p>[plain] view plain copy print?<br>server {  </p>
<pre><code>listen 80;  
server_name localhost;  

location / {  
    root   D:/dev/workspace;  
            index  index.html index.htm;  
}  

location ~ \.php$ {  
    # 委托给后端的php  
    }  
</code></pre><p> }  </p>
<pre><code>81端口的server配置是类似的，只是端口不同而已，所以通过80和81端口会访问到相同的东西。写两个php，一个是用于页面展示的show_person.php，另一个是用于生成json数据的person.php。
</code></pre><p>[php] view plain copy print?<br>// show_person.php  </p>
</li>
</ol>
<html><br>    <head><br>        <script type="text/javascript" src="js/jquery.min.js"></script><br>        <script type="text/javascript"><br>            function sayHello(person){<br>                alert(person.name + ‘, your age is ‘ + person.age);<br>            }<br>           // 通过jQuery的ajax请求person.php的数据<br>            $.getJSON(‘<a href="http://localhost:80/MongoTest/person.php">http://localhost:80/MongoTest/person.php</a>‘, function(data){<br>                sayHello(data);<br>            });<br>        </script><br>    </head><br>    <body><br>    </body><br></html>  

<p>[php] view plain copy print?<br>// person.php  </p>
<p>&lt;?php<br>$person = array(‘name’ =&gt; ‘kobe’, ‘age’ =&gt; 34);<br>echo json_encode($person);<br>?&gt;<br>        注意show_person.php中通过jQuery的getJSON请求<a href="http://localhost:80/MongoTest/person.php，这里是80端口。" target="_blank" rel="external">http://localhost:80/MongoTest/person.php，这里是80端口。</a><br>然后先访问80端口试试，键入url：<a href="http://localhost/cross_domain/show_person.php。会弹出对话框，显示：kobe" target="_blank" rel="external">http://localhost/cross_domain/show_person.php。会弹出对话框，显示：kobe</a>, your age is 34。<br>        然后再访问81端口，<a href="http://localhost:81/cross_domain/show_person.php，结果出错：" target="_blank" rel="external">http://localhost:81/cross_domain/show_person.php，结果出错：</a><br>XMLHttpRequest cannot load<a href="http://localhost/MongoTest/person.php" target="_blank" rel="external">http://localhost/MongoTest/person.php</a>. Origin <a href="http://localhost:81" target="_blank" rel="external">http://localhost:81</a> is not allowed by Access-Control-Allow-Origin.</p>
<pre><code>这就是同源策略作用的效果。因为浏览器中访问的是81端口的内容，而show_person.php中请求的是80端口，所以请求的是不同源的内容，浏览器直接阻止这次请求。
</code></pre><ol>
<li>打破同源策略的限制<pre><code>浏览器会阻止ajax请求非同源的内容，但没有限制&lt;script&gt;标签来访问非同源的内容，也没有限制使用动态添加&lt;script&gt;标签，所以可以采用这种方式打破这种限制。先测试下&lt;script&gt;访问非同源的内容，修改show_person.php，如下：
</code></pre>[php] view plain copy print?<br>// show_person.php  </li>
</ol>
<p><html><br>    <head><br>        <script type="text/javascript" src="js/jquery.min.js"></script><br>        <script type="text/javascript"><br>            function sayHello(person){<br>                alert(person.name + ‘, your age is ‘ + person.age);<br>            }<br>        </script>  </head></html></p>
<pre><code>    &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:80/MongoTest/person.php&quot; &gt;&lt;/script&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;/body&gt;  
</code></pre><p><br>        还需要对person.php略微修改，以实现函数调用：<br>[php] view plain copy print?<br>// person.php  </p>
<p>&lt;?php<br>$person = array(‘name’ =&gt; ‘kobe’, ‘age’ =&gt; 34);<br>echo ‘sayHello(‘.json_encode($person).’)’;<br>?&gt;<br>        实际上，通过<script>标签就是将远程请求来的数据插入到<script></script>之间。访问80和81端口，都会得到希望得到的结果：kobe, your age is 34。<br>        下面就看一下，动态添加<script>标签实现跨域请求数据。修改show_person.php：<br>[php] view plain copy print?<br>// show_person.php  </p>
<p><html><br>    <head><br>        <script type="text/javascript" src="js/jquery.min.js"></script><br>        <script type="text/javascript"><br>            function sayHello(person){<br>                alert(person.name + ‘, your age is ‘ + person.age);<br>            }<br>                // 通过callback参数指定回调函数<br>            var url = ‘<a href="http://localhost:80/MongoTest/person.php?callback=sayHello">http://localhost:80/MongoTest/person.php?callback=sayHello</a>‘;<br>            var script = document.createElement(‘script’);<br>            script.setAttribute(‘src’, url);<br>            document.getElementsByTagName(‘head’)[0].appendChild(script);<br>        </script><br>    <br>    <body><br>    </body><br><br>        person.php再做修改：<br>[php] view plain copy print?<br>// person.php  </p>
<p>&lt;?php<br>$person = array(‘name’ =&gt; ‘kobe’, ‘age’ =&gt; 34);<br>echo $_REQUEST[‘callback’].’(‘.json_encode($person).’)’;<br>?&gt;<br>        通过81端口访问，发现也会打印出结果。这就实现了跨域请求，可以通过firefox的firebug或者chrome的js控制台查看html元素发现，在head元素上多了一个<script>元素<br>[html] view plain copy print?</p>
<p><script src="http://localhost:80/MongoTest/person.php?callback=sayHello"></script>  </p>
<ol>
<li>JSONP<pre><code>实际上，上面的例子就是一个JSONP的简单实现。JSONP（JSON with Padding）就是服务器端和客户端互相协作以完成跨域请求的一种协议，客户端向服务器端发送请求并附带callback函数，服务器端返回相应的js代码，这个代码就是执行回调函数，参数就是服务器端返回的JSON数据。上面例子中的person.php就是服务端的简单实现，返回的响应内容是sayHello({&quot;name&quot;:&quot;kobe&quot;,&quot;age&quot;:34})，这段内容会被客户端插入到动态生成的script标签内部。
客户端在发起跨域请求时，需要制定具体的回调函数，比如这个请求http://localhost:80/MongoTest/person.php?callback=sayHello，callback就是回调函数，服务器端也要通过callback要提取回调函数名，所以具体的这个参数需要客户端和服务器端达成一致，否则不能实现跨域。
在jQuery中拥有对JSONP的支持，只要在使用jQuery.getJSON方法时传入的url的格式是url?callback=?即可，jQuery会自动的将?替换成具体的回调函数名。上面例子的功能，可以采用jQuery改写成：
</code></pre>[javascript] view plain copy print?<br>$.getJSON(‘<a href="http://localhost:80/MongoTest/person.php?callback=?" target="_blank" rel="external">http://localhost:80/MongoTest/person.php?callback=?</a>‘, function(data){<br> sayHello(data);<br>});  <pre><code>访问81端口，可以得到正确的响应。观察一下，发现person.php的响应内容是：
        jQuery17103600438670255244_1331202380099({&quot;name&quot;:&quot;kobe&quot;,&quot;age&quot;:34})
前面的jQuery17103600438670255244_1331202380099就是jQuery动态生成的回调函数名，然后在这个回调函数内容调用后面定义的匿名函数，并将得到的JSON数据传进去。jQuery可以优化JSONP请求，如果向同一个源发出请求，jQuery 就将其转化为普通 Ajax 请求。
</code></pre></li>
</ol>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/浏览器拦截跨域请求处理方法/" >
  浏览器拦截跨域请求处理方法
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/浏览器拦截跨域请求处理方法/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域请求处理方法/">跨域请求处理方法</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://my.oschina.net/lichaoqiang/blog/317823" target="_blank" rel="external">浏览器拦截跨域请求处理方法（同源策略不允许读取XXX上的远程资源）</a></p>
<p>解决此类问题，最直接的方法就是，就是给被请求的服务器，添加HTTP头响应头，这里提供两种添加HTTP头的方法：</p>
<ul>
<li>第一种，就是在程序中添加HTTP头：</li>
</ul>
<p>如： Response.Headers.Add(“Access-Control-Allow-Origin”, “<em>“);<br>  添加此段代码的目的很简单，也就是告诉浏览器，这个资源是运行远程所有域名访问的。当然，此处的</em>也可以替换为指定的域名，出于安全考虑，建议将*替换成指定的域名。</p>
<ul>
<li><p>第二种，就是在服务器上，添加HTTP响应头。在这里，我们就以IIS6.0为例：</p>
<p> 在被请求的网站上，设置HTTP头，添加“</p>
</li>
</ul>
<p>Access-Control-Allow-Origin<br>   值为:*或指定的域名。</p>
<p>  一般完成以上工作，就可以了。网上还有说在被请求服务器根目录下创建:”crossdomain.xml”的文件。内容格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;cross-domain-policy&gt;</span><br><span class="line">  &lt;allow-access-from domain=&quot;*&quot; /&gt;</span><br><span class="line">&lt;/cross-domain-policy&gt;</span><br></pre></td></tr></table></figure></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/套接字/" >
  套接字
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/套接字/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。<br><a href="http://blog.csdn.net/pitt_xiong/article/details/7466632" target="_blank" rel="external">套接字</a></p>
<p>　　套接字，简单的说就是通信双方的一种约定，用套接字中的相关函数来完成通信过程。应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了称为套接字(Socket)的接口。</p>
<pre><code>区分不同应用程序进程间的网络通信和连接，主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。Socket原意是 “插座”。通过将这3个参数结合起来，与一个“插座”Socket绑定，应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口、端口号，这样形成的整体就可以区别每一个套接字。关于WinSock中的套接字接发缓冲区的大小，可以通过WSA：getsockopt/setsockopt 来读取并设置。

Socket可以看成在两个程序进行通讯连接中的一个端点，一个程序将一段信息写入Socket中，该Socket将这段信息发送给另外一个Socket中，使这段信息能传送到其他程序中。一般一个server服务器对应很多客户端client连接，则服务器必须维护一张客户连接列表，每增加一个客户端连接服务器端都要新建一个套接字负责与新增客户端进行对话通信。

套接字主要有两类：流式套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM）。流类型的套接字是为需要可靠连接的应用程序设计的。这些程序通常使用连续的数据流。用于这种类型套接字的协议是TCP，适合FTP这类实现。流套接字是最常用的，一些众所周知的协议如HTTP、TCP、SMTP、POP3等都是用它。

 数据报套接字使用UDP做为下层协议，是无连接的，有一个最大缓冲区大小（数据包大小的最大值）。它是为那些需要发送小数据包，并且对可靠性要求不高的应用程序设计的。与流式套接字不同，数据报套接字并不保证数据会到达终端，也不保证它是以正确的顺序到来的。数据报套接字的传输效率相当高，它经常用于音频或视频应用程序。对这些程序来说，速度比可靠性更加重要。
</code></pre><p>以下为基于Socket的C/S通信模式图：</p>
<p>(1)同步和异步问题</p>
<pre><code>同步方式指发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式，它是一种阻塞模式；而异步指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式，它是非阻塞模式。
</code></pre><p> 关于同步和异步，参考以下实例：</p>
<p>举例1：手机的通讯</p>
<p>手机打电话时同步，发短信是异步。</p>
<p>举例2：请你吃饭</p>
<p>同步就是你叫我去吃饭，我听到了就和你去吃饭；如果没有听到，你就不停的叫，直到我告诉你听到了，才一起去吃饭。</p>
<p>异步就是你叫我，然后自己去吃饭，我得到消息后可能立即走，也可能等到下班才去吃饭。</p>
<p>举例3：Windows消息处理</p>
<p>SendMessage同步：把一条消息投放到创建hWnd窗口的线程的消息队列中，直到消息被处理完毕才返回。</p>
<p>PostMessage异步：把一条消息投放到创建hWnd窗口的线程的消息队列中，不等消息被处理就立即返回。</p>
<p>举例4：B/S交互</p>
<p>普通B/S模式同步：提交请求-&gt;等待服务器处理（这期间客户浏览器不能干任何其他事情）-&gt;处理完毕返回。</p>
<p>AJAX技术异步: 请求通过事件触发-&gt;服务器处理（这期间浏览器仍然可以作其他事情）-&gt;处理完毕。</p>
<p>(2)基于socket的C/S结构程序设计</p>
<pre><code>套接字的本质是通信过程中所要使用的一些缓冲区及一些相关的数据结构。
</code></pre><p>1）.服务器创建监听套接字，并为它关联一个本地地址（IP和端口Port），然后进入监听状态准备接受客户的连接请求。为了接受客户的连接请求，服务器必须调用accept函数。服务器端每接收到一个客户端连接就新建一个套接字负责与该客户会话。</p>
<p>2）.客户端创建套接字后即可调用connect函数去试图连接服务器监听套接字。当服务器端的accept函数返回后，connect函数也返回。此时客户方使用socket函数创建的套接字clientSocket，服务器方使用accept返回的套接字serverSocket，双方就可以通信了。</p>
<p>(3)关于服务器端监听套接字和accept返回的新的套接字的区别</p>
<pre><code>一个连接由server_ip, server_port, client_ip, server_port唯一确定。你可用getsockname和getpeername由某个socket取得。

关于监听套接字和accept返回的新的套接字的区别，借用以下情景说明。好比你去吃饭，饭馆门迎小姐（监听SOCKET）看到你来后和你打招呼，然后（ACCEPT）找来一个服务员小姐（NEW SOCKET）伺候你，然后守在门口继续欢迎（监听）下一个。当然门迎小姐会记录是哪一位服务员小姐招待了你；如再有新客人来，门迎小姐（同一监听SOCKET）又会安排另一位服务员小姐（NEW SOCKET）伺候。门迎小姐走了，伺候每一位客人的服务员小姐不受影响。从以上情景可知连接建立后，客户端用发出连接的那个SOCKET向服务器发数据，是发给服务器新创建的SOCKET，而不是服务器的监听SOCKET。服务器的监听SOCKET永远只是用来接受连接请求。
</code></pre>
        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/TCP协议与UDP协议的区别/" >
  TCP协议与UDP协议的区别
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/TCP协议与UDP协议的区别/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-UDP/">TCP/UDP</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p>TCP协议与UDP协议的区别<a href="http://www.cnblogs.com/bizhu/archive/2012/05/12/2497493.html" target="_blank" rel="external">转载地址</a></p>
<p>首先咱们弄清楚，TCP协议和UCP协议与TCP/IP协议的联系，很多人犯糊涂了，一直都是说TCP/IP协议与UDP协议的区别，我觉得这是没有从本质上弄清楚网络通信！</p>
<h3 id="TCP-IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个。之所以命名为TCP-IP协议，因为TCP-IP协议是两个很重要的协议，就用他两命名了。"><a href="#TCP-IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个。之所以命名为TCP-IP协议，因为TCP-IP协议是两个很重要的协议，就用他两命名了。" class="headerlink" title="TCP/IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个。之所以命名为TCP/IP协议，因为TCP,IP协议是两个很重要的协议，就用他两命名了。"></a>TCP/IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个。之所以命名为TCP/IP协议，因为TCP,IP协议是两个很重要的协议，就用他两命名了。</h3><ul>
<li><p>TCP/IP协议集包括应用层,传输层，网络层，网络访问层。</p>
</li>
<li><p>其中应用层包括:</p>
<blockquote>
<p>超文本传输协议(HTTP):万维网的基本协议.<br>文件传输(TFTP简单文件传输协议):<br>远程登录(Telnet),提供远程访问其它主机功能,它允许用户登录<br>internet主机,并在这台主机上执行命令.<br>网络管理(SNMP简单网络管理协议),该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等.<br>域名系统(DNS),该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. </p>
</blockquote>
</li>
<li><p>其次网络层包括:    </p>
<blockquote>
<p>Internet协议(IP)<br>Internet控制信息协议(ICMP)<br>地址解析协议(ARP)<br>反向地址解析协议(RARP)<br>最后说网络访问层:网络访问层又称作主机到网络层(host-to-network).网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接.</p>
</blockquote>
</li>
</ul>
<p>当然我这里说得不够完善，TCP/IP协议本来就是一门学问，每一个分支都是一个很复杂的流程，但我相信每位学习软件开发的同学都有必要去仔细了解一番。</p>
<ul>
<li>下面我着重讲解一下TCP协议和UDP协议的区别。</li>
</ul>
<p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。</p>
<p>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。<br>详细点说就是：（文章部分转载<a href="http://zhangjiangxing-gmail-com.iteye.com，主要是这个人讲解得很到位，的确很容易使人理解！）" target="_blank" rel="external">http://zhangjiangxing-gmail-com.iteye.com，主要是这个人讲解得很到位，的确很容易使人理解！）</a></p>
<ul>
<li><p>TCP三次握手过程</p>
<blockquote>
<p>1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,<br>主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.<br>2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:<br>我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我<br>3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:”我已收到回复,我现在要开始传输实际数据了<br>这样3次握手就完成了,主机A和主机B 就可以传输数据了.</p>
</blockquote>
</li>
<li><p>3次握手的特点</p>
<blockquote>
<p>没有应用层的数据<br>SYN这个标志位只有在TCP建产连接时才会被置1<br>握手完成后SYN标志位被置0</p>
</blockquote>
</li>
<li><p>TCP建立连接要进行3次握手,而断开连接要进行4次</p>
</li>
</ul>
<blockquote>
<p>1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求<br>2  主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1<br>3 由B 端再提出反方向的关闭请求,将FIN置1<br>4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.<br>由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端<br>和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础</p>
</blockquote>
<ul>
<li><strong>名词解释</strong></li>
</ul>
<ol>
<li><p>ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.</p>
</li>
<li><p>SYN  同步序列号,TCP建立连接时将这个位置1</p>
</li>
<li><p>FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1</p>
</li>
</ol>
<ul>
<li>TCP的包头结构：<blockquote>
<p>源端口 16位<br>目标端口 16位<br>序列号 32位<br>回应序号 32位<br>TCP头长度 4位<br>reserved 6位<br>控制代码 6位<br>窗口大小 16位<br>偏移量 16位<br>校验和 16位<br>选项  32位(可选)</p>
</blockquote>
</li>
</ul>
<p>这样我们得出了TCP包头的最小长度，为20字节。</p>
<h3 id="UDP（User-Data-Protocol，用户数据报协议）"><a href="#UDP（User-Data-Protocol，用户数据报协议）" class="headerlink" title="UDP（User Data Protocol，用户数据报协议）"></a>UDP（User Data Protocol，用户数据报协议）</h3><blockquote>
<p>（1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p>
</blockquote>
<hr>
<blockquote>
<p>（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</p>
</blockquote>
<hr>
<blockquote>
<p>（3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</p>
</blockquote>
<hr>
<blockquote>
<p>（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</p>
</blockquote>
<hr>
<blockquote>
<p>（5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p>
</blockquote>
<hr>
<blockquote>
<p>（6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p>
</blockquote>
<p><em>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</em></p>
<ul>
<li>UDP的包头结构：<blockquote>
<p>源端口 16位<br>目的端口 16位<br>长度 16位<br>校验和 16位</p>
</blockquote>
</li>
</ul>
<h3 id="小结TCP与UDP的区别："><a href="#小结TCP与UDP的区别：" class="headerlink" title="小结TCP与UDP的区别："></a>小结TCP与UDP的区别：</h3><ol>
<li><p>基于连接与无连接；</p>
</li>
<li><p>对系统资源的要求（TCP较多，UDP少）；</p>
</li>
<li><p>UDP程序结构较简单；</p>
</li>
<li><p>流模式与数据报模式 ；</p>
</li>
<li><p>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p>
</li>
</ol>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/http信息含义/" >
  http信息含义
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/http信息含义/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://www.cnblogs.com/lovening/archive/2011/04/28/2031764.html" target="_blank" rel="external">转载地址</a></p>
<h2 id="HTTP头标"><a href="#HTTP头标" class="headerlink" title="HTTP头标"></a>HTTP头标</h2><p>头标由主键/值对组成。它们描述客户端或者服务器的属性、被传输的资源以及应该实现连接。</p>
<ul>
<li>四种不同类型的头标：<blockquote>
<p>1.通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。<br>2.请求头标：允许客户端传递关于自身的信息和希望的响应形式。<br>3.响应头标：服务器和于传递自身信息的响应。<br>4.实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。</p>
</blockquote>
</li>
</ul>
<h2 id="头标格式："><a href="#头标格式：" class="headerlink" title="头标格式：:"></a>头标格式：<name>:<value><crlf></crlf></value></name></h2><ul>
<li>下面描述在HTTP/1.1中用到的头标</li>
</ul>
<p>Accept 定义客户端可以处理的媒体类型，按优先级排序；<br>在一个以逗号为分隔的列表中，可以定义多种类型和使用通配符。例如：Accept: image/jpeg,image/png,<em>/</em><br>Accept-Charset<br>定义客户端可以处理的字符集，按优先级排序；<br>在一个以逗号为分隔的列表中，可以定义多种类型和使用通配符。例如：Accept-Charset: iso-8859-1,*,utf-8</p>
<p>Accept-Encoding 定义客户端可以理解的编码机制。例如：Accept-Encoding:gzip,compress<br>Accept-Language 定义客户端乐于接受的自然语言列表。例如：Accept-Language: en,de</p>
<p>Accept-Ranges<br>一个响应头标，它允许服务器指明：将在给定的偏移和长度处，为资源组成部分的接受请求。<br>该头标的值被理解为请求范围的度量单位。例如Accept-Ranges: bytes或Accept-Ranges: nonea</p>
<p>Age 允许服务器规定自服务器生成该响应以来所经过的时间长度，以秒为单位。<br>该头标主要用于缓存响应。例如：Age: 30</p>
<p>Allow 一个响应头标，它定义一个由位于请求URI中的次源所支持的HTTP方法列表。例如：Allow: GET,PUT</p>
<p>aUTHORIZATION<br>一个响应头标，用于定义访问一种资源所必需的授权（域和被编码的用户ID与口令）。<br>例如：Authorization: Basic YXV0aG9yOnBoaWw=</p>
<p>Cache-Control 一个用于定义缓存指令的通用头标。例如：Cache-Control: max-age=30<br>Connection 一个用于表明是否保存socket连接为开放的通用头标。例如：Connection: close或Connection: keep-alive</p>
<p>Content-Base<br>一种定义基本URI的实体头标，为了在实体范围内解析相对URLs。<br>如果没有定义Content-Base头标解析相对URLs，使用Content-Location URI（存在且绝对）或使用URI请求。<br>例如：Content-Base: Http://www.myweb.com</p>
<p>Content-Encoding 一种介质类型修饰符，标明一个实体是如何编码的。例如：Content-Encoding: zip<br>Content-Language 用于指定在输入流中数据的自然语言类型。例如：Content-Language: en<br>Content-Length 指定包含于请求或响应中数据的字节长度。例如：Content-Length:382</p>
<p>Content-Location<br>指定包含于请求或响应中的资源定位（URI）。<br>如果是一绝。对URL它也作为被解析实体的相对URL的出发点。<br>例如：Content-Location: <a href="http://www.myweb.com/news" target="_blank" rel="external">http://www.myweb.com/news</a></p>
<p>Content-MD5<br>实体的一种MD5摘要，用作校验和。<br>发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。<br>例如：Content-MD5: <base64 128="" of="" md5="" digest=""></base64></p>
<p>Content-Range<br>随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。<br>例如：Content-Range: 1001-2000/5000</p>
<p>Contern-Type 标明发送或者接收的实体的MIME类型。例如：Content-Type: text/html<br>Date 发送HTTP消息的日期。例如：Date: Mon,10PR 18:42:51 GMT</p>
<p>ETag 一种实体头标，它向被发送的资源分派一个唯一的标识符。<br>对于可以使用多种URL请求的资源，ETag可以用于确定实际被发送的资源是否为同一资源。<br>例如：ETag: “208f-419e-30f8dc99”</p>
<p>Expires 指定实体的有效期。例如：Expires: Mon,05 Dec 2008 12:00:00 GMT<br>Form 一种请求头标，给定控制用户代理的人工用户的电子邮件地址。例如：From: webmaster@myweb.com<br>Host 被请求资源的主机名。对于使用HTTP/1.1的请求而言，此域是强制性的。例如：Host: www.myweb.com</p>
<p>If-Modified-Since<br>如果包含了GET请求，导致该请求条件性地依赖于资源上次修改日期。<br>如果出现了此头标，并且自指定日期以来，此资源已被修改，应该反回一个304响应代码。<br>例如：If-Modified-Since: Mon,10PR 18:42:51 GMT</p>
<p>If-Match 如果包含于一个请求，指定一个或者多个实体标记。只发送其ETag与列表中标记区配的资源。<br>例如：If-Match: “208f-419e-308dc99”</p>
<p>If-None-Match<br>如果包含一个请求，指定一个或者多个实体标记。资源的ETag不与列表中的任何一个条件匹配，操作才执行。<br>例如：If-None-Match: “208f-419e-308dc99”</p>
<p>If-Range<br>指定资源的一个实体标记，客户端已经拥有此资源的一个拷贝。必须与Range头标一同使用。<br>如果此实体自上次被客户端检索以来，还不曾修改过，那么服务器只发送指定的范围，否则它将发送整个资源。<br>例如：Range: byte=0-499<crlf>If-Range:”208f-419e-30f8dc99”</crlf></p>
<p>If-Unmodified-Since<br>只有自指定的日期以来，被请求的实体还不曾被修改过，才会返回此实体。<br>例如：If-Unmodified-Since:Mon,10PR 18:42:51 GMT</p>
<p>Last-Modified 指定被请求资源上次被修改的日期和时间。例如：Last-Modified: Mon,10PR 18:42:51 GMT<br>Location<br>对于一个已经移动的资源，用于重定向请求者至另一个位置。<br>与状态编码302（暂时移动）或者301（永久性移动）配合使用。<br>例如：Location: <a href="http://www2.myweb.com/index.jsp" target="_blank" rel="external">http://www2.myweb.com/index.jsp</a></p>
<p>Max-Forwards<br>一个用于TRACE方法的请求头标，以指定代理或网关的最大数目，该请求通过网关才得以路由。<br>在通过请求传递之前，代理或网关应该减少此数目。例如：Max-Forwards: 3</p>
<p>Pragma 一个通用头标，它发送实现相关的信息。例如：Pragma: no-cache<br>Proxy-Authenticate<br>类似于WWW-Authenticate，便是有意请求只来自请求链（代理）的下一个服务器的认证。<br>例如：Proxy-Authenticate: Basic realm-admin</p>
<p>Proxy-Proxy-Authorization<br>类似于授权，但并非有意传递任何比在即时服务器链中更进一步的内容。<br>例如：Proxy-Proxy-Authorization: Basic YXV0aG9yOnBoaWw=</p>
<p>Public 列表显示服务器所支持的方法集。例如：Public: OPTIONS,MGET,MHEAD,GET,HEAD<br>Range 指定一种度量单位和一个部分被请求资源的偏移范围。例如：Range: bytes=206-5513</p>
<p>Refener<br>一种请求头标域，标明产生请求的初始资源。对于HTML表单，它包含此表单的Web页面的地址。<br>例如：Refener: <a href="http://www.myweb.com/news/search.html" target="_blank" rel="external">http://www.myweb.com/news/search.html</a></p>
<p>Retry-After<br>一种响应头标域，由服务器与状态编码503（无法提供服务）配合发送，以标明再次请求之前应该等待多长时间。<br>此时间即可以是一种日期，也可以是一种秒单位。例如：Retry-After: 18</p>
<p>Server 一种标明Web服务器软件及其版本号的头标。例如：Server: Apache/2.0.46(Win32)<br>Transfer-Encoding 一种通用头标，标明对应被接受方反向的消息体实施变换的类型。例如：Transfer-Encoding: chunked</p>
<p>Upgrade<br>允许服务器指定一种新的协议或者新的协议版本，与响应编码101（切换协议）配合使用。<br>例如：Upgrade: HTTP/2.0</p>
<p>User-Agent<br>定义用于产生请求的软件类型（典型的如Web浏览器）。<br>例如：User-Agent: Mozilla/4.0(compatible; MSIE 5.5; Windows NT; DigExt)</p>
<p>Vary 一个响应头标，用于表示使用服务器驱动的协商从可用的响应表示中选择响应实体。例如：Vary: *<br>Via 一个包含所有中间主机和协议的通用头标，用于满足请求。例如：Via: 1.0 fred.com, 1.1 wilma.com<br>Warning 用于提供关于响应状态补充信息的响应头标。例如：Warning: 99 www.myweb.com Piano needs tuning</p>
<p>www-Authenticate<br>一个提示用户代理提供用户名和口令的响应头标，与状态编码401（未授权）配合使用。响应一个授权头标。<br>例如：www-Authenticate: Basic realm=zxm.mgmt</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/24/http请求状态码/" >
  http请求状态码
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/24/http请求状态码/"><span class="article-date">
  2016-05-24
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/网络/">网络</a></li></ul></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http状态码/">http状态码</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <p><a href="http://blog.csdn.net/caoyishuai/article/details/7937023" target="_blank" rel="external">转载地址</a></p>
<h2 id="http状态返回代码-1xx（临时响应）"><a href="#http状态返回代码-1xx（临时响应）" class="headerlink" title="http状态返回代码 1xx（临时响应）"></a>http状态返回代码 1xx（临时响应）</h2><ul>
<li>表示临时响应并需要请求者继续执行操作的状态代码。</li>
</ul>
<h2 id="http状态返回代码-代码-说明"><a href="#http状态返回代码-代码-说明" class="headerlink" title="http状态返回代码 代码   说明"></a>http状态返回代码 代码   说明</h2><ul>
<li>100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 </li>
<li>101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</li>
</ul>
<h2 id="http状态返回代码-2xx-（成功）"><a href="#http状态返回代码-2xx-（成功）" class="headerlink" title="http状态返回代码 2xx （成功）"></a>http状态返回代码 2xx （成功）</h2><p>表示成功处理了请求的状态代码。</p>
<h3 id="http状态返回代码-代码-说明-1"><a href="#http状态返回代码-代码-说明-1" class="headerlink" title="http状态返回代码 代码   说明"></a>http状态返回代码 代码   说明</h3><ul>
<li>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li>
<li>201   （已创建）  请求成功并且服务器创建了新的资源。</li>
<li>202   （已接受）  服务器已接受请求，但尚未处理。</li>
<li>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。</li>
<li>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。</li>
<li>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li>
<li>206   （部分内容）  服务器成功处理了部分 GET 请求。</li>
</ul>
<h2 id="http状态返回代码-3xx-（重定向）"><a href="#http状态返回代码-3xx-（重定向）" class="headerlink" title="http状态返回代码 3xx （重定向）"></a>http状态返回代码 3xx （重定向）</h2><ul>
<li>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</li>
</ul>
<h3 id="http状态返回代码-代码-说明-2"><a href="#http状态返回代码-代码-说明-2" class="headerlink" title="http状态返回代码 代码   说明"></a>http状态返回代码 代码   说明</h3><ul>
<li>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li>
<li>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>
<li>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li>
<li>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li>
<li>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li>
<li>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
</ul>
<h2 id="http状态返回代码-4xx（请求错误）"><a href="#http状态返回代码-4xx（请求错误）" class="headerlink" title="http状态返回代码 4xx（请求错误）"></a>http状态返回代码 4xx（请求错误）</h2><ul>
<li>这些状态代码表示请求可能出错，妨碍了服务器的处理。</li>
</ul>
<h3 id="http状态返回代码-代码-说明-3"><a href="#http状态返回代码-代码-说明-3" class="headerlink" title="http状态返回代码 代码   说明"></a>http状态返回代码 代码   说明</h3><ul>
<li>400   （错误请求） 服务器不理解请求的语法。</li>
<li>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403   （禁止） 服务器拒绝请求。</li>
<li>404   （未找到） 服务器找不到请求的网页。</li>
<li>405   （方法禁用） 禁用请求中指定的方法。</li>
<li>406   （不接受） 无法使用请求的内容特性响应请求的网页。</li>
<li>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li>
<li>408   （请求超时）  服务器等候请求时发生超时。</li>
<li>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li>
<li>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。</li>
<li>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li>
<li>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li>
<li>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li>
<li>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li>
<li>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。</li>
<li>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li>
<li>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li>
</ul>
<h2 id="http状态返回代码-5xx（服务器错误）"><a href="#http状态返回代码-5xx（服务器错误）" class="headerlink" title="http状态返回代码 5xx（服务器错误）"></a>http状态返回代码 5xx（服务器错误）</h2><ul>
<li>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</li>
</ul>
<h3 id="http状态返回代码-代码-说明-4"><a href="#http状态返回代码-代码-说明-4" class="headerlink" title="http状态返回代码 代码   说明"></a>http状态返回代码 代码   说明</h3><ul>
<li>500   （服务器内部错误）  服务器遇到错误，无法完成请求。</li>
<li>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li>
<li>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li>
<li>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li>
<li>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li>
<li>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 </li>
</ul>
<h2 id="一些常见的http状态返回代码为："><a href="#一些常见的http状态返回代码为：" class="headerlink" title="一些常见的http状态返回代码为："></a>一些常见的http状态返回代码为：</h2><ul>
<li>200 - 服务器成功返回网页</li>
<li>404 - 请求的网页不存在</li>
<li>503 - 服务不可用</li>
</ul>

        
      </div>
    </div>

  
    </div>
  






          <div class="main-footer">
  
    © 2016 findmoon-白色蜗牛 - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
